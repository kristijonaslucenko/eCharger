
menu.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003c10  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000004a6  00800060  00003c10  00003ca4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000308  00800506  00800506  0000414a  2**0
                  ALLOC
  3 .stab         00004230  00000000  00000000  0000414c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001132  00000000  00000000  0000837c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      0000002f  00000000  00000000  000094ae  2**0
                  CONTENTS, READONLY
  6 .debug_aranges 00000470  00000000  00000000  000094dd  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00006a26  00000000  00000000  0000994d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001c39  00000000  00000000  00010373  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002872  00000000  00000000  00011fac  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000ae8  00000000  00000000  00014820  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000108a  00000000  00000000  00015308  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00002b9c  00000000  00000000  00016392  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000388  00000000  00000000  00018f2e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 c9 00 	jmp	0x192	; 0x192 <__ctors_end>
       4:	0c 94 f3 10 	jmp	0x21e6	; 0x21e6 <__vector_1>
       8:	0c 94 d7 10 	jmp	0x21ae	; 0x21ae <__vector_2>
       c:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      10:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      14:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      18:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      1c:	0c 94 81 13 	jmp	0x2702	; 0x2702 <__vector_7>
      20:	0c 94 9d 13 	jmp	0x273a	; 0x273a <__vector_8>
      24:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      28:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      2c:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      30:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      34:	0c 94 9d 02 	jmp	0x53a	; 0x53a <__vector_13>
      38:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      3c:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      40:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      44:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      48:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      4c:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>
      50:	0c 94 e6 00 	jmp	0x1cc	; 0x1cc <__bad_interrupt>

00000054 <__c.2006>:
      54:	6e 61 6e 00                                         nan.

00000058 <__c.2004>:
      58:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
      68:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
      78:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
      88:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
      98:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
      a8:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
      b8:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
      c8:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
      d8:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
      e8:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
      f8:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     108:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     118:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     128:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     138:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     148:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000156 <pstr_inf>:
     156:	49 4e 46                                            INF

00000159 <pstr_inity>:
     159:	49 4e 49 54 59                                      INITY

0000015e <pstr_nan>:
     15e:	4e 41 4e                                            NAN

00000161 <pwr_p10>:
     161:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     171:	ca 1b 0e 5a ae c5 9d 74                             ...Z...t

00000179 <pwr_m10>:
     179:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     189:	95 95 e6 24 1f b1 4f 0a 00                          ...$..O..

00000192 <__ctors_end>:
     192:	11 24       	eor	r1, r1
     194:	1f be       	out	0x3f, r1	; 63
     196:	cf e5       	ldi	r28, 0x5F	; 95
     198:	d8 e0       	ldi	r29, 0x08	; 8
     19a:	de bf       	out	0x3e, r29	; 62
     19c:	cd bf       	out	0x3d, r28	; 61

0000019e <__do_copy_data>:
     19e:	15 e0       	ldi	r17, 0x05	; 5
     1a0:	a0 e6       	ldi	r26, 0x60	; 96
     1a2:	b0 e0       	ldi	r27, 0x00	; 0
     1a4:	e0 e1       	ldi	r30, 0x10	; 16
     1a6:	fc e3       	ldi	r31, 0x3C	; 60
     1a8:	02 c0       	rjmp	.+4      	; 0x1ae <__do_copy_data+0x10>
     1aa:	05 90       	lpm	r0, Z+
     1ac:	0d 92       	st	X+, r0
     1ae:	a6 30       	cpi	r26, 0x06	; 6
     1b0:	b1 07       	cpc	r27, r17
     1b2:	d9 f7       	brne	.-10     	; 0x1aa <__do_copy_data+0xc>

000001b4 <__do_clear_bss>:
     1b4:	28 e0       	ldi	r18, 0x08	; 8
     1b6:	a6 e0       	ldi	r26, 0x06	; 6
     1b8:	b5 e0       	ldi	r27, 0x05	; 5
     1ba:	01 c0       	rjmp	.+2      	; 0x1be <.do_clear_bss_start>

000001bc <.do_clear_bss_loop>:
     1bc:	1d 92       	st	X+, r1

000001be <.do_clear_bss_start>:
     1be:	ae 30       	cpi	r26, 0x0E	; 14
     1c0:	b2 07       	cpc	r27, r18
     1c2:	e1 f7       	brne	.-8      	; 0x1bc <.do_clear_bss_loop>
     1c4:	0e 94 f2 0f 	call	0x1fe4	; 0x1fe4 <main>
     1c8:	0c 94 06 1e 	jmp	0x3c0c	; 0x3c0c <_exit>

000001cc <__bad_interrupt>:
     1cc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001d0 <waitAndScanKeyPad>:
meanwhile. Let's say, ADC readings are being sampled every
4 seconds, thus keypad is scanned four seconds and then 
sample is made.
-----------------------------------------------------*/
bool waitAndScanKeyPad(){
	if(second == NsampleSeconds) {
     1d0:	80 91 a0 05 	lds	r24, 0x05A0
     1d4:	81 30       	cpi	r24, 0x01	; 1
     1d6:	19 f4       	brne	.+6      	; 0x1de <waitAndScanKeyPad+0xe>
 		second = 0;
     1d8:	10 92 a0 05 	sts	0x05A0, r1
		return true;
     1dc:	08 95       	ret
	}else{
		if (scanKeyPad() == 1)
     1de:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
     1e2:	81 30       	cpi	r24, 0x01	; 1
     1e4:	49 f4       	brne	.+18     	; 0x1f8 <waitAndScanKeyPad+0x28>
		{
			if (returnKey() == 'B')
     1e6:	0e 94 0c 09 	call	0x1218	; 0x1218 <returnKey>
     1ea:	82 34       	cpi	r24, 0x42	; 66
     1ec:	39 f4       	brne	.+14     	; 0x1fc <waitAndScanKeyPad+0x2c>
			{
				cancelled = true;
     1ee:	81 e0       	ldi	r24, 0x01	; 1
     1f0:	80 93 06 05 	sts	0x0506, r24
			}
		}
		return false;
     1f4:	80 e0       	ldi	r24, 0x00	; 0
     1f6:	08 95       	ret
     1f8:	80 e0       	ldi	r24, 0x00	; 0
     1fa:	08 95       	ret
     1fc:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     1fe:	08 95       	ret

00000200 <progressBar>:
void progressBar(double _energy)
Simple function to draw some graphical simulation
representation. Uses _energy as input
-----------------------------------------------------*/
void progressBar(double _energy){
	int pos_value = (int)floor(_energy/5);
     200:	20 e0       	ldi	r18, 0x00	; 0
     202:	30 e0       	ldi	r19, 0x00	; 0
     204:	40 ea       	ldi	r20, 0xA0	; 160
     206:	50 e4       	ldi	r21, 0x40	; 64
     208:	0e 94 35 14 	call	0x286a	; 0x286a <__divsf3>
     20c:	0e 94 0b 15 	call	0x2a16	; 0x2a16 <floor>
     210:	0e 94 9d 14 	call	0x293a	; 0x293a <__fixsfsi>
     214:	26 2f       	mov	r18, r22

	GoTo(pos_value,3);
     216:	63 e0       	ldi	r22, 0x03	; 3
     218:	82 2f       	mov	r24, r18
     21a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
	lcd_data_write(ful5x8font);
     21e:	80 91 60 00 	lds	r24, 0x0060
     222:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
     226:	08 95       	ret

00000228 <initADC>:
/* -----------------------------------------------------
void initADC()
ADC initialization function
-----------------------------------------------------*/
void initADC(){
	ADMUX|=  (1<<REFS0);  //(1<<REFS1) |(1<<REFS0) the internal adcref: external ref  (1<<REFS0); and adc0 selected
     228:	3e 9a       	sbi	0x07, 6	; 7
	ADCSRA|= (1<<ADEN);   //enable triggered sampling  |(1<<ADATE)
     22a:	37 9a       	sbi	0x06, 7	; 6
     22c:	08 95       	ret

0000022e <doSample>:
and returns it's value
-----------------------------------------------------*/
unsigned int doSample(){
	
	unsigned int value=0;
	ADCSRA|=(1<<ADSC);
     22e:	36 9a       	sbi	0x06, 6	; 6
	while((ADCSRA & (1<<ADSC)));
     230:	36 99       	sbic	0x06, 6	; 6
     232:	fe cf       	rjmp	.-4      	; 0x230 <doSample+0x2>
	
	value= ADCL+ ADCH*256;
     234:	24 b1       	in	r18, 0x04	; 4
     236:	35 b1       	in	r19, 0x05	; 5
     238:	93 2f       	mov	r25, r19
     23a:	80 e0       	ldi	r24, 0x00	; 0
     23c:	82 0f       	add	r24, r18
     23e:	91 1d       	adc	r25, r1
	return value&0x3FF;
     240:	9c 01       	movw	r18, r24
     242:	33 70       	andi	r19, 0x03	; 3
}
     244:	82 2f       	mov	r24, r18
     246:	93 2f       	mov	r25, r19
     248:	08 95       	ret

0000024a <onADC>:
/* -----------------------------------------------------
void onADC()
Turns on ADC.
-----------------------------------------------------*/
void onADC(){
	ADCSRA|= (1<<ADEN);
     24a:	37 9a       	sbi	0x06, 7	; 6
     24c:	08 95       	ret

0000024e <initCharge>:
modules and drawing graphical template.
-----------------------------------------------------*/

void initCharge(void)
{
	lcd_init();
     24e:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <lcd_init>
	keypad_init();
     252:	0e 94 0f 09 	call	0x121e	; 0x121e <keypad_init>
	initADC();
     256:	0e 94 14 01 	call	0x228	; 0x228 <initADC>
	init_timer1(0,1);
     25a:	61 e0       	ldi	r22, 0x01	; 1
     25c:	80 e0       	ldi	r24, 0x00	; 0
     25e:	0e 94 62 13 	call	0x26c4	; 0x26c4 <init_timer1>
	USART_Init(64);
     262:	80 e4       	ldi	r24, 0x40	; 64
     264:	90 e0       	ldi	r25, 0x00	; 0
     266:	0e 94 c1 13 	call	0x2782	; 0x2782 <USART_Init>
	onADC();
     26a:	0e 94 25 01 	call	0x24a	; 0x24a <onADC>
	
	lcdClear();
     26e:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     272:	85 ea       	ldi	r24, 0xA5	; 165
     274:	9e e0       	ldi	r25, 0x0E	; 14
     276:	01 97       	sbiw	r24, 0x01	; 1
     278:	f1 f7       	brne	.-4      	; 0x276 <initCharge+0x28>
     27a:	00 c0       	rjmp	.+0      	; 0x27c <initCharge+0x2e>
     27c:	00 00       	nop
	_delay_ms(15);
	GoTo(0,0);
     27e:	60 e0       	ldi	r22, 0x00	; 0
     280:	80 e0       	ldi	r24, 0x00	; 0
     282:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
	LCDPutString("Energy:          mWs");
     286:	81 ee       	ldi	r24, 0xE1	; 225
     288:	91 e0       	ldi	r25, 0x01	; 1
     28a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     28e:	83 ec       	ldi	r24, 0xC3	; 195
     290:	99 e0       	ldi	r25, 0x09	; 9
     292:	01 97       	sbiw	r24, 0x01	; 1
     294:	f1 f7       	brne	.-4      	; 0x292 <initCharge+0x44>
     296:	00 c0       	rjmp	.+0      	; 0x298 <initCharge+0x4a>
     298:	00 00       	nop
	_delay_ms(10);
	GoTo(0,1);
     29a:	61 e0       	ldi	r22, 0x01	; 1
     29c:	80 e0       	ldi	r24, 0x00	; 0
     29e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
     2a2:	83 ec       	ldi	r24, 0xC3	; 195
     2a4:	99 e0       	ldi	r25, 0x09	; 9
     2a6:	01 97       	sbiw	r24, 0x01	; 1
     2a8:	f1 f7       	brne	.-4      	; 0x2a6 <initCharge+0x58>
     2aa:	00 c0       	rjmp	.+0      	; 0x2ac <initCharge+0x5e>
     2ac:	00 00       	nop
	_delay_ms(10);
	LCDPutString("Power:           mW");
     2ae:	86 ef       	ldi	r24, 0xF6	; 246
     2b0:	91 e0       	ldi	r25, 0x01	; 1
     2b2:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     2b6:	83 ec       	ldi	r24, 0xC3	; 195
     2b8:	99 e0       	ldi	r25, 0x09	; 9
     2ba:	01 97       	sbiw	r24, 0x01	; 1
     2bc:	f1 f7       	brne	.-4      	; 0x2ba <initCharge+0x6c>
     2be:	00 c0       	rjmp	.+0      	; 0x2c0 <initCharge+0x72>
     2c0:	00 00       	nop
	_delay_ms(10);
	GoTo(0,2);
     2c2:	62 e0       	ldi	r22, 0x02	; 2
     2c4:	80 e0       	ldi	r24, 0x00	; 0
     2c6:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
	LCDPutString("Charging progress:");
     2ca:	8a e0       	ldi	r24, 0x0A	; 10
     2cc:	92 e0       	ldi	r25, 0x02	; 2
     2ce:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
	sei();
     2d2:	78 94       	sei
     2d4:	08 95       	ret

000002d6 <offADC>:
/* -----------------------------------------------------
void offADC()
Turns off ADC.
-----------------------------------------------------*/
void offADC() {
	ADCSRA &=~(1<<ADEN);
     2d6:	37 98       	cbi	0x06, 7	; 6
     2d8:	08 95       	ret

000002da <chargeADC>:
bool charge()
Main function that returns true and stores energy used value
in energy variable. It returns true whenever energy value 
reached desired one or user's cancelled it.
-----------------------------------------------------*/
bool chargeADC(){
     2da:	cf 92       	push	r12
     2dc:	df 92       	push	r13
     2de:	ef 92       	push	r14
     2e0:	ff 92       	push	r15

 	while(!waitAndScanKeyPad());
     2e2:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <waitAndScanKeyPad>
     2e6:	88 23       	and	r24, r24
     2e8:	e1 f3       	breq	.-8      	; 0x2e2 <chargeADC+0x8>
	if (cancelled)
     2ea:	80 91 06 05 	lds	r24, 0x0506
     2ee:	88 23       	and	r24, r24
     2f0:	21 f0       	breq	.+8      	; 0x2fa <chargeADC+0x20>
	{
		offADC();
     2f2:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <offADC>
		return true;
     2f6:	81 e0       	ldi	r24, 0x01	; 1
     2f8:	15 c1       	rjmp	.+554    	; 0x524 <chargeADC+0x24a>
	}
		data = doSample();
     2fa:	0e 94 17 01 	call	0x22e	; 0x22e <doSample>
     2fe:	90 93 08 05 	sts	0x0508, r25
     302:	80 93 07 05 	sts	0x0507, r24
		
		double power = data/(0.4*1023);   //mW  uW 0.4*1.023
     306:	bc 01       	movw	r22, r24
     308:	80 e0       	ldi	r24, 0x00	; 0
     30a:	90 e0       	ldi	r25, 0x00	; 0
     30c:	0e 94 ce 14 	call	0x299c	; 0x299c <__floatunsisf>
     310:	2a e9       	ldi	r18, 0x9A	; 154
     312:	39 e9       	ldi	r19, 0x99	; 153
     314:	4c ec       	ldi	r20, 0xCC	; 204
     316:	53 e4       	ldi	r21, 0x43	; 67
     318:	0e 94 35 14 	call	0x286a	; 0x286a <__divsf3>
     31c:	c6 2e       	mov	r12, r22
     31e:	d7 2e       	mov	r13, r23
     320:	e8 2e       	mov	r14, r24
     322:	f9 2e       	mov	r15, r25
		if (power == 0)
     324:	20 e0       	ldi	r18, 0x00	; 0
     326:	30 e0       	ldi	r19, 0x00	; 0
     328:	a9 01       	movw	r20, r18
     32a:	0e 94 31 14 	call	0x2862	; 0x2862 <__cmpsf2>
     32e:	81 11       	cpse	r24, r1
     330:	09 c0       	rjmp	.+18     	; 0x344 <chargeADC+0x6a>
		{
			energy = 0;
     332:	10 92 0d 05 	sts	0x050D, r1
     336:	10 92 0e 05 	sts	0x050E, r1
     33a:	10 92 0f 05 	sts	0x050F, r1
     33e:	10 92 10 05 	sts	0x0510, r1
     342:	16 c0       	rjmp	.+44     	; 0x370 <chargeADC+0x96>
		}
		else
		{
			energy = energy + power;
     344:	2c 2d       	mov	r18, r12
     346:	3d 2d       	mov	r19, r13
     348:	4e 2d       	mov	r20, r14
     34a:	5f 2d       	mov	r21, r15
     34c:	60 91 0d 05 	lds	r22, 0x050D
     350:	70 91 0e 05 	lds	r23, 0x050E
     354:	80 91 0f 05 	lds	r24, 0x050F
     358:	90 91 10 05 	lds	r25, 0x0510
     35c:	0e 94 cd 13 	call	0x279a	; 0x279a <__addsf3>
     360:	60 93 0d 05 	sts	0x050D, r22
     364:	70 93 0e 05 	sts	0x050E, r23
     368:	80 93 0f 05 	sts	0x050F, r24
     36c:	90 93 10 05 	sts	0x0510, r25
		}
		
		//Only update lcd if needed
		if(Last_power!= power) {
     370:	2c 2d       	mov	r18, r12
     372:	3d 2d       	mov	r19, r13
     374:	4e 2d       	mov	r20, r14
     376:	5f 2d       	mov	r21, r15
     378:	60 91 09 05 	lds	r22, 0x0509
     37c:	70 91 0a 05 	lds	r23, 0x050A
     380:	80 91 0b 05 	lds	r24, 0x050B
     384:	90 91 0c 05 	lds	r25, 0x050C
     388:	0e 94 31 14 	call	0x2862	; 0x2862 <__cmpsf2>
     38c:	88 23       	and	r24, r24
     38e:	09 f4       	brne	.+2      	; 0x392 <chargeADC+0xb8>
     390:	4f c0       	rjmp	.+158    	; 0x430 <chargeADC+0x156>
			if(snprintf(buffer,8, "%.3f \r\n", (double) power )) {
     392:	ff 92       	push	r15
     394:	ef 92       	push	r14
     396:	df 92       	push	r13
     398:	cf 92       	push	r12
     39a:	8d e1       	ldi	r24, 0x1D	; 29
     39c:	92 e0       	ldi	r25, 0x02	; 2
     39e:	9f 93       	push	r25
     3a0:	8f 93       	push	r24
     3a2:	1f 92       	push	r1
     3a4:	88 e0       	ldi	r24, 0x08	; 8
     3a6:	8f 93       	push	r24
     3a8:	84 ea       	ldi	r24, 0xA4	; 164
     3aa:	95 e0       	ldi	r25, 0x05	; 5
     3ac:	9f 93       	push	r25
     3ae:	8f 93       	push	r24
     3b0:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
     3b4:	2d b7       	in	r18, 0x3d	; 61
     3b6:	3e b7       	in	r19, 0x3e	; 62
     3b8:	26 5f       	subi	r18, 0xF6	; 246
     3ba:	3f 4f       	sbci	r19, 0xFF	; 255
     3bc:	0f b6       	in	r0, 0x3f	; 63
     3be:	f8 94       	cli
     3c0:	3e bf       	out	0x3e, r19	; 62
     3c2:	0f be       	out	0x3f, r0	; 63
     3c4:	2d bf       	out	0x3d, r18	; 61
     3c6:	89 2b       	or	r24, r25
     3c8:	79 f1       	breq	.+94     	; 0x428 <chargeADC+0x14e>
				GoTo(10,1);
     3ca:	61 e0       	ldi	r22, 0x01	; 1
     3cc:	8a e0       	ldi	r24, 0x0A	; 10
     3ce:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
     3d2:	83 ec       	ldi	r24, 0xC3	; 195
     3d4:	99 e0       	ldi	r25, 0x09	; 9
     3d6:	01 97       	sbiw	r24, 0x01	; 1
     3d8:	f1 f7       	brne	.-4      	; 0x3d6 <chargeADC+0xfc>
     3da:	00 c0       	rjmp	.+0      	; 0x3dc <chargeADC+0x102>
     3dc:	00 00       	nop
			
				_delay_ms(10);
				LCDPutString("       ");
     3de:	8c eb       	ldi	r24, 0xBC	; 188
     3e0:	93 e0       	ldi	r25, 0x03	; 3
     3e2:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     3e6:	83 ec       	ldi	r24, 0xC3	; 195
     3e8:	99 e0       	ldi	r25, 0x09	; 9
     3ea:	01 97       	sbiw	r24, 0x01	; 1
     3ec:	f1 f7       	brne	.-4      	; 0x3ea <chargeADC+0x110>
     3ee:	00 c0       	rjmp	.+0      	; 0x3f0 <chargeADC+0x116>
     3f0:	00 00       	nop
				_delay_ms(10);
				GoTo(10,1);
     3f2:	61 e0       	ldi	r22, 0x01	; 1
     3f4:	8a e0       	ldi	r24, 0x0A	; 10
     3f6:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
     3fa:	83 ec       	ldi	r24, 0xC3	; 195
     3fc:	99 e0       	ldi	r25, 0x09	; 9
     3fe:	01 97       	sbiw	r24, 0x01	; 1
     400:	f1 f7       	brne	.-4      	; 0x3fe <chargeADC+0x124>
     402:	00 c0       	rjmp	.+0      	; 0x404 <chargeADC+0x12a>
     404:	00 00       	nop
				_delay_ms(10);
				LCDPutString(buffer);
     406:	84 ea       	ldi	r24, 0xA4	; 164
     408:	95 e0       	ldi	r25, 0x05	; 5
     40a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
				Last_power = power;
     40e:	8c 2d       	mov	r24, r12
     410:	9d 2d       	mov	r25, r13
     412:	ae 2d       	mov	r26, r14
     414:	bf 2d       	mov	r27, r15
     416:	80 93 09 05 	sts	0x0509, r24
     41a:	90 93 0a 05 	sts	0x050A, r25
     41e:	a0 93 0b 05 	sts	0x050B, r26
     422:	b0 93 0c 05 	sts	0x050C, r27
     426:	04 c0       	rjmp	.+8      	; 0x430 <chargeADC+0x156>
				}else{
				LCDPutString("not converted");
     428:	85 e2       	ldi	r24, 0x25	; 37
     42a:	92 e0       	ldi	r25, 0x02	; 2
     42c:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
			}
		}
		
		
		
		if (buffer == ultoa(energy, buffer, 10)) {  //last number is the radix
     430:	60 91 0d 05 	lds	r22, 0x050D
     434:	70 91 0e 05 	lds	r23, 0x050E
     438:	80 91 0f 05 	lds	r24, 0x050F
     43c:	90 91 10 05 	lds	r25, 0x0510
     440:	0e 94 a2 14 	call	0x2944	; 0x2944 <__fixunssfsi>
     444:	2a e0       	ldi	r18, 0x0A	; 10
     446:	30 e0       	ldi	r19, 0x00	; 0
     448:	44 ea       	ldi	r20, 0xA4	; 164
     44a:	55 e0       	ldi	r21, 0x05	; 5
     44c:	0e 94 38 1b 	call	0x3670	; 0x3670 <ultoa>
     450:	84 5a       	subi	r24, 0xA4	; 164
     452:	95 40       	sbci	r25, 0x05	; 5
     454:	09 f0       	breq	.+2      	; 0x458 <chargeADC+0x17e>
     456:	3f c0       	rjmp	.+126    	; 0x4d6 <chargeADC+0x1fc>
			snprintf(buffer,8, "%.1f \r\n", (double) energy );
     458:	80 91 10 05 	lds	r24, 0x0510
     45c:	8f 93       	push	r24
     45e:	80 91 0f 05 	lds	r24, 0x050F
     462:	8f 93       	push	r24
     464:	80 91 0e 05 	lds	r24, 0x050E
     468:	8f 93       	push	r24
     46a:	80 91 0d 05 	lds	r24, 0x050D
     46e:	8f 93       	push	r24
     470:	83 e3       	ldi	r24, 0x33	; 51
     472:	92 e0       	ldi	r25, 0x02	; 2
     474:	9f 93       	push	r25
     476:	8f 93       	push	r24
     478:	1f 92       	push	r1
     47a:	88 e0       	ldi	r24, 0x08	; 8
     47c:	8f 93       	push	r24
     47e:	84 ea       	ldi	r24, 0xA4	; 164
     480:	95 e0       	ldi	r25, 0x05	; 5
     482:	9f 93       	push	r25
     484:	8f 93       	push	r24
     486:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
			GoTo(10,0);
     48a:	60 e0       	ldi	r22, 0x00	; 0
     48c:	8a e0       	ldi	r24, 0x0A	; 10
     48e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
			LCDPutString("      ");
     492:	8d eb       	ldi	r24, 0xBD	; 189
     494:	93 e0       	ldi	r25, 0x03	; 3
     496:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     49a:	83 ec       	ldi	r24, 0xC3	; 195
     49c:	99 e0       	ldi	r25, 0x09	; 9
     49e:	01 97       	sbiw	r24, 0x01	; 1
     4a0:	f1 f7       	brne	.-4      	; 0x49e <chargeADC+0x1c4>
     4a2:	00 c0       	rjmp	.+0      	; 0x4a4 <chargeADC+0x1ca>
     4a4:	00 00       	nop
			_delay_ms(10);
			GoTo(10,0);
     4a6:	60 e0       	ldi	r22, 0x00	; 0
     4a8:	8a e0       	ldi	r24, 0x0A	; 10
     4aa:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
			LCDPutString(buffer);
     4ae:	84 ea       	ldi	r24, 0xA4	; 164
     4b0:	95 e0       	ldi	r25, 0x05	; 5
     4b2:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     4b6:	83 ec       	ldi	r24, 0xC3	; 195
     4b8:	99 e0       	ldi	r25, 0x09	; 9
     4ba:	01 97       	sbiw	r24, 0x01	; 1
     4bc:	f1 f7       	brne	.-4      	; 0x4ba <chargeADC+0x1e0>
     4be:	00 c0       	rjmp	.+0      	; 0x4c0 <chargeADC+0x1e6>
     4c0:	00 00       	nop
     4c2:	2d b7       	in	r18, 0x3d	; 61
     4c4:	3e b7       	in	r19, 0x3e	; 62
     4c6:	26 5f       	subi	r18, 0xF6	; 246
     4c8:	3f 4f       	sbci	r19, 0xFF	; 255
     4ca:	0f b6       	in	r0, 0x3f	; 63
     4cc:	f8 94       	cli
     4ce:	3e bf       	out	0x3e, r19	; 62
     4d0:	0f be       	out	0x3f, r0	; 63
     4d2:	2d bf       	out	0x3d, r18	; 61
     4d4:	04 c0       	rjmp	.+8      	; 0x4de <chargeADC+0x204>
			_delay_ms(10);
			}else{
			LCDPutString("not converted correct");
     4d6:	8b e3       	ldi	r24, 0x3B	; 59
     4d8:	92 e0       	ldi	r25, 0x02	; 2
     4da:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
		}
		//draw a progress bar along with value sampling
		if (energy <= 100)
     4de:	c0 90 0d 05 	lds	r12, 0x050D
     4e2:	d0 90 0e 05 	lds	r13, 0x050E
     4e6:	e0 90 0f 05 	lds	r14, 0x050F
     4ea:	f0 90 10 05 	lds	r15, 0x0510
     4ee:	20 e0       	ldi	r18, 0x00	; 0
     4f0:	30 e0       	ldi	r19, 0x00	; 0
     4f2:	48 ec       	ldi	r20, 0xC8	; 200
     4f4:	52 e4       	ldi	r21, 0x42	; 66
     4f6:	c7 01       	movw	r24, r14
     4f8:	b6 01       	movw	r22, r12
     4fa:	0e 94 31 14 	call	0x2862	; 0x2862 <__cmpsf2>
     4fe:	18 16       	cp	r1, r24
     500:	34 f0       	brlt	.+12     	; 0x50e <chargeADC+0x234>
		{
			progressBar(energy);
     502:	c7 01       	movw	r24, r14
     504:	b6 01       	movw	r22, r12
     506:	0e 94 00 01 	call	0x200	; 0x200 <progressBar>
			LCDPutString("Charging is complete");
			offADC();
			return true;
		
	}
	return false;
     50a:	80 e0       	ldi	r24, 0x00	; 0
     50c:	0b c0       	rjmp	.+22     	; 0x524 <chargeADC+0x24a>
		{
			progressBar(energy);
		}
		else //simulation has reached desired value energy <= 100 and true value returned
		{
			GoTo(0,3);
     50e:	63 e0       	ldi	r22, 0x03	; 3
     510:	80 e0       	ldi	r24, 0x00	; 0
     512:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
			LCDPutString("Charging is complete");
     516:	81 e5       	ldi	r24, 0x51	; 81
     518:	92 e0       	ldi	r25, 0x02	; 2
     51a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
			offADC();
     51e:	0e 94 6b 01 	call	0x2d6	; 0x2d6 <offADC>
			return true;
     522:	81 e0       	ldi	r24, 0x01	; 1
		
	}
	return false;
}
     524:	ff 90       	pop	r15
     526:	ef 90       	pop	r14
     528:	df 90       	pop	r13
     52a:	cf 90       	pop	r12
     52c:	08 95       	ret

0000052e <startCharge>:
is done
-----------------------------------------------------*/

bool startCharge(){
	//initCharge();
	while(!chargeADC());
     52e:	0e 94 6d 01 	call	0x2da	; 0x2da <chargeADC>
     532:	88 23       	and	r24, r24
     534:	e1 f3       	breq	.-8      	; 0x52e <startCharge>
	return true;
}
     536:	81 e0       	ldi	r24, 0x01	; 1
     538:	08 95       	ret

0000053a <__vector_13>:
detecting consecutive bytes to be stop char 2 and stop char 1
and setting datastart true and start to store arrived data byte
to arrivedByte variable.
-----------------------------------------------------*/
ISR(USART_RXC_vect)
{
     53a:	1f 92       	push	r1
     53c:	0f 92       	push	r0
     53e:	0f b6       	in	r0, 0x3f	; 63
     540:	0f 92       	push	r0
     542:	11 24       	eor	r1, r1
     544:	2f 93       	push	r18
     546:	8f 93       	push	r24
     548:	9f 93       	push	r25
	prevByteisr = currByteisr;
     54a:	90 91 14 05 	lds	r25, 0x0514
     54e:	90 93 15 05 	sts	0x0515, r25
	currByteisr = UDR;
     552:	8c b1       	in	r24, 0x0c	; 12
     554:	80 93 14 05 	sts	0x0514, r24
	if (datastart)
     558:	20 91 11 05 	lds	r18, 0x0511
     55c:	22 23       	and	r18, r18
     55e:	29 f0       	breq	.+10     	; 0x56a <__vector_13+0x30>
	{
		packageArrival = true;
     560:	21 e0       	ldi	r18, 0x01	; 1
     562:	20 93 13 05 	sts	0x0513, r18
		arrivedByte = currByteisr;
     566:	80 93 21 06 	sts	0x0621, r24
	}
	if ((currByteisr == STOP_CHAR1) && (prevByteisr == STOP_CHAR2))
     56a:	8d 32       	cpi	r24, 0x2D	; 45
     56c:	29 f4       	brne	.+10     	; 0x578 <__vector_13+0x3e>
     56e:	9a 32       	cpi	r25, 0x2A	; 42
     570:	19 f4       	brne	.+6      	; 0x578 <__vector_13+0x3e>
	{
		datastart = true;
     572:	81 e0       	ldi	r24, 0x01	; 1
     574:	80 93 11 05 	sts	0x0511, r24
	}
	
}
     578:	9f 91       	pop	r25
     57a:	8f 91       	pop	r24
     57c:	2f 91       	pop	r18
     57e:	0f 90       	pop	r0
     580:	0f be       	out	0x3f, r0	; 63
     582:	0f 90       	pop	r0
     584:	1f 90       	pop	r1
     586:	18 95       	reti

00000588 <receivePackage>:
extern char actualData[100];
extern int _source;
extern int _destination;
extern int _command;
-----------------------------------------------------*/
bool receivePackage(void){
     588:	bf 92       	push	r11
     58a:	cf 92       	push	r12
     58c:	df 92       	push	r13
     58e:	ef 92       	push	r14
     590:	ff 92       	push	r15
     592:	0f 93       	push	r16
     594:	1f 93       	push	r17
     596:	cf 93       	push	r28
     598:	df 93       	push	r29
	
static char prevByte = 0;
static char currByte = 0;
static int countBits = 0;

	if ((packageArrival) && (!packageArrived))
     59a:	80 91 13 05 	lds	r24, 0x0513
     59e:	88 23       	and	r24, r24
     5a0:	c1 f1       	breq	.+112    	; 0x612 <receivePackage+0x8a>
     5a2:	80 91 12 05 	lds	r24, 0x0512
     5a6:	81 11       	cpse	r24, r1
     5a8:	34 c0       	rjmp	.+104    	; 0x612 <receivePackage+0x8a>
	{
		
		packageArrival = false;
     5aa:	10 92 13 05 	sts	0x0513, r1
		
		prevByte = currByte;
     5ae:	80 91 16 05 	lds	r24, 0x0516
     5b2:	80 93 17 05 	sts	0x0517, r24
		currByte = arrivedByte;
     5b6:	90 91 21 06 	lds	r25, 0x0621
     5ba:	90 93 16 05 	sts	0x0516, r25
		
		if ((prevByte == STOP_CHAR1) && (currByte == STOP_CHAR2)) //The end of package is detected and flag packageArrived is set
     5be:	8d 32       	cpi	r24, 0x2D	; 45
     5c0:	b9 f4       	brne	.+46     	; 0x5f0 <receivePackage+0x68>
     5c2:	9a 32       	cpi	r25, 0x2A	; 42
     5c4:	a9 f4       	brne	.+42     	; 0x5f0 <receivePackage+0x68>
		{
			packageArrived = true;
     5c6:	81 e0       	ldi	r24, 0x01	; 1
     5c8:	80 93 12 05 	sts	0x0512, r24
			dataArrived[countBits++] = '\0';
     5cc:	e0 91 18 05 	lds	r30, 0x0518
     5d0:	f0 91 19 05 	lds	r31, 0x0519
     5d4:	ee 54       	subi	r30, 0x4E	; 78
     5d6:	fa 4f       	sbci	r31, 0xFA	; 250
     5d8:	10 82       	st	Z, r1
			countBits = 0;
     5da:	10 92 19 05 	sts	0x0519, r1
     5de:	10 92 18 05 	sts	0x0518, r1
			prevByte = 0;
     5e2:	10 92 17 05 	sts	0x0517, r1
			currByte = 0;
     5e6:	10 92 16 05 	sts	0x0516, r1
			datastart = false;
     5ea:	10 92 11 05 	sts	0x0511, r1
     5ee:	02 c0       	rjmp	.+4      	; 0x5f4 <receivePackage+0x6c>
		}else{
			packageArrived = false;
     5f0:	10 92 12 05 	sts	0x0512, r1
		}

		dataArrived[countBits++] = currByte;		
     5f4:	80 91 18 05 	lds	r24, 0x0518
     5f8:	90 91 19 05 	lds	r25, 0x0519
     5fc:	fc 01       	movw	r30, r24
     5fe:	ee 54       	subi	r30, 0x4E	; 78
     600:	fa 4f       	sbci	r31, 0xFA	; 250
     602:	20 91 16 05 	lds	r18, 0x0516
     606:	20 83       	st	Z, r18
     608:	01 96       	adiw	r24, 0x01	; 1
     60a:	90 93 19 05 	sts	0x0519, r25
     60e:	80 93 18 05 	sts	0x0518, r24
	}
	
	if ((!packageArrival) && packageArrived) //package data interpretation
     612:	80 91 13 05 	lds	r24, 0x0513
     616:	81 11       	cpse	r24, r1
     618:	a7 c0       	rjmp	.+334    	; 0x768 <receivePackage+0x1e0>
     61a:	80 91 12 05 	lds	r24, 0x0512
     61e:	88 23       	and	r24, r24
     620:	09 f4       	brne	.+2      	; 0x624 <receivePackage+0x9c>
     622:	a4 c0       	rjmp	.+328    	; 0x76c <receivePackage+0x1e4>
	{
		_source = 0;
     624:	10 92 b1 05 	sts	0x05B1, r1
     628:	10 92 b0 05 	sts	0x05B0, r1
		_destination = 0;
     62c:	10 92 90 06 	sts	0x0690, r1
     630:	10 92 8f 06 	sts	0x068F, r1
		_command = 0;
     634:	10 92 1d 06 	sts	0x061D, r1
     638:	10 92 1c 06 	sts	0x061C, r1
		//set a null terminators so the arrays later could be interpreted as a string
		memset(source, '\0', 3);
     63c:	2e e1       	ldi	r18, 0x1E	; 30
     63e:	36 e0       	ldi	r19, 0x06	; 6
     640:	e9 01       	movw	r28, r18
     642:	18 82       	st	Y, r1
     644:	19 82       	std	Y+1, r1	; 0x01
     646:	1a 82       	std	Y+2, r1	; 0x02
		memset(destination, '\0', 3);
     648:	86 e1       	ldi	r24, 0x16	; 22
     64a:	96 e0       	ldi	r25, 0x06	; 6
     64c:	fc 01       	movw	r30, r24
     64e:	10 82       	st	Z, r1
     650:	11 82       	std	Z+1, r1	; 0x01
     652:	12 82       	std	Z+2, r1	; 0x02
		memset(command, '\0', 3);
     654:	a9 e1       	ldi	r26, 0x19	; 25
     656:	b6 e0       	ldi	r27, 0x06	; 6
     658:	1d 92       	st	X+, r1
     65a:	1d 92       	st	X+, r1
     65c:	1c 92       	st	X, r1
     65e:	12 97       	sbiw	r26, 0x02	; 2
		memset(dataLenght, '\0', 5);
     660:	0f 2e       	mov	r0, r31
     662:	f8 e8       	ldi	r31, 0x88	; 136
     664:	cf 2e       	mov	r12, r31
     666:	f6 e0       	ldi	r31, 0x06	; 6
     668:	df 2e       	mov	r13, r31
     66a:	f0 2d       	mov	r31, r0
     66c:	45 e0       	ldi	r20, 0x05	; 5
     66e:	e6 01       	movw	r28, r12
     670:	19 92       	st	Y+, r1
     672:	4a 95       	dec	r20
     674:	e9 f7       	brne	.-6      	; 0x670 <receivePackage+0xe8>
		memset(actualData, '\0', 100);
     676:	0f 2e       	mov	r0, r31
     678:	f2 e2       	ldi	r31, 0x22	; 34
     67a:	ef 2e       	mov	r14, r31
     67c:	f6 e0       	ldi	r31, 0x06	; 6
     67e:	ff 2e       	mov	r15, r31
     680:	f0 2d       	mov	r31, r0
     682:	0f 2e       	mov	r0, r31
     684:	f4 e6       	ldi	r31, 0x64	; 100
     686:	bf 2e       	mov	r11, r31
     688:	f0 2d       	mov	r31, r0
     68a:	f7 01       	movw	r30, r14
     68c:	4b 2d       	mov	r20, r11
     68e:	11 92       	st	Z+, r1
     690:	4a 95       	dec	r20
     692:	e9 f7       	brne	.-6      	; 0x68e <receivePackage+0x106>
		memset(checksum, '\0', 4);
     694:	01 e9       	ldi	r16, 0x91	; 145
     696:	16 e0       	ldi	r17, 0x06	; 6
     698:	e8 01       	movw	r28, r16
     69a:	18 82       	st	Y, r1
     69c:	19 82       	std	Y+1, r1	; 0x01
     69e:	1a 82       	std	Y+2, r1	; 0x02
     6a0:	1b 82       	std	Y+3, r1	; 0x03
		
		//copy package contents to package fields
		memcpy(source, dataArrived, 2);
     6a2:	c2 eb       	ldi	r28, 0xB2	; 178
     6a4:	d5 e0       	ldi	r29, 0x05	; 5
     6a6:	48 81       	ld	r20, Y
     6a8:	59 81       	ldd	r21, Y+1	; 0x01
     6aa:	f9 01       	movw	r30, r18
     6ac:	51 83       	std	Z+1, r21	; 0x01
     6ae:	40 83       	st	Z, r20
		memcpy(destination, dataArrived + 2, 2);
     6b0:	20 91 b4 05 	lds	r18, 0x05B4
     6b4:	30 91 b5 05 	lds	r19, 0x05B5
     6b8:	fc 01       	movw	r30, r24
     6ba:	31 83       	std	Z+1, r19	; 0x01
     6bc:	20 83       	st	Z, r18
		memcpy(command, dataArrived + 4, 2);
     6be:	80 91 b6 05 	lds	r24, 0x05B6
     6c2:	90 91 b7 05 	lds	r25, 0x05B7
     6c6:	8d 93       	st	X+, r24
     6c8:	9c 93       	st	X, r25
		memcpy(dataLenght, dataArrived + 6, 4);
     6ca:	40 91 b8 05 	lds	r20, 0x05B8
     6ce:	50 91 b9 05 	lds	r21, 0x05B9
     6d2:	60 91 ba 05 	lds	r22, 0x05BA
     6d6:	70 91 bb 05 	lds	r23, 0x05BB
     6da:	f6 01       	movw	r30, r12
     6dc:	40 83       	st	Z, r20
     6de:	51 83       	std	Z+1, r21	; 0x01
     6e0:	62 83       	std	Z+2, r22	; 0x02
     6e2:	73 83       	std	Z+3, r23	; 0x03
				
		//count data bytes and copy data to package data field
		dl = atoi(dataLenght);
     6e4:	c6 01       	movw	r24, r12
     6e6:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <atoi>
     6ea:	6c 01       	movw	r12, r24
     6ec:	90 93 87 06 	sts	0x0687, r25
     6f0:	80 93 86 06 	sts	0x0686, r24
				
		memcpy(actualData, dataArrived + 10, dl);
     6f4:	8c eb       	ldi	r24, 0xBC	; 188
     6f6:	95 e0       	ldi	r25, 0x05	; 5
     6f8:	4c 2d       	mov	r20, r12
     6fa:	5d 2d       	mov	r21, r13
     6fc:	68 2f       	mov	r22, r24
     6fe:	79 2f       	mov	r23, r25
     700:	8e 2d       	mov	r24, r14
     702:	9f 2d       	mov	r25, r15
     704:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
		memcpy(checksum, dataArrived + (10 + dl), 3);
     708:	f6 01       	movw	r30, r12
     70a:	e4 54       	subi	r30, 0x44	; 68
     70c:	fa 4f       	sbci	r31, 0xFA	; 250
     70e:	80 81       	ld	r24, Z
     710:	91 81       	ldd	r25, Z+1	; 0x01
     712:	a2 81       	ldd	r26, Z+2	; 0x02
     714:	f8 01       	movw	r30, r16
     716:	80 83       	st	Z, r24
     718:	91 83       	std	Z+1, r25	; 0x01
     71a:	a2 83       	std	Z+2, r26	; 0x02
//  		usart_transmit('\n');
//  		putString("CheckSum: \n");
//  		putString(checksum);
//  		usart_transmit('\n');
// 			putString(command);
		_source = atoi(source);
     71c:	8e e1       	ldi	r24, 0x1E	; 30
     71e:	96 e0       	ldi	r25, 0x06	; 6
     720:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <atoi>
     724:	90 93 b1 05 	sts	0x05B1, r25
     728:	80 93 b0 05 	sts	0x05B0, r24
		_destination = atoi(destination);
     72c:	86 e1       	ldi	r24, 0x16	; 22
     72e:	96 e0       	ldi	r25, 0x06	; 6
     730:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <atoi>
     734:	90 93 90 06 	sts	0x0690, r25
     738:	80 93 8f 06 	sts	0x068F, r24
		_command = atoi(command);
     73c:	89 e1       	ldi	r24, 0x19	; 25
     73e:	96 e0       	ldi	r25, 0x06	; 6
     740:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <atoi>
     744:	90 93 1d 06 	sts	0x061D, r25
     748:	80 93 1c 06 	sts	0x061C, r24
		packageArrived = false;
     74c:	10 92 12 05 	sts	0x0512, r1
		packageArrival = false;
     750:	10 92 13 05 	sts	0x0513, r1
		memset(dataArrived, '\0', 100);
     754:	fe 01       	movw	r30, r28
     756:	11 92       	st	Z+, r1
     758:	ba 94       	dec	r11
     75a:	e9 f7       	brne	.-6      	; 0x756 <receivePackage+0x1ce>
		countBits = 0;
     75c:	10 92 19 05 	sts	0x0519, r1
     760:	10 92 18 05 	sts	0x0518, r1
		return true;
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	03 c0       	rjmp	.+6      	; 0x76e <receivePackage+0x1e6>
	}
	return false;
     768:	80 e0       	ldi	r24, 0x00	; 0
     76a:	01 c0       	rjmp	.+2      	; 0x76e <receivePackage+0x1e6>
     76c:	80 e0       	ldi	r24, 0x00	; 0
}
     76e:	df 91       	pop	r29
     770:	cf 91       	pop	r28
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	df 90       	pop	r13
     77c:	cf 90       	pop	r12
     77e:	bf 90       	pop	r11
     780:	08 95       	ret

00000782 <packageReceived>:
received yet. It returns true whenever it is received.
-----------------------------------------------------*/
bool packageReceived(void)
{
	//USART_Init(64);
    while(!receivePackage());
     782:	0e 94 c4 02 	call	0x588	; 0x588 <receivePackage>
     786:	88 23       	and	r24, r24
     788:	e1 f3       	breq	.-8      	; 0x782 <packageReceived>
	return true;
}
     78a:	81 e0       	ldi	r24, 0x01	; 1
     78c:	08 95       	ret

0000078e <formPacket>:
formPacket("02", "01", "86", energyStr); where energyStr is "102.20"
The output is:
0201860006102.2000(xor value)-*
-----------------------------------------------------*/
	
bool formPacket(char _source[], char _destination[], char _command[], char _data[]){
     78e:	6f 92       	push	r6
     790:	7f 92       	push	r7
     792:	8f 92       	push	r8
     794:	9f 92       	push	r9
     796:	af 92       	push	r10
     798:	bf 92       	push	r11
     79a:	cf 92       	push	r12
     79c:	df 92       	push	r13
     79e:	ef 92       	push	r14
     7a0:	ff 92       	push	r15
     7a2:	0f 93       	push	r16
     7a4:	1f 93       	push	r17
     7a6:	cf 93       	push	r28
     7a8:	df 93       	push	r29
     7aa:	cd b7       	in	r28, 0x3d	; 61
     7ac:	de b7       	in	r29, 0x3e	; 62
     7ae:	29 97       	sbiw	r28, 0x09	; 9
     7b0:	0f b6       	in	r0, 0x3f	; 63
     7b2:	f8 94       	cli
     7b4:	de bf       	out	0x3e, r29	; 62
     7b6:	0f be       	out	0x3f, r0	; 63
     7b8:	cd bf       	out	0x3d, r28	; 61
     7ba:	4c 01       	movw	r8, r24
     7bc:	5b 01       	movw	r10, r22
     7be:	6a 01       	movw	r12, r20
     7c0:	62 2e       	mov	r6, r18
     7c2:	73 2e       	mov	r7, r19
	
	memset(formedDataPackageToSend, 0, 100);
     7c4:	84 e6       	ldi	r24, 0x64	; 100
     7c6:	ea e1       	ldi	r30, 0x1A	; 26
     7c8:	f5 e0       	ldi	r31, 0x05	; 5
     7ca:	df 01       	movw	r26, r30
     7cc:	1d 92       	st	X+, r1
     7ce:	8a 95       	dec	r24
     7d0:	e9 f7       	brne	.-6      	; 0x7cc <formPacket+0x3e>
	
	int datalint = strlen(_data);
     7d2:	e2 2f       	mov	r30, r18
     7d4:	f3 2f       	mov	r31, r19
     7d6:	df 01       	movw	r26, r30
     7d8:	0d 90       	ld	r0, X+
     7da:	00 20       	and	r0, r0
     7dc:	e9 f7       	brne	.-6      	; 0x7d8 <formPacket+0x4a>
     7de:	11 97       	sbiw	r26, 0x01	; 1
     7e0:	7d 01       	movw	r14, r26
     7e2:	ee 1a       	sub	r14, r30
     7e4:	ff 0a       	sbc	r15, r31

	int sizeofpacket = datalint + 10;
     7e6:	87 01       	movw	r16, r14
     7e8:	06 5f       	subi	r16, 0xF6	; 246
     7ea:	1f 4f       	sbci	r17, 0xFF	; 255
	
	char _dataLenght[5];
	
	memset(_dataLenght, '\0', 5);
     7ec:	fe 01       	movw	r30, r28
     7ee:	31 96       	adiw	r30, 0x01	; 1
     7f0:	85 e0       	ldi	r24, 0x05	; 5
     7f2:	df 01       	movw	r26, r30
     7f4:	1d 92       	st	X+, r1
     7f6:	8a 95       	dec	r24
     7f8:	e9 f7       	brne	.-6      	; 0x7f4 <formPacket+0x66>
	
	if (datalint < 10)
     7fa:	ba e0       	ldi	r27, 0x0A	; 10
     7fc:	eb 16       	cp	r14, r27
     7fe:	f1 04       	cpc	r15, r1
     800:	3c f4       	brge	.+14     	; 0x810 <formPacket+0x82>
	{
		char datal = (char)(((int)'0')+datalint);
		_dataLenght[0] = '0';
     802:	80 e3       	ldi	r24, 0x30	; 48
     804:	89 83       	std	Y+1, r24	; 0x01
		_dataLenght[1] = '0';
     806:	8a 83       	std	Y+2, r24	; 0x02
		_dataLenght[2] = '0';
     808:	8b 83       	std	Y+3, r24	; 0x03
	
	memset(_dataLenght, '\0', 5);
	
	if (datalint < 10)
	{
		char datal = (char)(((int)'0')+datalint);
     80a:	8e 2d       	mov	r24, r14
     80c:	80 5d       	subi	r24, 0xD0	; 208
		_dataLenght[0] = '0';
		_dataLenght[1] = '0';
		_dataLenght[2] = '0';
		_dataLenght[3] = datal;
     80e:	8c 83       	std	Y+4, r24	; 0x04
	}
	if ((datalint < 100) && (datalint >= 10))
     810:	c7 01       	movw	r24, r14
     812:	0a 97       	sbiw	r24, 0x0a	; 10
     814:	8a 35       	cpi	r24, 0x5A	; 90
     816:	91 05       	cpc	r25, r1
     818:	78 f4       	brcc	.+30     	; 0x838 <formPacket+0xaa>
	{
		_dataLenght[0] = '0';
     81a:	80 e3       	ldi	r24, 0x30	; 48
     81c:	89 83       	std	Y+1, r24	; 0x01
		_dataLenght[1] = '0';
     81e:	8a 83       	std	Y+2, r24	; 0x02
		char datal[3];
		itoa(datalint, datal, 10);
     820:	4a e0       	ldi	r20, 0x0A	; 10
     822:	50 e0       	ldi	r21, 0x00	; 0
     824:	be 01       	movw	r22, r28
     826:	6a 5f       	subi	r22, 0xFA	; 250
     828:	7f 4f       	sbci	r23, 0xFF	; 255
     82a:	c7 01       	movw	r24, r14
     82c:	0e 94 0f 1b 	call	0x361e	; 0x361e <itoa>
		_dataLenght[2] = datal[0];
     830:	8e 81       	ldd	r24, Y+6	; 0x06
     832:	8b 83       	std	Y+3, r24	; 0x03
		_dataLenght[3] = datal[1];
     834:	8f 81       	ldd	r24, Y+7	; 0x07
     836:	8c 83       	std	Y+4, r24	; 0x04
	}
	if ((datalint < 999) && (datalint >= 100))
     838:	c7 01       	movw	r24, r14
     83a:	84 56       	subi	r24, 0x64	; 100
     83c:	91 09       	sbc	r25, r1
     83e:	83 38       	cpi	r24, 0x83	; 131
     840:	93 40       	sbci	r25, 0x03	; 3
     842:	80 f4       	brcc	.+32     	; 0x864 <__stack+0x5>
	{
		_dataLenght[0] = '0';
     844:	80 e3       	ldi	r24, 0x30	; 48
     846:	89 83       	std	Y+1, r24	; 0x01
		char datal[4];
		itoa(datalint, datal, 10);
     848:	4a e0       	ldi	r20, 0x0A	; 10
     84a:	50 e0       	ldi	r21, 0x00	; 0
     84c:	be 01       	movw	r22, r28
     84e:	6a 5f       	subi	r22, 0xFA	; 250
     850:	7f 4f       	sbci	r23, 0xFF	; 255
     852:	c7 01       	movw	r24, r14
     854:	0e 94 0f 1b 	call	0x361e	; 0x361e <itoa>
		_dataLenght[1] = datal[0];
     858:	8e 81       	ldd	r24, Y+6	; 0x06
     85a:	8a 83       	std	Y+2, r24	; 0x02
		_dataLenght[2] = datal[1];
     85c:	8f 81       	ldd	r24, Y+7	; 0x07
     85e:	8b 83       	std	Y+3, r24	; 0x03
		_dataLenght[3] = datal[2];
     860:	88 85       	ldd	r24, Y+8	; 0x08
     862:	8c 83       	std	Y+4, r24	; 0x04
	}
	
	memcpy(formedDataPackageToSend, _source, 2);
     864:	d4 01       	movw	r26, r8
     866:	8d 91       	ld	r24, X+
     868:	9c 91       	ld	r25, X
     86a:	90 93 1b 05 	sts	0x051B, r25
     86e:	80 93 1a 05 	sts	0x051A, r24
	memcpy(formedDataPackageToSend + 2, _destination, 2);
     872:	f5 01       	movw	r30, r10
     874:	80 81       	ld	r24, Z
     876:	91 81       	ldd	r25, Z+1	; 0x01
     878:	90 93 1d 05 	sts	0x051D, r25
     87c:	80 93 1c 05 	sts	0x051C, r24
	memcpy(formedDataPackageToSend + 4, _command, 2);
     880:	d6 01       	movw	r26, r12
     882:	8d 91       	ld	r24, X+
     884:	9c 91       	ld	r25, X
     886:	90 93 1f 05 	sts	0x051F, r25
     88a:	80 93 1e 05 	sts	0x051E, r24
	memcpy(formedDataPackageToSend + 6, _dataLenght, 4);
     88e:	49 81       	ldd	r20, Y+1	; 0x01
     890:	5a 81       	ldd	r21, Y+2	; 0x02
     892:	6b 81       	ldd	r22, Y+3	; 0x03
     894:	7c 81       	ldd	r23, Y+4	; 0x04
     896:	40 93 20 05 	sts	0x0520, r20
     89a:	50 93 21 05 	sts	0x0521, r21
     89e:	60 93 22 05 	sts	0x0522, r22
     8a2:	70 93 23 05 	sts	0x0523, r23
	memcpy(formedDataPackageToSend + 10, _data, datalint);
     8a6:	24 e2       	ldi	r18, 0x24	; 36
     8a8:	35 e0       	ldi	r19, 0x05	; 5
     8aa:	4e 2d       	mov	r20, r14
     8ac:	5f 2d       	mov	r21, r15
     8ae:	66 2d       	mov	r22, r6
     8b0:	77 2d       	mov	r23, r7
     8b2:	82 2f       	mov	r24, r18
     8b4:	93 2f       	mov	r25, r19
     8b6:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
		
	char xor = 0;
	
	for ( int i = 0 ; i < (sizeofpacket); i ++ ) {
     8ba:	10 16       	cp	r1, r16
     8bc:	11 06       	cpc	r1, r17
     8be:	64 f4       	brge	.+24     	; 0x8d8 <__stack+0x79>
     8c0:	ea e1       	ldi	r30, 0x1A	; 26
     8c2:	f5 e0       	ldi	r31, 0x05	; 5
formPacket("02", "01", "86", energyStr); where energyStr is "102.20"
The output is:
0201860006102.2000(xor value)-*
-----------------------------------------------------*/
	
bool formPacket(char _source[], char _destination[], char _command[], char _data[]){
     8c4:	c7 01       	movw	r24, r14
     8c6:	8c 5d       	subi	r24, 0xDC	; 220
     8c8:	9a 4f       	sbci	r25, 0xFA	; 250
	memcpy(formedDataPackageToSend + 2, _destination, 2);
	memcpy(formedDataPackageToSend + 4, _command, 2);
	memcpy(formedDataPackageToSend + 6, _dataLenght, 4);
	memcpy(formedDataPackageToSend + 10, _data, datalint);
		
	char xor = 0;
     8ca:	20 e0       	ldi	r18, 0x00	; 0
	
	for ( int i = 0 ; i < (sizeofpacket); i ++ ) {
		xor = xor ^ formedDataPackageToSend[i];
     8cc:	31 91       	ld	r19, Z+
     8ce:	23 27       	eor	r18, r19
	memcpy(formedDataPackageToSend + 6, _dataLenght, 4);
	memcpy(formedDataPackageToSend + 10, _data, datalint);
		
	char xor = 0;
	
	for ( int i = 0 ; i < (sizeofpacket); i ++ ) {
     8d0:	e8 17       	cp	r30, r24
     8d2:	f9 07       	cpc	r31, r25
     8d4:	d9 f7       	brne	.-10     	; 0x8cc <__stack+0x6d>
     8d6:	01 c0       	rjmp	.+2      	; 0x8da <__stack+0x7b>
	memcpy(formedDataPackageToSend + 2, _destination, 2);
	memcpy(formedDataPackageToSend + 4, _command, 2);
	memcpy(formedDataPackageToSend + 6, _dataLenght, 4);
	memcpy(formedDataPackageToSend + 10, _data, datalint);
		
	char xor = 0;
     8d8:	20 e0       	ldi	r18, 0x00	; 0
	
	for ( int i = 0 ; i < (sizeofpacket); i ++ ) {
		xor = xor ^ formedDataPackageToSend[i];
	}
	
	formedDataPackageToSend[(10 + datalint)] = '0';
     8da:	f8 01       	movw	r30, r16
     8dc:	e6 5e       	subi	r30, 0xE6	; 230
     8de:	fa 4f       	sbci	r31, 0xFA	; 250
     8e0:	80 e3       	ldi	r24, 0x30	; 48
     8e2:	80 83       	st	Z, r24
	formedDataPackageToSend[(11 + datalint)] = '0';
     8e4:	f7 01       	movw	r30, r14
     8e6:	e6 5e       	subi	r30, 0xE6	; 230
     8e8:	fa 4f       	sbci	r31, 0xFA	; 250
     8ea:	83 87       	std	Z+11, r24	; 0x0b
	formedDataPackageToSend[(12 + datalint)] = xor;
     8ec:	24 87       	std	Z+12, r18	; 0x0c
	formedDataPackageToSend[(13 + datalint)] = STOP_CHAR1;
     8ee:	8d e2       	ldi	r24, 0x2D	; 45
     8f0:	85 87       	std	Z+13, r24	; 0x0d
	formedDataPackageToSend[(14 + datalint)] = STOP_CHAR2;
     8f2:	8a e2       	ldi	r24, 0x2A	; 42
     8f4:	86 87       	std	Z+14, r24	; 0x0e
	formedDataPackageToSend[(15 + datalint)] = '\0';
     8f6:	17 86       	std	Z+15, r1	; 0x0f
	
	return true;
     8f8:	81 e0       	ldi	r24, 0x01	; 1
     8fa:	29 96       	adiw	r28, 0x09	; 9
     8fc:	0f b6       	in	r0, 0x3f	; 63
     8fe:	f8 94       	cli
     900:	de bf       	out	0x3e, r29	; 62
     902:	0f be       	out	0x3f, r0	; 63
     904:	cd bf       	out	0x3d, r28	; 61
     906:	df 91       	pop	r29
     908:	cf 91       	pop	r28
     90a:	1f 91       	pop	r17
     90c:	0f 91       	pop	r16
     90e:	ff 90       	pop	r15
     910:	ef 90       	pop	r14
     912:	df 90       	pop	r13
     914:	cf 90       	pop	r12
     916:	bf 90       	pop	r11
     918:	af 90       	pop	r10
     91a:	9f 90       	pop	r9
     91c:	8f 90       	pop	r8
     91e:	7f 90       	pop	r7
     920:	6f 90       	pop	r6
     922:	08 95       	ret

00000924 <noAction>:
    sendStringUSART(formedDataPackageToSend); 
    //Welcome 
    stateTransition(g); 
} 
  
void noAction(void){ 
     924:	08 95       	ret

00000926 <idSessionDone>:
Function that clears the screen and sets idied flag true.
The mechanism above stops and returns true for inheriting
module to flag id process done.
 -----------------------------------------------------*/   
void idSessionDone(){ 
    lcdClear(); 
     926:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     92a:	80 e1       	ldi	r24, 0x10	; 16
     92c:	8a 95       	dec	r24
     92e:	f1 f7       	brne	.-4      	; 0x92c <idSessionDone+0x6>
     930:	00 c0       	rjmp	.+0      	; 0x932 <idSessionDone+0xc>
    _delay_us(5); 
    idied = true; 
     932:	81 e0       	ldi	r24, 0x01	; 1
     934:	80 93 84 05 	sts	0x0584, r24
     938:	08 95       	ret

0000093a <stateEval>:
Function that finds next state and corresponding action
according to the event passed as a parameter and current
state variable.
-----------------------------------------------------*/  
void stateEval(event w) { 
    stateElement stateEvaluation = stateMatrix[currentState][w];    //suranda sekancia state pagal esama state ir ivyki 
     93a:	90 e0       	ldi	r25, 0x00	; 0
     93c:	dc 01       	movw	r26, r24
     93e:	aa 0f       	add	r26, r26
     940:	bb 1f       	adc	r27, r27
     942:	a8 0f       	add	r26, r24
     944:	b9 1f       	adc	r27, r25
     946:	80 91 7e 05 	lds	r24, 0x057E
     94a:	9b e1       	ldi	r25, 0x1B	; 27
     94c:	89 9f       	mul	r24, r25
     94e:	a0 0d       	add	r26, r0
     950:	b1 1d       	adc	r27, r1
     952:	11 24       	eor	r1, r1
     954:	ae 59       	subi	r26, 0x9E	; 158
     956:	bf 4f       	sbci	r27, 0xFF	; 255
     958:	11 96       	adiw	r26, 0x01	; 1
     95a:	ed 91       	ld	r30, X+
     95c:	fc 91       	ld	r31, X
     95e:	12 97       	sbiw	r26, 0x02	; 2
    currentState = stateEvaluation.nextState;                       //sauna action'a busimos 
     960:	8c 91       	ld	r24, X
     962:	80 93 7e 05 	sts	0x057E, r24
    (*stateEvaluation.actionToDo)(); 
     966:	09 95       	icall
     968:	08 95       	ret

0000096a <stateTransition>:
handy at testing stages and as generated event is stored, 
let's stimulate state and action change from anywhere from
this module.
 -----------------------------------------------------*/   
void stateTransition(event curr){ 
    EventOccured = curr; 
     96a:	80 93 61 00 	sts	0x0061, r24
    stateEval((event)curr); 
     96e:	0e 94 9d 04 	call	0x93a	; 0x93a <stateEval>
     972:	08 95       	ret

00000974 <RFIDidRead>:
id and debt if there was one.
 -----------------------------------------------------*/    
void RFIDidRead(void) 
{ 
    //sendStringUSART("RFID \n"); 
    GoTo(0,3); 
     974:	63 e0       	ldi	r22, 0x03	; 3
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    onlineFirstREad = true; 
     97c:	81 e0       	ldi	r24, 0x01	; 1
     97e:	80 93 92 05 	sts	0x0592, r24
    while (!RFIDinit(1, "uid", 3));  
     982:	43 e0       	ldi	r20, 0x03	; 3
     984:	50 e0       	ldi	r21, 0x00	; 0
     986:	66 e6       	ldi	r22, 0x66	; 102
     988:	72 e0       	ldi	r23, 0x02	; 2
     98a:	81 e0       	ldi	r24, 0x01	; 1
     98c:	90 e0       	ldi	r25, 0x00	; 0
     98e:	0e 94 2c 11 	call	0x2258	; 0x2258 <RFIDinit>
     992:	88 23       	and	r24, r24
     994:	b1 f3       	breq	.-20     	; 0x982 <RFIDidRead+0xe>
    rfidDone = false; 
     996:	10 92 8e 05 	sts	0x058E, r1
      
    rfidIdArrived = true; 
     99a:	81 e0       	ldi	r24, 0x01	; 1
     99c:	80 93 85 05 	sts	0x0585, r24
    LCDPutString("Wait"); 
     9a0:	8a e6       	ldi	r24, 0x6A	; 106
     9a2:	92 e0       	ldi	r25, 0x02	; 2
     9a4:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    //To Send 
    stateTransition(a); 
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     9ae:	08 95       	ret

000009b0 <Receive>:
that asks to repeat data is fired.
 -----------------------------------------------------*/   
void Receive(void){ 
    //sendStringUSART("USARTreceive\n"); 
      
    while(!packageReceived()); 
     9b0:	0e 94 c1 03 	call	0x782	; 0x782 <packageReceived>
     9b4:	88 23       	and	r24, r24
     9b6:	e1 f3       	breq	.-8      	; 0x9b0 <Receive>
      
    if ( _command == 1) 
     9b8:	80 91 1c 06 	lds	r24, 0x061C
     9bc:	90 91 1d 06 	lds	r25, 0x061D
     9c0:	81 30       	cpi	r24, 0x01	; 1
     9c2:	91 05       	cpc	r25, r1
     9c4:	a9 f4       	brne	.+42     	; 0x9f0 <Receive+0x40>
    { 
        GoTo(0,3); 
     9c6:	63 e0       	ldi	r22, 0x03	; 3
     9c8:	80 e0       	ldi	r24, 0x00	; 0
     9ca:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("PIN is OK"); 
     9ce:	8f e6       	ldi	r24, 0x6F	; 111
     9d0:	92 e0       	ldi	r25, 0x02	; 2
     9d2:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     9d6:	2f ef       	ldi	r18, 0xFF	; 255
     9d8:	88 e0       	ldi	r24, 0x08	; 8
     9da:	9d e3       	ldi	r25, 0x3D	; 61
     9dc:	21 50       	subi	r18, 0x01	; 1
     9de:	80 40       	sbci	r24, 0x00	; 0
     9e0:	90 40       	sbci	r25, 0x00	; 0
     9e2:	e1 f7       	brne	.-8      	; 0x9dc <Receive+0x2c>
     9e4:	00 c0       	rjmp	.+0      	; 0x9e6 <Receive+0x36>
     9e6:	00 00       	nop
        _delay_ms(2000); 
        // End Session 
        stateTransition(f); 
     9e8:	86 e0       	ldi	r24, 0x06	; 6
     9ea:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     9ee:	08 95       	ret
    }  
    else if (  _command == 2) 
     9f0:	82 30       	cpi	r24, 0x02	; 2
     9f2:	91 05       	cpc	r25, r1
     9f4:	a9 f4       	brne	.+42     	; 0xa20 <Receive+0x70>
    { 
        GoTo(0,3); 
     9f6:	63 e0       	ldi	r22, 0x03	; 3
     9f8:	80 e0       	ldi	r24, 0x00	; 0
     9fa:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Incorrect PIN"); 
     9fe:	89 e7       	ldi	r24, 0x79	; 121
     a00:	92 e0       	ldi	r25, 0x02	; 2
     a02:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     a06:	2f ef       	ldi	r18, 0xFF	; 255
     a08:	88 e0       	ldi	r24, 0x08	; 8
     a0a:	9d e3       	ldi	r25, 0x3D	; 61
     a0c:	21 50       	subi	r18, 0x01	; 1
     a0e:	80 40       	sbci	r24, 0x00	; 0
     a10:	90 40       	sbci	r25, 0x00	; 0
     a12:	e1 f7       	brne	.-8      	; 0xa0c <Receive+0x5c>
     a14:	00 c0       	rjmp	.+0      	; 0xa16 <Receive+0x66>
     a16:	00 00       	nop
        _delay_ms(2000); 
        //To Keypad 
        stateTransition(g); 
     a18:	87 e0       	ldi	r24, 0x07	; 7
     a1a:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     a1e:	08 95       	ret
    } 
      
    else if (  _command == 3) 
     a20:	83 30       	cpi	r24, 0x03	; 3
     a22:	91 05       	cpc	r25, r1
     a24:	29 f5       	brne	.+74     	; 0xa70 <Receive+0xc0>
    { 
        lcdClear(); 
     a26:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
     a2a:	83 ed       	ldi	r24, 0xD3	; 211
     a2c:	90 e3       	ldi	r25, 0x30	; 48
     a2e:	01 97       	sbiw	r24, 0x01	; 1
     a30:	f1 f7       	brne	.-4      	; 0xa2e <Receive+0x7e>
     a32:	00 c0       	rjmp	.+0      	; 0xa34 <Receive+0x84>
     a34:	00 00       	nop
        _delay_ms(5); 
        GoTo(0,0); 
     a36:	60 e0       	ldi	r22, 0x00	; 0
     a38:	80 e0       	ldi	r24, 0x00	; 0
     a3a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Access is blocked"); 
     a3e:	87 e8       	ldi	r24, 0x87	; 135
     a40:	92 e0       	ldi	r25, 0x02	; 2
     a42:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,2); 
     a46:	62 e0       	ldi	r22, 0x02	; 2
     a48:	80 e0       	ldi	r24, 0x00	; 0
     a4a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Wrong PIN input 3x"); 
     a4e:	89 e9       	ldi	r24, 0x99	; 153
     a50:	92 e0       	ldi	r25, 0x02	; 2
     a52:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     a56:	9f e7       	ldi	r25, 0x7F	; 127
     a58:	24 e8       	ldi	r18, 0x84	; 132
     a5a:	8e e1       	ldi	r24, 0x1E	; 30
     a5c:	91 50       	subi	r25, 0x01	; 1
     a5e:	20 40       	sbci	r18, 0x00	; 0
     a60:	80 40       	sbci	r24, 0x00	; 0
     a62:	e1 f7       	brne	.-8      	; 0xa5c <Receive+0xac>
     a64:	00 c0       	rjmp	.+0      	; 0xa66 <Receive+0xb6>
     a66:	00 00       	nop
        _delay_ms(1000); 
        //End Session 
        stateTransition(f); 
     a68:	86 e0       	ldi	r24, 0x06	; 6
     a6a:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     a6e:	08 95       	ret
    } 
      
    else if (_command == 11) 
     a70:	8b 30       	cpi	r24, 0x0B	; 11
     a72:	91 05       	cpc	r25, r1
     a74:	21 f4       	brne	.+8      	; 0xa7e <Receive+0xce>
    { 
        //To keypad 
        stateTransition(b); 
     a76:	82 e0       	ldi	r24, 0x02	; 2
     a78:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     a7c:	08 95       	ret
    }  
    else if ( _command == 12) 
     a7e:	0c 97       	sbiw	r24, 0x0c	; 12
     a80:	a9 f4       	brne	.+42     	; 0xaac <Receive+0xfc>
    { 
        GoTo(0,3); 
     a82:	63 e0       	ldi	r22, 0x03	; 3
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Unknown card"); 
     a8a:	8c ea       	ldi	r24, 0xAC	; 172
     a8c:	92 e0       	ldi	r25, 0x02	; 2
     a8e:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
     a92:	9f e7       	ldi	r25, 0x7F	; 127
     a94:	24 e8       	ldi	r18, 0x84	; 132
     a96:	8e e1       	ldi	r24, 0x1E	; 30
     a98:	91 50       	subi	r25, 0x01	; 1
     a9a:	20 40       	sbci	r18, 0x00	; 0
     a9c:	80 40       	sbci	r24, 0x00	; 0
     a9e:	e1 f7       	brne	.-8      	; 0xa98 <Receive+0xe8>
     aa0:	00 c0       	rjmp	.+0      	; 0xaa2 <Receive+0xf2>
     aa2:	00 00       	nop
        _delay_ms(1000); 
        //End Session 
        stateTransition(d); 
     aa4:	84 e0       	ldi	r24, 0x04	; 4
     aa6:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     aaa:	08 95       	ret
    } 
    else{ 
        //Repeat data 
        stateTransition(c); 
     aac:	83 e0       	ldi	r24, 0x03	; 3
     aae:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     ab2:	08 95       	ret

00000ab4 <Send>:
it sends packet with RFID card id, if pinReceived flag is
up, sends packet with pin code to be checked.
 -----------------------------------------------------*/  
void Send(void){ 
  
    if (rfidIdArrived) 
     ab4:	80 91 85 05 	lds	r24, 0x0585
     ab8:	88 23       	and	r24, r24
     aba:	99 f0       	breq	.+38     	; 0xae2 <Send+0x2e>
        /* double creditgg = atof (debtChar); 
         //convert float to string so zeros are lost ant only float number is stored 
         if(snprintf(credit_,8, "%.2f \r\n", creditgg)){ 
             sendStringUSART("detectedcredit"); 
         }*/
        formPacket("02", "01", "10", RfidBufferToRead); 
     abc:	2e ef       	ldi	r18, 0xFE	; 254
     abe:	36 e0       	ldi	r19, 0x06	; 6
     ac0:	49 eb       	ldi	r20, 0xB9	; 185
     ac2:	52 e0       	ldi	r21, 0x02	; 2
     ac4:	6c eb       	ldi	r22, 0xBC	; 188
     ac6:	72 e0       	ldi	r23, 0x02	; 2
     ac8:	8f eb       	ldi	r24, 0xBF	; 191
     aca:	92 e0       	ldi	r25, 0x02	; 2
     acc:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
        sendStringUSART(formedDataPackageToSend); 
     ad0:	8a e1       	ldi	r24, 0x1A	; 26
     ad2:	95 e0       	ldi	r25, 0x05	; 5
     ad4:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
        rfidIdArrived = false; 
     ad8:	10 92 85 05 	sts	0x0585, r1
        //To Receive 
        stateTransition(a); 
     adc:	81 e0       	ldi	r24, 0x01	; 1
     ade:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
    }  
    if (pinReceived) 
     ae2:	80 91 86 05 	lds	r24, 0x0586
     ae6:	88 23       	and	r24, r24
     ae8:	d9 f0       	breq	.+54     	; 0xb20 <Send+0x6c>
    { 
        pinReceived = false; 
     aea:	10 92 86 05 	sts	0x0586, r1
        GoTo(0,2); 
     aee:	62 e0       	ldi	r22, 0x02	; 2
     af0:	80 e0       	ldi	r24, 0x00	; 0
     af2:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("PIN is being checked"); 
     af6:	82 ec       	ldi	r24, 0xC2	; 194
     af8:	92 e0       	ldi	r25, 0x02	; 2
     afa:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
      
        formPacket("02", "01", "00", pin); 
     afe:	2d ed       	ldi	r18, 0xDD	; 221
     b00:	36 e0       	ldi	r19, 0x06	; 6
     b02:	47 ed       	ldi	r20, 0xD7	; 215
     b04:	52 e0       	ldi	r21, 0x02	; 2
     b06:	6c eb       	ldi	r22, 0xBC	; 188
     b08:	72 e0       	ldi	r23, 0x02	; 2
     b0a:	8f eb       	ldi	r24, 0xBF	; 191
     b0c:	92 e0       	ldi	r25, 0x02	; 2
     b0e:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
        sendStringUSART(formedDataPackageToSend); 
     b12:	8a e1       	ldi	r24, 0x1A	; 26
     b14:	95 e0       	ldi	r25, 0x05	; 5
     b16:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
          
        stateTransition(e); 
     b1a:	85 e0       	ldi	r24, 0x05	; 5
     b1c:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     b20:	08 95       	ret

00000b22 <KeyPadRead>:
graphics, stores entered pin code in char array and works
for both modes - offline and online. After pin is read,
corresponding event is generated and appropriate actions
are fired - to check pin code.
 -----------------------------------------------------*/    
void KeyPadRead(void){ 
     b22:	cf 93       	push	r28
     b24:	df 93       	push	r29
    //sendStringUSART("KeypadRead\n"); 
        int i = 0; 
        lcdClear(); 
     b26:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
     b2a:	83 ed       	ldi	r24, 0xD3	; 211
     b2c:	90 e3       	ldi	r25, 0x30	; 48
     b2e:	01 97       	sbiw	r24, 0x01	; 1
     b30:	f1 f7       	brne	.-4      	; 0xb2e <KeyPadRead+0xc>
     b32:	00 c0       	rjmp	.+0      	; 0xb34 <KeyPadRead+0x12>
     b34:	00 00       	nop
        _delay_ms(5); 
        GoTo(0,0); 
     b36:	60 e0       	ldi	r22, 0x00	; 0
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Enter PIN:"); 
     b3e:	8a ed       	ldi	r24, 0xDA	; 218
     b40:	92 e0       	ldi	r25, 0x02	; 2
     b42:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        if (incorrectPIN) 
     b46:	80 91 7f 05 	lds	r24, 0x057F
     b4a:	88 23       	and	r24, r24
     b4c:	41 f0       	breq	.+16     	; 0xb5e <KeyPadRead+0x3c>
        { 
            GoTo(0,3); 
     b4e:	63 e0       	ldi	r22, 0x03	; 3
     b50:	80 e0       	ldi	r24, 0x00	; 0
     b52:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
            LCDPutString("Incorrect PIN"); 
     b56:	89 e7       	ldi	r24, 0x79	; 121
     b58:	92 e0       	ldi	r25, 0x02	; 2
     b5a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        } 
          
        memset(pin, '\0', 5); 
     b5e:	85 e0       	ldi	r24, 0x05	; 5
     b60:	ed ed       	ldi	r30, 0xDD	; 221
     b62:	f6 e0       	ldi	r31, 0x06	; 6
     b64:	df 01       	movw	r26, r30
     b66:	1d 92       	st	X+, r1
     b68:	8a 95       	dec	r24
     b6a:	e9 f7       	brne	.-6      	; 0xb66 <KeyPadRead+0x44>
corresponding event is generated and appropriate actions
are fired - to check pin code.
 -----------------------------------------------------*/    
void KeyPadRead(void){ 
    //sendStringUSART("KeypadRead\n"); 
        int i = 0; 
     b6c:	c0 e0       	ldi	r28, 0x00	; 0
     b6e:	d0 e0       	ldi	r29, 0x00	; 0
          
        memset(pin, '\0', 5); 
          
        while (i!=4) 
        { 
            if ((scanKeyPad()==1) && (i!=4)){ 
     b70:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
     b74:	81 30       	cpi	r24, 0x01	; 1
     b76:	01 f5       	brne	.+64     	; 0xbb8 <KeyPadRead+0x96>
     b78:	c4 30       	cpi	r28, 0x04	; 4
     b7a:	d1 05       	cpc	r29, r1
     b7c:	01 f1       	breq	.+64     	; 0xbbe <KeyPadRead+0x9c>
                GoTo(i,1); 
     b7e:	61 e0       	ldi	r22, 0x01	; 1
     b80:	8c 2f       	mov	r24, r28
     b82:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
                char jj = returnKey(); 
     b86:	0e 94 0c 09 	call	0x1218	; 0x1218 <returnKey>
                pin[i] = jj; 
     b8a:	fe 01       	movw	r30, r28
     b8c:	e3 52       	subi	r30, 0x23	; 35
     b8e:	f9 4f       	sbci	r31, 0xF9	; 249
     b90:	80 83       	st	Z, r24
                lcd_data_write(pin[i]); 
     b92:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
     b96:	bf e3       	ldi	r27, 0x3F	; 63
     b98:	2d e0       	ldi	r18, 0x0D	; 13
     b9a:	83 e0       	ldi	r24, 0x03	; 3
     b9c:	b1 50       	subi	r27, 0x01	; 1
     b9e:	20 40       	sbci	r18, 0x00	; 0
     ba0:	80 40       	sbci	r24, 0x00	; 0
     ba2:	e1 f7       	brne	.-8      	; 0xb9c <KeyPadRead+0x7a>
     ba4:	00 c0       	rjmp	.+0      	; 0xba6 <KeyPadRead+0x84>
     ba6:	00 00       	nop
                _delay_ms(100); 
                GoTo(i,1); 
     ba8:	61 e0       	ldi	r22, 0x01	; 1
     baa:	8c 2f       	mov	r24, r28
     bac:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
                lcd_data_write('*'); 
     bb0:	8a e2       	ldi	r24, 0x2A	; 42
     bb2:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
                i++; 
     bb6:	21 96       	adiw	r28, 0x01	; 1
            LCDPutString("Incorrect PIN"); 
        } 
          
        memset(pin, '\0', 5); 
          
        while (i!=4) 
     bb8:	c4 30       	cpi	r28, 0x04	; 4
     bba:	d1 05       	cpc	r29, r1
     bbc:	c9 f6       	brne	.-78     	; 0xb70 <KeyPadRead+0x4e>
                lcd_data_write('*'); 
                i++; 
            } 
        } 
        i=0; 
        pinReceived = true; 
     bbe:	81 e0       	ldi	r24, 0x01	; 1
     bc0:	80 93 86 05 	sts	0x0586, r24
        if (currentState == offline) 
     bc4:	80 91 7e 05 	lds	r24, 0x057E
     bc8:	86 30       	cpi	r24, 0x06	; 6
     bca:	21 f4       	brne	.+8      	; 0xbd4 <KeyPadRead+0xb2>
        { 
            stateTransition(c); 
     bcc:	83 e0       	ldi	r24, 0x03	; 3
     bce:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     bd2:	03 c0       	rjmp	.+6      	; 0xbda <KeyPadRead+0xb8>
        }else{ 
        stateTransition(a);  
     bd4:	81 e0       	ldi	r24, 0x01	; 1
     bd6:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
        } 
  
} 
     bda:	df 91       	pop	r29
     bdc:	cf 91       	pop	r28
     bde:	08 95       	ret

00000be0 <Welcome>:
void Welcome(void)
Welcome screen function that puts a couple of text lines
on welcome screen and generates event to shift states.
 -----------------------------------------------------*/   
void Welcome(void){ 
    lcdClear(); 
     be0:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
     be4:	83 ed       	ldi	r24, 0xD3	; 211
     be6:	90 e3       	ldi	r25, 0x30	; 48
     be8:	01 97       	sbiw	r24, 0x01	; 1
     bea:	f1 f7       	brne	.-4      	; 0xbe8 <Welcome+0x8>
     bec:	00 c0       	rjmp	.+0      	; 0xbee <Welcome+0xe>
     bee:	00 00       	nop
    _delay_ms(5); 
    LCDPutString("Ultra 2000 eCharge"); 
     bf0:	85 ee       	ldi	r24, 0xE5	; 229
     bf2:	92 e0       	ldi	r25, 0x02	; 2
     bf4:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,1); 
     bf8:	61 e0       	ldi	r22, 0x01	; 1
     bfa:	80 e0       	ldi	r24, 0x00	; 0
     bfc:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Use your RFID card"); 
     c00:	88 ef       	ldi	r24, 0xF8	; 248
     c02:	92 e0       	ldi	r25, 0x02	; 2
     c04:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    stateTransition(b); 
     c08:	82 e0       	ldi	r24, 0x02	; 2
     c0a:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     c0e:	08 95       	ret

00000c10 <EndSession>:
void EndSession(void)
Function that sends data package to server to initiate
end of session and shifts to idle state.
 -----------------------------------------------------*/     
void EndSession(void){ 
    formPacket("02", "01", "99", "EndofSession"); 
     c10:	2b e0       	ldi	r18, 0x0B	; 11
     c12:	33 e0       	ldi	r19, 0x03	; 3
     c14:	48 e1       	ldi	r20, 0x18	; 24
     c16:	53 e0       	ldi	r21, 0x03	; 3
     c18:	6c eb       	ldi	r22, 0xBC	; 188
     c1a:	72 e0       	ldi	r23, 0x02	; 2
     c1c:	8f eb       	ldi	r24, 0xBF	; 191
     c1e:	92 e0       	ldi	r25, 0x02	; 2
     c20:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
    sendStringUSART(formedDataPackageToSend); 
     c24:	8a e1       	ldi	r24, 0x1A	; 26
     c26:	95 e0       	ldi	r25, 0x05	; 5
     c28:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    //Welcome 
    stateTransition(g); 
     c2c:	87 e0       	ldi	r24, 0x07	; 7
     c2e:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     c32:	08 95       	ret

00000c34 <repeatPacket>:
void repeatPacket(void)
Function that sends request to repeat last packet if 
receiving mechanism failed to interpret it.
 -----------------------------------------------------*/    
void repeatPacket(void){ 
    formPacket("02", "01", "09", "RepeatLastPacket"); 
     c34:	2b e1       	ldi	r18, 0x1B	; 27
     c36:	33 e0       	ldi	r19, 0x03	; 3
     c38:	4c e2       	ldi	r20, 0x2C	; 44
     c3a:	53 e0       	ldi	r21, 0x03	; 3
     c3c:	6c eb       	ldi	r22, 0xBC	; 188
     c3e:	72 e0       	ldi	r23, 0x02	; 2
     c40:	8f eb       	ldi	r24, 0xBF	; 191
     c42:	92 e0       	ldi	r25, 0x02	; 2
     c44:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
    sendStringUSART(formedDataPackageToSend); 
     c48:	8a e1       	ldi	r24, 0x1A	; 26
     c4a:	95 e0       	ldi	r25, 0x05	; 5
     c4c:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    if ((back == 1)) 
     c50:	80 91 95 06 	lds	r24, 0x0695
     c54:	90 91 96 06 	lds	r25, 0x0696
     c58:	01 97       	sbiw	r24, 0x01	; 1
     c5a:	41 f4       	brne	.+16     	; 0xc6c <repeatPacket+0x38>
    { 
        back = 0; 
     c5c:	10 92 96 06 	sts	0x0696, r1
     c60:	10 92 95 06 	sts	0x0695, r1
        stateTransition(f); //start session 
     c64:	86 e0       	ldi	r24, 0x06	; 6
     c66:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     c6a:	08 95       	ret
    }  
    else
    { 
        stateTransition(a); 
     c6c:	81 e0       	ldi	r24, 0x01	; 1
     c6e:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     c72:	08 95       	ret

00000c74 <id>:
Also initiates USART, LCD and keypad modules. Stimulates
actions and states according to generated events.
 -----------------------------------------------------*/     
bool id(void) 
{ 
    USART_Init(64); 
     c74:	80 e4       	ldi	r24, 0x40	; 64
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	0e 94 c1 13 	call	0x2782	; 0x2782 <USART_Init>
    lcd_init(); 
     c7c:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <lcd_init>
    sei(); 
     c80:	78 94       	sei
    keypad_init(); 
     c82:	0e 94 0f 09 	call	0x121e	; 0x121e <keypad_init>
      
    while(!idied){ 
     c86:	80 91 84 05 	lds	r24, 0x0584
     c8a:	81 11       	cpse	r24, r1
     c8c:	08 c0       	rjmp	.+16     	; 0xc9e <id+0x2a>
    stateTransition(EventOccured); 
     c8e:	80 91 61 00 	lds	r24, 0x0061
     c92:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
    USART_Init(64); 
    lcd_init(); 
    sei(); 
    keypad_init(); 
      
    while(!idied){ 
     c96:	80 91 84 05 	lds	r24, 0x0584
     c9a:	88 23       	and	r24, r24
     c9c:	c1 f3       	breq	.-16     	; 0xc8e <id+0x1a>
    stateTransition(EventOccured); 
    } 
    return true; 
// 
//stateTransition(a); 
} 
     c9e:	81 e0       	ldi	r24, 0x01	; 1
     ca0:	08 95       	ret

00000ca2 <idOfflineWelcome>:
Simple function that initiates welcome screen whenever
there is evidence of lost connection with server and 
offline mode is on.
 -----------------------------------------------------*/    
void idOfflineWelcome(void){ 
        lcdClear(); 
     ca2:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
     ca6:	8b e4       	ldi	r24, 0x4B	; 75
     ca8:	9d e1       	ldi	r25, 0x1D	; 29
     caa:	01 97       	sbiw	r24, 0x01	; 1
     cac:	f1 f7       	brne	.-4      	; 0xcaa <idOfflineWelcome+0x8>
     cae:	00 c0       	rjmp	.+0      	; 0xcb0 <idOfflineWelcome+0xe>
     cb0:	00 00       	nop
        _delay_ms(3); 
        LCDPutString("Ultra 2000 eCharge"); 
     cb2:	85 ee       	ldi	r24, 0xE5	; 229
     cb4:	92 e0       	ldi	r25, 0x02	; 2
     cb6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,1); 
     cba:	61 e0       	ldi	r22, 0x01	; 1
     cbc:	80 e0       	ldi	r24, 0x00	; 0
     cbe:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("System's offline"); 
     cc2:	8f e2       	ldi	r24, 0x2F	; 47
     cc4:	93 e0       	ldi	r25, 0x03	; 3
     cc6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,2); 
     cca:	62 e0       	ldi	r22, 0x02	; 2
     ccc:	80 e0       	ldi	r24, 0x00	; 0
     cce:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Use your RFID card"); 
     cd2:	88 ef       	ldi	r24, 0xF8	; 248
     cd4:	92 e0       	ldi	r25, 0x02	; 2
     cd6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        stateTransition(a); 
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     ce0:	08 95       	ret

00000ce2 <idOfflineGetMifareInfo>:
debt that is on card, last consumption and last expense 
and pin code. Char arrays are converted to floats in order
to lose any trailing zeros and then stored to char arrays
to be used at later actions and states.
 -----------------------------------------------------*/  
void idOfflineGetMifareInfo(void){ 
     ce2:	8f 92       	push	r8
     ce4:	9f 92       	push	r9
     ce6:	af 92       	push	r10
     ce8:	bf 92       	push	r11
     cea:	cf 92       	push	r12
     cec:	df 92       	push	r13
     cee:	ef 92       	push	r14
     cf0:	ff 92       	push	r15
     cf2:	0f 93       	push	r16
     cf4:	1f 93       	push	r17
     cf6:	cf 93       	push	r28
     cf8:	df 93       	push	r29
     offlineFirstRead = true; 
     cfa:	81 e0       	ldi	r24, 0x01	; 1
     cfc:	80 93 94 05 	sts	0x0594, r24
     rfidDone = false; 
     d00:	10 92 8e 05 	sts	0x058E, r1
     while(!RFIDinit(1, "64.76", 5)); 
     d04:	45 e0       	ldi	r20, 0x05	; 5
     d06:	50 e0       	ldi	r21, 0x00	; 0
     d08:	60 e4       	ldi	r22, 0x40	; 64
     d0a:	73 e0       	ldi	r23, 0x03	; 3
     d0c:	81 e0       	ldi	r24, 0x01	; 1
     d0e:	90 e0       	ldi	r25, 0x00	; 0
     d10:	0e 94 2c 11 	call	0x2258	; 0x2258 <RFIDinit>
     d14:	88 23       	and	r24, r24
     d16:	b1 f3       	breq	.-20     	; 0xd04 <idOfflineGetMifareInfo+0x22>
     //convert 16byte data to float 
     double creditD = atof (debtChar); 
     d18:	80 e7       	ldi	r24, 0x70	; 112
     d1a:	97 e0       	ldi	r25, 0x07	; 7
     d1c:	0e 94 ef 19 	call	0x33de	; 0x33de <atof>
     d20:	c6 2f       	mov	r28, r22
     d22:	d7 2f       	mov	r29, r23
     d24:	18 2f       	mov	r17, r24
     d26:	89 2e       	mov	r8, r25
     double pastEnergyD = atof (pastEnChar); 
     d28:	8b ef       	ldi	r24, 0xFB	; 251
     d2a:	97 e0       	ldi	r25, 0x07	; 7
     d2c:	0e 94 ef 19 	call	0x33de	; 0x33de <atof>
     d30:	c6 2e       	mov	r12, r22
     d32:	b7 2e       	mov	r11, r23
     d34:	a8 2e       	mov	r10, r24
     d36:	99 2e       	mov	r9, r25
     double pastExpenseD = atof (pastExChar); 
     d38:	86 e8       	ldi	r24, 0x86	; 134
     d3a:	97 e0       	ldi	r25, 0x07	; 7
     d3c:	0e 94 ef 19 	call	0x33de	; 0x33de <atof>
     d40:	06 2f       	mov	r16, r22
     d42:	f7 2e       	mov	r15, r23
     d44:	e8 2e       	mov	r14, r24
     d46:	d9 2e       	mov	r13, r25
     //convert float to string so zeros are lost ant only float number is stored 
    snprintf(credit_,8, "%.2f \r\n", creditD); 
     d48:	8f 92       	push	r8
     d4a:	1f 93       	push	r17
     d4c:	df 93       	push	r29
     d4e:	cf 93       	push	r28
     d50:	c6 e4       	ldi	r28, 0x46	; 70
     d52:	d3 e0       	ldi	r29, 0x03	; 3
     d54:	df 93       	push	r29
     d56:	cf 93       	push	r28
     d58:	1f 92       	push	r1
     d5a:	18 e0       	ldi	r17, 0x08	; 8
     d5c:	1f 93       	push	r17
     d5e:	2a ea       	ldi	r18, 0xAA	; 170
     d60:	36 e0       	ldi	r19, 0x06	; 6
     d62:	3f 93       	push	r19
     d64:	2f 93       	push	r18
     d66:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
    snprintf(pastEnergy_,8, "%.2f \r\n", pastEnergyD); 
     d6a:	9f 92       	push	r9
     d6c:	af 92       	push	r10
     d6e:	bf 92       	push	r11
     d70:	cf 92       	push	r12
     d72:	df 93       	push	r29
     d74:	cf 93       	push	r28
     d76:	1f 92       	push	r1
     d78:	1f 93       	push	r17
     d7a:	2c ec       	ldi	r18, 0xCC	; 204
     d7c:	36 e0       	ldi	r19, 0x06	; 6
     d7e:	3f 93       	push	r19
     d80:	2f 93       	push	r18
     d82:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
    snprintf(pastExpense_,8, "%.2f \r\n", pastExpenseD); 
     d86:	df 92       	push	r13
     d88:	ef 92       	push	r14
     d8a:	ff 92       	push	r15
     d8c:	0f 93       	push	r16
     d8e:	df 93       	push	r29
     d90:	cf 93       	push	r28
     d92:	1f 92       	push	r1
     d94:	1f 93       	push	r17
     d96:	8b eb       	ldi	r24, 0xBB	; 187
     d98:	96 e0       	ldi	r25, 0x06	; 6
     d9a:	9f 93       	push	r25
     d9c:	8f 93       	push	r24
     d9e:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
      
    stateTransition(b); 
     da2:	82 e0       	ldi	r24, 0x02	; 2
     da4:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     da8:	8d b7       	in	r24, 0x3d	; 61
     daa:	9e b7       	in	r25, 0x3e	; 62
     dac:	4e 96       	adiw	r24, 0x1e	; 30
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	f8 94       	cli
     db2:	9e bf       	out	0x3e, r25	; 62
     db4:	0f be       	out	0x3f, r0	; 63
     db6:	8d bf       	out	0x3d, r24	; 61
} 
     db8:	df 91       	pop	r29
     dba:	cf 91       	pop	r28
     dbc:	1f 91       	pop	r17
     dbe:	0f 91       	pop	r16
     dc0:	ff 90       	pop	r15
     dc2:	ef 90       	pop	r14
     dc4:	df 90       	pop	r13
     dc6:	cf 90       	pop	r12
     dc8:	bf 90       	pop	r11
     dca:	af 90       	pop	r10
     dcc:	9f 90       	pop	r9
     dce:	8f 90       	pop	r8
     dd0:	08 95       	ret

00000dd2 <idleWaitingf>:
Function that is fired on idle state, has simple string
output on LCD and waits for any key pressed. After it's
pressed, fires action that starts session.
 -----------------------------------------------------*/   
void idleWaitingf(){ 
        lcdClear(); 
     dd2:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
     dd6:	87 ea       	ldi	r24, 0xA7	; 167
     dd8:	91 e6       	ldi	r25, 0x61	; 97
     dda:	01 97       	sbiw	r24, 0x01	; 1
     ddc:	f1 f7       	brne	.-4      	; 0xdda <idleWaitingf+0x8>
     dde:	00 c0       	rjmp	.+0      	; 0xde0 <idleWaitingf+0xe>
     de0:	00 00       	nop
        _delay_ms(10); 
        GoTo(0,1);
     de2:	61 e0       	ldi	r22, 0x01	; 1
     de4:	80 e0       	ldi	r24, 0x00	; 0
     de6:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
		LCDPutString("Ultra 2000 eCharger"); 
     dea:	8e e4       	ldi	r24, 0x4E	; 78
     dec:	93 e0       	ldi	r25, 0x03	; 3
     dee:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,2); 
     df2:	62 e0       	ldi	r22, 0x02	; 2
     df4:	80 e0       	ldi	r24, 0x00	; 0
     df6:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Press any key"); 
     dfa:	82 e6       	ldi	r24, 0x62	; 98
     dfc:	93 e0       	ldi	r25, 0x03	; 3
     dfe:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        while (scanKeyPad()!=1); 
     e02:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
     e06:	81 30       	cpi	r24, 0x01	; 1
     e08:	e1 f7       	brne	.-8      	; 0xe02 <idleWaitingf+0x30>
        stateTransition(e); 
     e0a:	85 e0       	ldi	r24, 0x05	; 5
     e0c:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     e10:	08 95       	ret

00000e12 <offlinePINcheck>:
Function that takes external array with pin values that 
were read from RFID card and checks with one that is 
entered by user.
 -----------------------------------------------------*/ 
void offlinePINcheck(void){ 
    if ((pinChar[0] == pin[0]) && (pinChar[1] == pin[1]) && (pinChar[2] == pin[2]) && (pinChar[3] == pin[3])) 
     e12:	90 91 81 07 	lds	r25, 0x0781
     e16:	80 91 dd 06 	lds	r24, 0x06DD
     e1a:	98 13       	cpse	r25, r24
     e1c:	16 c0       	rjmp	.+44     	; 0xe4a <offlinePINcheck+0x38>
     e1e:	90 91 82 07 	lds	r25, 0x0782
     e22:	80 91 de 06 	lds	r24, 0x06DE
     e26:	98 13       	cpse	r25, r24
     e28:	10 c0       	rjmp	.+32     	; 0xe4a <offlinePINcheck+0x38>
     e2a:	90 91 83 07 	lds	r25, 0x0783
     e2e:	80 91 df 06 	lds	r24, 0x06DF
     e32:	98 13       	cpse	r25, r24
     e34:	0a c0       	rjmp	.+20     	; 0xe4a <offlinePINcheck+0x38>
     e36:	90 91 84 07 	lds	r25, 0x0784
     e3a:	80 91 e0 06 	lds	r24, 0x06E0
     e3e:	98 13       	cpse	r25, r24
     e40:	04 c0       	rjmp	.+8      	; 0xe4a <offlinePINcheck+0x38>
    { 
        stateTransition(g); //id session is done 
     e42:	87 e0       	ldi	r24, 0x07	; 7
     e44:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     e48:	08 95       	ret
    }else{ 
        GoTo(0,3); 
     e4a:	63 e0       	ldi	r22, 0x03	; 3
     e4c:	80 e0       	ldi	r24, 0x00	; 0
     e4e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        incorrectPIN = true; 
     e52:	81 e0       	ldi	r24, 0x01	; 1
     e54:	80 93 7f 05 	sts	0x057F, r24
        stateTransition(b); 
     e58:	82 e0       	ldi	r24, 0x02	; 2
     e5a:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     e5e:	08 95       	ret

00000e60 <waitUntilKeysPressed>:
bool waitUntilKeysPressed(char fkey, char fkey1)
Function that gets two chars, ASCII representation of keys
and waits for one of them to be pressed, stores 1 in global
variable if first key is pressed, 2 if second pressed.
 -----------------------------------------------------*/    
bool waitUntilKeysPressed(char fkey, char fkey1){ 
     e60:	cf 93       	push	r28
     e62:	df 93       	push	r29
     e64:	c8 2f       	mov	r28, r24
     e66:	d6 2f       	mov	r29, r22
    char keyPressedf; 
    while (scanKeyPad()!=1); 
     e68:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
     e6c:	81 30       	cpi	r24, 0x01	; 1
     e6e:	e1 f7       	brne	.-8      	; 0xe68 <waitUntilKeysPressed+0x8>
    keyPressedf = returnKey(); 
     e70:	0e 94 0c 09 	call	0x1218	; 0x1218 <returnKey>
      
    if (keyPressedf == fkey) 
     e74:	8c 13       	cpse	r24, r28
     e76:	08 c0       	rjmp	.+16     	; 0xe88 <waitUntilKeysPressed+0x28>
    { 
        keyPressed = 1; 
     e78:	81 e0       	ldi	r24, 0x01	; 1
     e7a:	90 e0       	ldi	r25, 0x00	; 0
     e7c:	90 93 81 05 	sts	0x0581, r25
     e80:	80 93 80 05 	sts	0x0580, r24
        return true; 
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	0b c0       	rjmp	.+22     	; 0xe9e <waitUntilKeysPressed+0x3e>
    } 
    else if(keyPressedf == fkey1) 
     e88:	8d 13       	cpse	r24, r29
     e8a:	08 c0       	rjmp	.+16     	; 0xe9c <waitUntilKeysPressed+0x3c>
    { 
        keyPressed = 2; 
     e8c:	82 e0       	ldi	r24, 0x02	; 2
     e8e:	90 e0       	ldi	r25, 0x00	; 0
     e90:	90 93 81 05 	sts	0x0581, r25
     e94:	80 93 80 05 	sts	0x0580, r24
        return true; 
     e98:	81 e0       	ldi	r24, 0x01	; 1
     e9a:	01 c0       	rjmp	.+2      	; 0xe9e <waitUntilKeysPressed+0x3e>
    } 
    return false; 
     e9c:	80 e0       	ldi	r24, 0x00	; 0
} 
     e9e:	df 91       	pop	r29
     ea0:	cf 91       	pop	r28
     ea2:	08 95       	ret

00000ea4 <StartSession>:
Function that initiates session start with server by sending
data package. If answered command is 23, it is online mode,
if server is off and sent command is 24 - it is offline mode
and appropriate indications are put on LCD.
 -----------------------------------------------------*/      
void StartSession(void){ 
     ea4:	cf 93       	push	r28
     ea6:	df 93       	push	r29
     ea8:	00 d0       	rcall	.+0      	; 0xeaa <StartSession+0x6>
     eaa:	1f 92       	push	r1
     eac:	cd b7       	in	r28, 0x3d	; 61
     eae:	de b7       	in	r29, 0x3e	; 62
    formPacket("02", "01", "22", "StartSession"); 
     eb0:	20 e7       	ldi	r18, 0x70	; 112
     eb2:	33 e0       	ldi	r19, 0x03	; 3
     eb4:	4d e7       	ldi	r20, 0x7D	; 125
     eb6:	53 e0       	ldi	r21, 0x03	; 3
     eb8:	6c eb       	ldi	r22, 0xBC	; 188
     eba:	72 e0       	ldi	r23, 0x02	; 2
     ebc:	8f eb       	ldi	r24, 0xBF	; 191
     ebe:	92 e0       	ldi	r25, 0x02	; 2
     ec0:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
    sendStringUSART(formedDataPackageToSend); 
     ec4:	8a e1       	ldi	r24, 0x1A	; 26
     ec6:	95 e0       	ldi	r25, 0x05	; 5
     ec8:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    while(!packageReceived()); 
     ecc:	0e 94 c1 03 	call	0x782	; 0x782 <packageReceived>
     ed0:	88 23       	and	r24, r24
     ed2:	e1 f3       	breq	.-8      	; 0xecc <StartSession+0x28>
      
    if (_command == 23) 
     ed4:	80 91 1c 06 	lds	r24, 0x061C
     ed8:	90 91 1d 06 	lds	r25, 0x061D
     edc:	87 31       	cpi	r24, 0x17	; 23
     ede:	91 05       	cpc	r25, r1
     ee0:	61 f4       	brne	.+24     	; 0xefa <StartSession+0x56>
    { 
        GoTo(0,2); 
     ee2:	62 e0       	ldi	r22, 0x02	; 2
     ee4:	80 e0       	ldi	r24, 0x00	; 0
     ee6:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Connected");//To RFID 
     eea:	80 e8       	ldi	r24, 0x80	; 128
     eec:	93 e0       	ldi	r25, 0x03	; 3
     eee:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        stateTransition(c); 
     ef2:	83 e0       	ldi	r24, 0x03	; 3
     ef4:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     ef8:	76 c0       	rjmp	.+236    	; 0xfe6 <StartSession+0x142>
    } 
      
    else if (_command == 24) 
     efa:	48 97       	sbiw	r24, 0x18	; 24
     efc:	09 f0       	breq	.+2      	; 0xf00 <StartSession+0x5c>
     efe:	6a c0       	rjmp	.+212    	; 0xfd4 <StartSession+0x130>
    { 
        lcdClear(); 
     f00:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
     f04:	83 ed       	ldi	r24, 0xD3	; 211
     f06:	90 e3       	ldi	r25, 0x30	; 48
     f08:	01 97       	sbiw	r24, 0x01	; 1
     f0a:	f1 f7       	brne	.-4      	; 0xf08 <StartSession+0x64>
     f0c:	00 c0       	rjmp	.+0      	; 0xf0e <StartSession+0x6a>
     f0e:	00 00       	nop
        _delay_ms(5); 
        GoTo(0,0); 
     f10:	60 e0       	ldi	r22, 0x00	; 0
     f12:	80 e0       	ldi	r24, 0x00	; 0
     f14:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("No connection"); 
     f18:	8a e8       	ldi	r24, 0x8A	; 138
     f1a:	93 e0       	ldi	r25, 0x03	; 3
     f1c:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,1); 
     f20:	61 e0       	ldi	r22, 0x01	; 1
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     f28:	91 e2       	ldi	r25, 0x21	; 33
     f2a:	9a 95       	dec	r25
     f2c:	f1 f7       	brne	.-4      	; 0xf2a <StartSession+0x86>
     f2e:	00 00       	nop
        _delay_us(10); 
        LCDPutString("Offline, fixed price"); 
     f30:	88 e9       	ldi	r24, 0x98	; 152
     f32:	93 e0       	ldi	r25, 0x03	; 3
     f34:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,2); 
     f38:	62 e0       	ldi	r22, 0x02	; 2
     f3a:	80 e0       	ldi	r24, 0x00	; 0
     f3c:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        char fixedPrice[3]; 
        itoa(OFFLINE_PRICE, fixedPrice, 10); 
     f40:	4a e0       	ldi	r20, 0x0A	; 10
     f42:	50 e0       	ldi	r21, 0x00	; 0
     f44:	be 01       	movw	r22, r28
     f46:	6f 5f       	subi	r22, 0xFF	; 255
     f48:	7f 4f       	sbci	r23, 0xFF	; 255
     f4a:	80 91 1f 01 	lds	r24, 0x011F
     f4e:	90 91 20 01 	lds	r25, 0x0120
     f52:	0e 94 0f 1b 	call	0x361e	; 0x361e <itoa>
        LCDPutString(fixedPrice); 
     f56:	ce 01       	movw	r24, r28
     f58:	01 96       	adiw	r24, 0x01	; 1
     f5a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        LCDPutString("dkk/kWs"); 
     f5e:	8d ea       	ldi	r24, 0xAD	; 173
     f60:	93 e0       	ldi	r25, 0x03	; 3
     f62:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,3); 
     f66:	63 e0       	ldi	r22, 0x03	; 3
     f68:	80 e0       	ldi	r24, 0x00	; 0
     f6a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        lcd_data_write(doneCharf); 
     f6e:	80 91 82 05 	lds	r24, 0x0582
     f72:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
        LCDPutString("Accept        "); 
     f76:	85 eb       	ldi	r24, 0xB5	; 181
     f78:	93 e0       	ldi	r25, 0x03	; 3
     f7a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        lcd_data_write(arrowf); 
     f7e:	80 91 21 01 	lds	r24, 0x0121
     f82:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
        LCDPutString("Back"); 
     f86:	86 e7       	ldi	r24, 0x76	; 118
     f88:	94 e0       	ldi	r25, 0x04	; 4
     f8a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        while(!waitUntilKeysPressed('A', 'B')); 
     f8e:	62 e4       	ldi	r22, 0x42	; 66
     f90:	81 e4       	ldi	r24, 0x41	; 65
     f92:	0e 94 30 07 	call	0xe60	; 0xe60 <waitUntilKeysPressed>
     f96:	88 23       	and	r24, r24
     f98:	d1 f3       	breq	.-12     	; 0xf8e <StartSession+0xea>
        offline_mode = true; 
     f9a:	81 e0       	ldi	r24, 0x01	; 1
     f9c:	80 93 83 05 	sts	0x0583, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     fa0:	2f e7       	ldi	r18, 0x7F	; 127
     fa2:	8d e8       	ldi	r24, 0x8D	; 141
     fa4:	9b e5       	ldi	r25, 0x5B	; 91
     fa6:	21 50       	subi	r18, 0x01	; 1
     fa8:	80 40       	sbci	r24, 0x00	; 0
     faa:	90 40       	sbci	r25, 0x00	; 0
     fac:	e1 f7       	brne	.-8      	; 0xfa6 <StartSession+0x102>
     fae:	00 c0       	rjmp	.+0      	; 0xfb0 <StartSession+0x10c>
     fb0:	00 00       	nop
        _delay_ms(3000); 
        //To RFID, fixed price, offline mode 
        if (keyPressed == 1) 
     fb2:	80 91 80 05 	lds	r24, 0x0580
     fb6:	90 91 81 05 	lds	r25, 0x0581
     fba:	81 30       	cpi	r24, 0x01	; 1
     fbc:	91 05       	cpc	r25, r1
     fbe:	21 f4       	brne	.+8      	; 0xfc8 <StartSession+0x124>
        { 
            stateTransition(a); 
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     fc6:	0f c0       	rjmp	.+30     	; 0xfe6 <StartSession+0x142>
        }else if (keyPressed == 2) 
     fc8:	02 97       	sbiw	r24, 0x02	; 2
     fca:	69 f4       	brne	.+26     	; 0xfe6 <StartSession+0x142>
        { 
            stateTransition(d); 
     fcc:	84 e0       	ldi	r24, 0x04	; 4
     fce:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
     fd2:	09 c0       	rjmp	.+18     	; 0xfe6 <StartSession+0x142>
          
    } 
    else
    { 
        //Repead data packet 
        stateTransition(b); 
     fd4:	82 e0       	ldi	r24, 0x02	; 2
     fd6:	0e 94 b5 04 	call	0x96a	; 0x96a <stateTransition>
        back = 1; 
     fda:	81 e0       	ldi	r24, 0x01	; 1
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	90 93 96 06 	sts	0x0696, r25
     fe2:	80 93 95 06 	sts	0x0695, r24
    } 
} 
     fe6:	0f 90       	pop	r0
     fe8:	0f 90       	pop	r0
     fea:	0f 90       	pop	r0
     fec:	df 91       	pop	r29
     fee:	cf 91       	pop	r28
     ff0:	08 95       	ret

00000ff2 <setRow>:
This function sets a row to be checked for key press.
Four button rows, four cases. Parameter is int cnt, that 
is passed from main state machine.
-----------------------------------------------------*/	
void setRow(int cnt){
	switch(cnt){
     ff2:	82 30       	cpi	r24, 0x02	; 2
     ff4:	91 05       	cpc	r25, r1
     ff6:	51 f0       	breq	.+20     	; 0x100c <setRow+0x1a>
     ff8:	1c f4       	brge	.+6      	; 0x1000 <setRow+0xe>
     ffa:	01 97       	sbiw	r24, 0x01	; 1
     ffc:	91 f4       	brne	.+36     	; 0x1022 <setRow+0x30>
     ffe:	0f c0       	rjmp	.+30     	; 0x101e <setRow+0x2c>
    1000:	83 30       	cpi	r24, 0x03	; 3
    1002:	91 05       	cpc	r25, r1
    1004:	31 f0       	breq	.+12     	; 0x1012 <setRow+0x20>
    1006:	04 97       	sbiw	r24, 0x04	; 4
    1008:	61 f4       	brne	.+24     	; 0x1022 <setRow+0x30>
    100a:	06 c0       	rjmp	.+12     	; 0x1018 <setRow+0x26>
		
		case 2:  PORTC|= (1<<PC6); PORTC&=~(1<<PC7);  break; //10
    100c:	ae 9a       	sbi	0x15, 6	; 21
    100e:	af 98       	cbi	0x15, 7	; 21
    1010:	08 95       	ret
		
		case 3:  PORTC&=~(1<<PC6); PORTC|= (1<<PC7);  break; //01
    1012:	ae 98       	cbi	0x15, 6	; 21
    1014:	af 9a       	sbi	0x15, 7	; 21
    1016:	08 95       	ret
		
		case 4:  PORTC|= (1<<PC6); PORTC|= (1<<PC7);  break; //11
    1018:	ae 9a       	sbi	0x15, 6	; 21
    101a:	af 9a       	sbi	0x15, 7	; 21
    101c:	08 95       	ret
		
		case 1:  PORTC&=~(1<<PC6); PORTC&=~(1<<PC7);  break; //00
    101e:	ae 98       	cbi	0x15, 6	; 21
    1020:	af 98       	cbi	0x15, 7	; 21
    1022:	08 95       	ret

00001024 <RawKeyPressed>:
This function checks whether any key was pressed or not.
Returns 0x02 for pressed and 0x00 for no press.
-----------------------------------------------------*/
unsigned char RawKeyPressed()
{
	char temp1=(PINB&0x04)>>1|(PINB&0x08)>>3|(PINB&0x02)<<1;
    1024:	46 b3       	in	r20, 0x16	; 22
    1026:	96 b3       	in	r25, 0x16	; 22
    1028:	86 b3       	in	r24, 0x16	; 22
    102a:	93 fb       	bst	r25, 3
    102c:	99 27       	eor	r25, r25
    102e:	90 f9       	bld	r25, 0
    1030:	44 70       	andi	r20, 0x04	; 4
    1032:	50 e0       	ldi	r21, 0x00	; 0
    1034:	9a 01       	movw	r18, r20
    1036:	35 95       	asr	r19
    1038:	27 95       	ror	r18
    103a:	29 2b       	or	r18, r25
    103c:	82 70       	andi	r24, 0x02	; 2
    103e:	88 0f       	add	r24, r24
	return(temp1);
}
    1040:	82 2b       	or	r24, r18
    1042:	08 95       	ret

00001044 <findKey>:
for character value. It looks up a table and returns a 
key_d variable with corresponding ASCII value.
-----------------------------------------------------*/
char findKey(int row, char temp){
	char key_d=0;
	switch(temp)
    1044:	63 30       	cpi	r22, 0x03	; 3
    1046:	d9 f0       	breq	.+54     	; 0x107e <findKey+0x3a>
    1048:	18 f4       	brcc	.+6      	; 0x1050 <findKey+0xc>
    104a:	62 30       	cpi	r22, 0x02	; 2
    104c:	51 f5       	brne	.+84     	; 0x10a2 <findKey+0x5e>
    104e:	05 c0       	rjmp	.+10     	; 0x105a <findKey+0x16>
    1050:	66 30       	cpi	r22, 0x06	; 6
    1052:	61 f0       	breq	.+24     	; 0x106c <findKey+0x28>
    1054:	67 30       	cpi	r22, 0x07	; 7
    1056:	29 f5       	brne	.+74     	; 0x10a2 <findKey+0x5e>
    1058:	1b c0       	rjmp	.+54     	; 0x1090 <findKey+0x4c>
	{
		case 0b0000010: key_d=key_table[row-1][0]; break;
    105a:	fc 01       	movw	r30, r24
    105c:	ee 0f       	add	r30, r30
    105e:	ff 1f       	adc	r31, r31
    1060:	ee 0f       	add	r30, r30
    1062:	ff 1f       	adc	r31, r31
    1064:	e2 5e       	subi	r30, 0xE2	; 226
    1066:	fe 4f       	sbci	r31, 0xFE	; 254
    1068:	80 81       	ld	r24, Z
    106a:	08 95       	ret
		
		case 0b0000110: key_d=key_table[row-1][1]; break;
    106c:	fc 01       	movw	r30, r24
    106e:	ee 0f       	add	r30, r30
    1070:	ff 1f       	adc	r31, r31
    1072:	ee 0f       	add	r30, r30
    1074:	ff 1f       	adc	r31, r31
    1076:	e2 5e       	subi	r30, 0xE2	; 226
    1078:	fe 4f       	sbci	r31, 0xFE	; 254
    107a:	81 81       	ldd	r24, Z+1	; 0x01
    107c:	08 95       	ret
		
		case 0b0000011: key_d=key_table[row-1][2]; break;
    107e:	fc 01       	movw	r30, r24
    1080:	ee 0f       	add	r30, r30
    1082:	ff 1f       	adc	r31, r31
    1084:	ee 0f       	add	r30, r30
    1086:	ff 1f       	adc	r31, r31
    1088:	e2 5e       	subi	r30, 0xE2	; 226
    108a:	fe 4f       	sbci	r31, 0xFE	; 254
    108c:	82 81       	ldd	r24, Z+2	; 0x02
    108e:	08 95       	ret
		
		case 0b0000111: key_d=key_table[row-1][3]; break;
    1090:	fc 01       	movw	r30, r24
    1092:	ee 0f       	add	r30, r30
    1094:	ff 1f       	adc	r31, r31
    1096:	ee 0f       	add	r30, r30
    1098:	ff 1f       	adc	r31, r31
    109a:	e2 5e       	subi	r30, 0xE2	; 226
    109c:	fe 4f       	sbci	r31, 0xFE	; 254
    109e:	83 81       	ldd	r24, Z+3	; 0x03
    10a0:	08 95       	ret
Parameters passed are int row for row number and char temp
for character value. It looks up a table and returns a 
key_d variable with corresponding ASCII value.
-----------------------------------------------------*/
char findKey(int row, char temp){
	char key_d=0;
    10a2:	80 e0       	ldi	r24, 0x00	; 0
		
		default: break;
	}
	return key_d;
	
}
    10a4:	08 95       	ret

000010a6 <delay>:
times. 
-----------------------------------------------------*/
bool delay(char ms)
{
	int i;
	for (i=0;i<ms;i++)
    10a6:	90 e0       	ldi	r25, 0x00	; 0
    10a8:	18 16       	cp	r1, r24
    10aa:	19 06       	cpc	r1, r25
    10ac:	6c f4       	brge	.+26     	; 0x10c8 <delay+0x22>
    10ae:	20 e0       	ldi	r18, 0x00	; 0
    10b0:	30 e0       	ldi	r19, 0x00	; 0
    10b2:	e9 ef       	ldi	r30, 0xF9	; 249
    10b4:	f0 e0       	ldi	r31, 0x00	; 0
    10b6:	31 97       	sbiw	r30, 0x01	; 1
    10b8:	f1 f7       	brne	.-4      	; 0x10b6 <delay+0x10>
    10ba:	00 c0       	rjmp	.+0      	; 0x10bc <delay+0x16>
    10bc:	00 00       	nop
    10be:	2f 5f       	subi	r18, 0xFF	; 255
    10c0:	3f 4f       	sbci	r19, 0xFF	; 255
    10c2:	28 17       	cp	r18, r24
    10c4:	39 07       	cpc	r19, r25
    10c6:	ac f3       	brlt	.-22     	; 0x10b2 <delay+0xc>
	{
		_delay_ms(1);
	}
	return true;
}
    10c8:	81 e0       	ldi	r24, 0x01	; 1
    10ca:	08 95       	ret

000010cc <scanKeyPad>:
key press was detected, encoded and ASCII value found.
ASCII value is stored in global value key.
-----------------------------------------------------*/
char scanKeyPad(){
	
	switch(state1)
    10cc:	80 91 e3 06 	lds	r24, 0x06E3
    10d0:	83 30       	cpi	r24, 0x03	; 3
    10d2:	09 f4       	brne	.+2      	; 0x10d6 <scanKeyPad+0xa>
    10d4:	58 c0       	rjmp	.+176    	; 0x1186 <scanKeyPad+0xba>
    10d6:	28 f4       	brcc	.+10     	; 0x10e2 <scanKeyPad+0x16>
    10d8:	81 30       	cpi	r24, 0x01	; 1
    10da:	d1 f1       	breq	.+116    	; 0x1150 <scanKeyPad+0x84>
    10dc:	08 f0       	brcs	.+2      	; 0x10e0 <scanKeyPad+0x14>
    10de:	40 c0       	rjmp	.+128    	; 0x1160 <scanKeyPad+0x94>
    10e0:	09 c0       	rjmp	.+18     	; 0x10f4 <scanKeyPad+0x28>
    10e2:	85 30       	cpi	r24, 0x05	; 5
    10e4:	09 f4       	brne	.+2      	; 0x10e8 <scanKeyPad+0x1c>
    10e6:	79 c0       	rjmp	.+242    	; 0x11da <scanKeyPad+0x10e>
    10e8:	08 f4       	brcc	.+2      	; 0x10ec <scanKeyPad+0x20>
    10ea:	61 c0       	rjmp	.+194    	; 0x11ae <scanKeyPad+0xe2>
    10ec:	86 30       	cpi	r24, 0x06	; 6
    10ee:	09 f0       	breq	.+2      	; 0x10f2 <scanKeyPad+0x26>
    10f0:	8e c0       	rjmp	.+284    	; 0x120e <scanKeyPad+0x142>
    10f2:	84 c0       	rjmp	.+264    	; 0x11fc <scanKeyPad+0x130>
	{
		case idle:
		if(keyfound==1)
    10f4:	80 91 e7 06 	lds	r24, 0x06E7
    10f8:	90 91 e8 06 	lds	r25, 0x06E8
    10fc:	01 97       	sbiw	r24, 0x01	; 1
    10fe:	21 f4       	brne	.+8      	; 0x1108 <scanKeyPad+0x3c>
		{
			keyfound=0;
    1100:	10 92 e8 06 	sts	0x06E8, r1
    1104:	10 92 e7 06 	sts	0x06E7, r1
		} if (count==5)
    1108:	80 91 e5 06 	lds	r24, 0x06E5
    110c:	90 91 e6 06 	lds	r25, 0x06E6
    1110:	05 97       	sbiw	r24, 0x05	; 5
    1112:	41 f4       	brne	.+16     	; 0x1124 <scanKeyPad+0x58>
		{ 
			count=1; 
    1114:	81 e0       	ldi	r24, 0x01	; 1
    1116:	90 e0       	ldi	r25, 0x00	; 0
    1118:	90 93 e6 06 	sts	0x06E6, r25
    111c:	80 93 e5 06 	sts	0x06E5, r24
			setRow(count);
    1120:	0e 94 f9 07 	call	0xff2	; 0xff2 <setRow>
		} if ((RawKeyPressed()&0x02)==(0x02)) 
    1124:	0e 94 12 08 	call	0x1024	; 0x1024 <RawKeyPressed>
    1128:	81 ff       	sbrs	r24, 1
    112a:	04 c0       	rjmp	.+8      	; 0x1134 <scanKeyPad+0x68>
		{ 
			state1=keyPresses;
    112c:	81 e0       	ldi	r24, 0x01	; 1
    112e:	80 93 e3 06 	sts	0x06E3, r24
    1132:	6f c0       	rjmp	.+222    	; 0x1212 <scanKeyPad+0x146>
		} else {
			state1=idle; 
    1134:	10 92 e3 06 	sts	0x06E3, r1
			count++; 
    1138:	80 91 e5 06 	lds	r24, 0x06E5
    113c:	90 91 e6 06 	lds	r25, 0x06E6
    1140:	01 96       	adiw	r24, 0x01	; 1
    1142:	90 93 e6 06 	sts	0x06E6, r25
    1146:	80 93 e5 06 	sts	0x06E5, r24
			setRow(count);
    114a:	0e 94 f9 07 	call	0xff2	; 0xff2 <setRow>
    114e:	61 c0       	rjmp	.+194    	; 0x1212 <scanKeyPad+0x146>
		} break;
		
		case keyPresses: 
		temp=RawKeyPressed(); 
    1150:	0e 94 12 08 	call	0x1024	; 0x1024 <RawKeyPressed>
    1154:	80 93 e2 06 	sts	0x06E2, r24
		state1=debounce; 
    1158:	82 e0       	ldi	r24, 0x02	; 2
    115a:	80 93 e3 06 	sts	0x06E3, r24
		break;
    115e:	59 c0       	rjmp	.+178    	; 0x1212 <scanKeyPad+0x146>
		
		case debounce: 
		if((delay(10)) && (temp==RawKeyPressed()))
    1160:	8a e0       	ldi	r24, 0x0A	; 10
    1162:	0e 94 53 08 	call	0x10a6	; 0x10a6 <delay>
    1166:	88 23       	and	r24, r24
    1168:	51 f0       	breq	.+20     	; 0x117e <scanKeyPad+0xb2>
    116a:	0e 94 12 08 	call	0x1024	; 0x1024 <RawKeyPressed>
    116e:	90 91 e2 06 	lds	r25, 0x06E2
    1172:	89 13       	cpse	r24, r25
    1174:	04 c0       	rjmp	.+8      	; 0x117e <scanKeyPad+0xb2>
		{ 
			state1=getKey; 
    1176:	83 e0       	ldi	r24, 0x03	; 3
    1178:	80 93 e3 06 	sts	0x06E3, r24
    117c:	4a c0       	rjmp	.+148    	; 0x1212 <scanKeyPad+0x146>
		}else { 
			state1=debounce;
    117e:	82 e0       	ldi	r24, 0x02	; 2
    1180:	80 93 e3 06 	sts	0x06E3, r24
    1184:	46 c0       	rjmp	.+140    	; 0x1212 <scanKeyPad+0x146>
		}  break;
		
		case getKey:state1=waitRelease; key=findKey(count,temp); keyfound=1; break;
    1186:	84 e0       	ldi	r24, 0x04	; 4
    1188:	80 93 e3 06 	sts	0x06E3, r24
    118c:	60 91 e2 06 	lds	r22, 0x06E2
    1190:	80 91 e5 06 	lds	r24, 0x06E5
    1194:	90 91 e6 06 	lds	r25, 0x06E6
    1198:	0e 94 22 08 	call	0x1044	; 0x1044 <findKey>
    119c:	80 93 e4 06 	sts	0x06E4, r24
    11a0:	81 e0       	ldi	r24, 0x01	; 1
    11a2:	90 e0       	ldi	r25, 0x00	; 0
    11a4:	90 93 e8 06 	sts	0x06E8, r25
    11a8:	80 93 e7 06 	sts	0x06E7, r24
    11ac:	32 c0       	rjmp	.+100    	; 0x1212 <scanKeyPad+0x146>

		case waitRelease: if(keyfound==1){keyfound=0;} if ((RawKeyPressed()&0x02)==(0x02)){state1=releasedDebounce;} else {state1=released;} break;
    11ae:	80 91 e7 06 	lds	r24, 0x06E7
    11b2:	90 91 e8 06 	lds	r25, 0x06E8
    11b6:	01 97       	sbiw	r24, 0x01	; 1
    11b8:	21 f4       	brne	.+8      	; 0x11c2 <scanKeyPad+0xf6>
    11ba:	10 92 e8 06 	sts	0x06E8, r1
    11be:	10 92 e7 06 	sts	0x06E7, r1
    11c2:	0e 94 12 08 	call	0x1024	; 0x1024 <RawKeyPressed>
    11c6:	81 ff       	sbrs	r24, 1
    11c8:	04 c0       	rjmp	.+8      	; 0x11d2 <scanKeyPad+0x106>
    11ca:	85 e0       	ldi	r24, 0x05	; 5
    11cc:	80 93 e3 06 	sts	0x06E3, r24
    11d0:	20 c0       	rjmp	.+64     	; 0x1212 <scanKeyPad+0x146>
    11d2:	86 e0       	ldi	r24, 0x06	; 6
    11d4:	80 93 e3 06 	sts	0x06E3, r24
    11d8:	1c c0       	rjmp	.+56     	; 0x1212 <scanKeyPad+0x146>
		
		case releasedDebounce: 
		if((delay(35)) && (RawKeyPressed()==0b0000000))
    11da:	83 e2       	ldi	r24, 0x23	; 35
    11dc:	0e 94 53 08 	call	0x10a6	; 0x10a6 <delay>
    11e0:	88 23       	and	r24, r24
    11e2:	41 f0       	breq	.+16     	; 0x11f4 <scanKeyPad+0x128>
    11e4:	0e 94 12 08 	call	0x1024	; 0x1024 <RawKeyPressed>
    11e8:	81 11       	cpse	r24, r1
    11ea:	04 c0       	rjmp	.+8      	; 0x11f4 <scanKeyPad+0x128>
		{
			state1=released;
    11ec:	86 e0       	ldi	r24, 0x06	; 6
    11ee:	80 93 e3 06 	sts	0x06E3, r24
    11f2:	0f c0       	rjmp	.+30     	; 0x1212 <scanKeyPad+0x146>
		} else {
			state1=releasedDebounce;
    11f4:	85 e0       	ldi	r24, 0x05	; 5
    11f6:	80 93 e3 06 	sts	0x06E3, r24
    11fa:	0b c0       	rjmp	.+22     	; 0x1212 <scanKeyPad+0x146>
		} break;
		
		case released: state1=idle; count=1; break;
    11fc:	10 92 e3 06 	sts	0x06E3, r1
    1200:	81 e0       	ldi	r24, 0x01	; 1
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	90 93 e6 06 	sts	0x06E6, r25
    1208:	80 93 e5 06 	sts	0x06E5, r24
    120c:	02 c0       	rjmp	.+4      	; 0x1212 <scanKeyPad+0x146>
		
		default:state1=idle; break;
    120e:	10 92 e3 06 	sts	0x06E3, r1
	}
	

	return keyfound;
}
    1212:	80 91 e7 06 	lds	r24, 0x06E7
    1216:	08 95       	ret

00001218 <returnKey>:
a char with ASCII value.
-----------------------------------------------------*/
char returnKey()
{
	return key;
}
    1218:	80 91 e4 06 	lds	r24, 0x06E4
    121c:	08 95       	ret

0000121e <keypad_init>:
Function that sets initial values for keypad scanning
mechanism.
-----------------------------------------------------*/
void keypad_init()
{	 
	 DDRC |= 1 << PINC6;
    121e:	a6 9a       	sbi	0x14, 6	; 20
	 DDRC |= 1 << PINC7;
    1220:	a7 9a       	sbi	0x14, 7	; 20

	 state1=idle;
    1222:	10 92 e3 06 	sts	0x06E3, r1
    1226:	08 95       	ret

00001228 <lcd_nibble_transfer>:
} 


void lcd_nibble_transfer( unsigned char d )  
{ 
    lcd_port|= (1<<lcd_E);
    1228:	db 9a       	sbi	0x1b, 3	; 27
	asm volatile("NOP");   // Slow down timing 100 nS
    122a:	00 00       	nop
   	lcd_port= (lcd_port & 0x0f)| (d &0xf0);   //(always msn as 4 bit data bus)
    122c:	9b b3       	in	r25, 0x1b	; 27
    122e:	80 7f       	andi	r24, 0xF0	; 240
    1230:	9f 70       	andi	r25, 0x0F	; 15
    1232:	89 2b       	or	r24, r25
    1234:	8b bb       	out	0x1b, r24	; 27
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1236:	88 ec       	ldi	r24, 0xC8	; 200
    1238:	8a 95       	dec	r24
    123a:	f1 f7       	brne	.-4      	; 0x1238 <lcd_nibble_transfer+0x10>
  
  	
	_delay_us(60);
	lcd_port &= ~(1<<lcd_E);
    123c:	db 98       	cbi	0x1b, 3	; 27
    123e:	88 ec       	ldi	r24, 0xC8	; 200
    1240:	8a 95       	dec	r24
    1242:	f1 f7       	brne	.-4      	; 0x1240 <lcd_nibble_transfer+0x18>
    1244:	08 95       	ret

00001246 <lcd_transfer>:
//********************************************************************************************
// Low level functions
// Write to the lcd data bus - generate E pulse 

void lcd_transfer (unsigned char d)
{
    1246:	cf 93       	push	r28
    1248:	c8 2f       	mov	r28, r24
	lcd_port|= (1<<lcd_E);
    124a:	db 9a       	sbi	0x1b, 3	; 27
	asm volatile("NOP");  // Slow down timing 100 nS
    124c:	00 00       	nop
    asm volatile("NOP"); // Slow down timing 100 nS
    124e:	00 00       	nop
	lcd_nibble_transfer(d);   //(msn)
    1250:	0e 94 14 09 	call	0x1228	; 0x1228 <lcd_nibble_transfer>
  
	asm volatile("NOP");   // Slow down timing 100 nS
    1254:	00 00       	nop
	lcd_port |= (1<<lcd_E);
    1256:	db 9a       	sbi	0x1b, 3	; 27

	lcd_nibble_transfer(d<<4);   //lsn);
    1258:	8c 2f       	mov	r24, r28
    125a:	82 95       	swap	r24
    125c:	80 7f       	andi	r24, 0xF0	; 240
    125e:	0e 94 14 09 	call	0x1228	; 0x1228 <lcd_nibble_transfer>
 
} 
    1262:	cf 91       	pop	r28
    1264:	08 95       	ret

00001266 <lcd_data_write>:
   } 


void lcd_data_write(unsigned char d)
{
   lcd_direction |= 0xfc;
    1266:	9a b3       	in	r25, 0x1a	; 26
    1268:	9c 6f       	ori	r25, 0xFC	; 252
    126a:	9a bb       	out	0x1a, r25	; 26
   lcd_port|=(1<<lcd_RS);				//rs=1 when writing data
    126c:	da 9a       	sbi	0x1b, 2	; 27
   

    asm volatile("NOP");   // Slow down timing 100 nS
    126e:	00 00       	nop
   	asm volatile("NOP");   // Slow down timing 100 nS
    1270:	00 00       	nop

   lcd_transfer(d); 
    1272:	0e 94 23 09 	call	0x1246	; 0x1246 <lcd_transfer>
    1276:	08 95       	ret

00001278 <lcd_cmd_write>:
// Medium level functions
// Select RS / RW mode and call lower level funtion to complete the transfer

void lcd_cmd_write(unsigned char cmd)
   { 
    lcd_direction |= 0xfc;
    1278:	9a b3       	in	r25, 0x1a	; 26
    127a:	9c 6f       	ori	r25, 0xFC	; 252
    127c:	9a bb       	out	0x1a, r25	; 26
	lcd_port &= ~(1<<lcd_RS);
    127e:	da 98       	cbi	0x1b, 2	; 27

	asm volatile("NOP");  // Slow down timing 100 nS
    1280:	00 00       	nop
	asm volatile("NOP");   // Slow down timing 100 nS
    1282:	00 00       	nop
	lcd_transfer(cmd);
    1284:	0e 94 23 09 	call	0x1246	; 0x1246 <lcd_transfer>
    1288:	08 95       	ret

0000128a <createCustomFont>:
Writes a couple of custom made fonts to CGRAM that later
are being used.
-----------------------------------------------------*/

void createCustomFont(){
	lcd_cmd_write(0x40); //CGRAM
    128a:	80 e4       	ldi	r24, 0x40	; 64
    128c:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1290:	8f e0       	ldi	r24, 0x0F	; 15
    1292:	97 e2       	ldi	r25, 0x27	; 39
    1294:	01 97       	sbiw	r24, 0x01	; 1
    1296:	f1 f7       	brne	.-4      	; 0x1294 <createCustomFont+0xa>
    1298:	00 c0       	rjmp	.+0      	; 0x129a <createCustomFont+0x10>
    129a:	00 00       	nop
	
	_delay_ms(4);
	lcd_data_write(0);
    129c:	80 e0       	ldi	r24, 0x00	; 0
    129e:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    12a2:	87 e8       	ldi	r24, 0x87	; 135
    12a4:	93 e1       	ldi	r25, 0x13	; 19
    12a6:	01 97       	sbiw	r24, 0x01	; 1
    12a8:	f1 f7       	brne	.-4      	; 0x12a6 <createCustomFont+0x1c>
    12aa:	00 c0       	rjmp	.+0      	; 0x12ac <createCustomFont+0x22>
    12ac:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(1);
    12ae:	81 e0       	ldi	r24, 0x01	; 1
    12b0:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    12b4:	87 e8       	ldi	r24, 0x87	; 135
    12b6:	93 e1       	ldi	r25, 0x13	; 19
    12b8:	01 97       	sbiw	r24, 0x01	; 1
    12ba:	f1 f7       	brne	.-4      	; 0x12b8 <createCustomFont+0x2e>
    12bc:	00 c0       	rjmp	.+0      	; 0x12be <createCustomFont+0x34>
    12be:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(3);
    12c0:	83 e0       	ldi	r24, 0x03	; 3
    12c2:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    12c6:	87 e8       	ldi	r24, 0x87	; 135
    12c8:	93 e1       	ldi	r25, 0x13	; 19
    12ca:	01 97       	sbiw	r24, 0x01	; 1
    12cc:	f1 f7       	brne	.-4      	; 0x12ca <createCustomFont+0x40>
    12ce:	00 c0       	rjmp	.+0      	; 0x12d0 <createCustomFont+0x46>
    12d0:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(22);
    12d2:	86 e1       	ldi	r24, 0x16	; 22
    12d4:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    12d8:	87 e8       	ldi	r24, 0x87	; 135
    12da:	93 e1       	ldi	r25, 0x13	; 19
    12dc:	01 97       	sbiw	r24, 0x01	; 1
    12de:	f1 f7       	brne	.-4      	; 0x12dc <createCustomFont+0x52>
    12e0:	00 c0       	rjmp	.+0      	; 0x12e2 <createCustomFont+0x58>
    12e2:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(28);
    12e4:	8c e1       	ldi	r24, 0x1C	; 28
    12e6:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    12ea:	87 e8       	ldi	r24, 0x87	; 135
    12ec:	93 e1       	ldi	r25, 0x13	; 19
    12ee:	01 97       	sbiw	r24, 0x01	; 1
    12f0:	f1 f7       	brne	.-4      	; 0x12ee <createCustomFont+0x64>
    12f2:	00 c0       	rjmp	.+0      	; 0x12f4 <createCustomFont+0x6a>
    12f4:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(8);
    12f6:	88 e0       	ldi	r24, 0x08	; 8
    12f8:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    12fc:	87 e8       	ldi	r24, 0x87	; 135
    12fe:	93 e1       	ldi	r25, 0x13	; 19
    1300:	01 97       	sbiw	r24, 0x01	; 1
    1302:	f1 f7       	brne	.-4      	; 0x1300 <createCustomFont+0x76>
    1304:	00 c0       	rjmp	.+0      	; 0x1306 <createCustomFont+0x7c>
    1306:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(0);
    1308:	80 e0       	ldi	r24, 0x00	; 0
    130a:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    130e:	87 e8       	ldi	r24, 0x87	; 135
    1310:	93 e1       	ldi	r25, 0x13	; 19
    1312:	01 97       	sbiw	r24, 0x01	; 1
    1314:	f1 f7       	brne	.-4      	; 0x1312 <createCustomFont+0x88>
    1316:	00 c0       	rjmp	.+0      	; 0x1318 <createCustomFont+0x8e>
    1318:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(0);
    131a:	80 e0       	ldi	r24, 0x00	; 0
    131c:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    1320:	8f e0       	ldi	r24, 0x0F	; 15
    1322:	97 e2       	ldi	r25, 0x27	; 39
    1324:	01 97       	sbiw	r24, 0x01	; 1
    1326:	f1 f7       	brne	.-4      	; 0x1324 <createCustomFont+0x9a>
    1328:	00 c0       	rjmp	.+0      	; 0x132a <createCustomFont+0xa0>
    132a:	00 00       	nop
	_delay_ms(4);

	lcd_data_write(8);
    132c:	88 e0       	ldi	r24, 0x08	; 8
    132e:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    1332:	87 e8       	ldi	r24, 0x87	; 135
    1334:	93 e1       	ldi	r25, 0x13	; 19
    1336:	01 97       	sbiw	r24, 0x01	; 1
    1338:	f1 f7       	brne	.-4      	; 0x1336 <createCustomFont+0xac>
    133a:	00 c0       	rjmp	.+0      	; 0x133c <createCustomFont+0xb2>
    133c:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(12);
    133e:	8c e0       	ldi	r24, 0x0C	; 12
    1340:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    1344:	87 e8       	ldi	r24, 0x87	; 135
    1346:	93 e1       	ldi	r25, 0x13	; 19
    1348:	01 97       	sbiw	r24, 0x01	; 1
    134a:	f1 f7       	brne	.-4      	; 0x1348 <createCustomFont+0xbe>
    134c:	00 c0       	rjmp	.+0      	; 0x134e <createCustomFont+0xc4>
    134e:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(10);
    1350:	8a e0       	ldi	r24, 0x0A	; 10
    1352:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    1356:	87 e8       	ldi	r24, 0x87	; 135
    1358:	93 e1       	ldi	r25, 0x13	; 19
    135a:	01 97       	sbiw	r24, 0x01	; 1
    135c:	f1 f7       	brne	.-4      	; 0x135a <createCustomFont+0xd0>
    135e:	00 c0       	rjmp	.+0      	; 0x1360 <createCustomFont+0xd6>
    1360:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(9);
    1362:	89 e0       	ldi	r24, 0x09	; 9
    1364:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    1368:	87 e8       	ldi	r24, 0x87	; 135
    136a:	93 e1       	ldi	r25, 0x13	; 19
    136c:	01 97       	sbiw	r24, 0x01	; 1
    136e:	f1 f7       	brne	.-4      	; 0x136c <createCustomFont+0xe2>
    1370:	00 c0       	rjmp	.+0      	; 0x1372 <createCustomFont+0xe8>
    1372:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(10);
    1374:	8a e0       	ldi	r24, 0x0A	; 10
    1376:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    137a:	87 e8       	ldi	r24, 0x87	; 135
    137c:	93 e1       	ldi	r25, 0x13	; 19
    137e:	01 97       	sbiw	r24, 0x01	; 1
    1380:	f1 f7       	brne	.-4      	; 0x137e <createCustomFont+0xf4>
    1382:	00 c0       	rjmp	.+0      	; 0x1384 <createCustomFont+0xfa>
    1384:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(12);
    1386:	8c e0       	ldi	r24, 0x0C	; 12
    1388:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    138c:	87 e8       	ldi	r24, 0x87	; 135
    138e:	93 e1       	ldi	r25, 0x13	; 19
    1390:	01 97       	sbiw	r24, 0x01	; 1
    1392:	f1 f7       	brne	.-4      	; 0x1390 <createCustomFont+0x106>
    1394:	00 c0       	rjmp	.+0      	; 0x1396 <createCustomFont+0x10c>
    1396:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(8);
    1398:	88 e0       	ldi	r24, 0x08	; 8
    139a:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    139e:	87 e8       	ldi	r24, 0x87	; 135
    13a0:	93 e1       	ldi	r25, 0x13	; 19
    13a2:	01 97       	sbiw	r24, 0x01	; 1
    13a4:	f1 f7       	brne	.-4      	; 0x13a2 <createCustomFont+0x118>
    13a6:	00 c0       	rjmp	.+0      	; 0x13a8 <createCustomFont+0x11e>
    13a8:	00 00       	nop
	_delay_ms(2);
	lcd_data_write(0);
    13aa:	80 e0       	ldi	r24, 0x00	; 0
    13ac:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    13b0:	8f e0       	ldi	r24, 0x0F	; 15
    13b2:	97 e2       	ldi	r25, 0x27	; 39
    13b4:	01 97       	sbiw	r24, 0x01	; 1
    13b6:	f1 f7       	brne	.-4      	; 0x13b4 <createCustomFont+0x12a>
    13b8:	00 c0       	rjmp	.+0      	; 0x13ba <createCustomFont+0x130>
    13ba:	00 00       	nop
// 	lcd_data_write(0x1e);
// 	_delay_ms(2);
// 	lcd_data_write(0x1e);
// 	_delay_ms(10);

	lcd_data_write(0x80); //DD RAM	
    13bc:	80 e8       	ldi	r24, 0x80	; 128
    13be:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    13c2:	08 95       	ret

000013c4 <lcd_init>:
void lcd_init()    // Works like a constructor
   
   {

   // Power on delay
	lcd_direction |= 0xfc;							//	set port a as output
    13c4:	8a b3       	in	r24, 0x1a	; 26
    13c6:	8c 6f       	ori	r24, 0xFC	; 252
    13c8:	8a bb       	out	0x1a, r24	; 26
   lcd_wait( 20000 );                                   // Power on wait 
   lcd_wait( 20000 );
	lcd_port &= ~((1<<lcd_E) | (1<<lcd_RS)); // EN=0, RS=0
    13ca:	8b b3       	in	r24, 0x1b	; 27
    13cc:	83 7f       	andi	r24, 0xF3	; 243
    13ce:	8b bb       	out	0x1b, r24	; 27
//	lcd_port &= ~(1<<lcd_RW);               // Set RW = 0 in case it is connected
 
   lcd_nibble_transfer(SET_FUNCTION+IN8_BIT);
    13d0:	80 e3       	ldi	r24, 0x30	; 48
    13d2:	0e 94 14 09 	call	0x1228	; 0x1228 <lcd_nibble_transfer>
    13d6:	8f e5       	ldi	r24, 0x5F	; 95
    13d8:	9a ee       	ldi	r25, 0xEA	; 234
    13da:	01 97       	sbiw	r24, 0x01	; 1
    13dc:	f1 f7       	brne	.-4      	; 0x13da <lcd_init+0x16>
    13de:	00 c0       	rjmp	.+0      	; 0x13e0 <lcd_init+0x1c>
    13e0:	00 00       	nop
   //lcd_wait(longdelay );  						 // wait 24 ms
   _delay_ms(24);
   lcd_nibble_transfer(SET_FUNCTION+IN8_BIT);
    13e2:	80 e3       	ldi	r24, 0x30	; 48
    13e4:	0e 94 14 09 	call	0x1228	; 0x1228 <lcd_nibble_transfer>
    13e8:	8f e5       	ldi	r24, 0x5F	; 95
    13ea:	9a ee       	ldi	r25, 0xEA	; 234
    13ec:	01 97       	sbiw	r24, 0x01	; 1
    13ee:	f1 f7       	brne	.-4      	; 0x13ec <lcd_init+0x28>
    13f0:	00 c0       	rjmp	.+0      	; 0x13f2 <lcd_init+0x2e>
    13f2:	00 00       	nop
   //lcd_wait(longdelay);
    _delay_ms(24);
	lcd_nibble_transfer(SET_FUNCTION+IN8_BIT);
    13f4:	80 e3       	ldi	r24, 0x30	; 48
    13f6:	0e 94 14 09 	call	0x1228	; 0x1228 <lcd_nibble_transfer>
    13fa:	8f e5       	ldi	r24, 0x5F	; 95
    13fc:	9a ee       	ldi	r25, 0xEA	; 234
    13fe:	01 97       	sbiw	r24, 0x01	; 1
    1400:	f1 f7       	brne	.-4      	; 0x13fe <lcd_init+0x3a>
    1402:	00 c0       	rjmp	.+0      	; 0x1404 <lcd_init+0x40>
    1404:	00 00       	nop
   //lcd_wait(longdelay);
    _delay_ms(24);
	lcd_nibble_transfer(SET_FUNCTION);
    1406:	80 e2       	ldi	r24, 0x20	; 32
    1408:	0e 94 14 09 	call	0x1228	; 0x1228 <lcd_nibble_transfer>
    140c:	8f e5       	ldi	r24, 0x5F	; 95
    140e:	9a ee       	ldi	r25, 0xEA	; 234
    1410:	01 97       	sbiw	r24, 0x01	; 1
    1412:	f1 f7       	brne	.-4      	; 0x1410 <lcd_init+0x4c>
    1414:	00 c0       	rjmp	.+0      	; 0x1416 <lcd_init+0x52>
    1416:	00 00       	nop
  // lcd_wait(longdelay);
   _delay_ms(24);
   lcd_cmd_write(SET_FUNCTION+LN2_BIT);                 // Function set: 0x28  2 lines
    1418:	88 e2       	ldi	r24, 0x28	; 40
    141a:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    141e:	87 e8       	ldi	r24, 0x87	; 135
    1420:	93 e1       	ldi	r25, 0x13	; 19
    1422:	01 97       	sbiw	r24, 0x01	; 1
    1424:	f1 f7       	brne	.-4      	; 0x1422 <lcd_init+0x5e>
    1426:	00 c0       	rjmp	.+0      	; 0x1428 <lcd_init+0x64>
    1428:	00 00       	nop
  // lcd_wait(WAIT_15m);                              // Wait 39 uS
 _delay_ms(2);
    lcd_cmd_write(SET_DISPLAY);						//display off
    142a:	88 e0       	ldi	r24, 0x08	; 8
    142c:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1430:	87 e8       	ldi	r24, 0x87	; 135
    1432:	93 e1       	ldi	r25, 0x13	; 19
    1434:	01 97       	sbiw	r24, 0x01	; 1
    1436:	f1 f7       	brne	.-4      	; 0x1434 <lcd_init+0x70>
    1438:	00 c0       	rjmp	.+0      	; 0x143a <lcd_init+0x76>
    143a:	00 00       	nop
 //lcd_wait(WAIT_15m);
_delay_ms(2);	
	lcd_cmd_write(CLR_DISPLAY);       // Display clear: 0x01 clear data                 	 
    143c:	81 e0       	ldi	r24, 0x01	; 1
    143e:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1442:	87 e8       	ldi	r24, 0x87	; 135
    1444:	93 e1       	ldi	r25, 0x13	; 19
    1446:	01 97       	sbiw	r24, 0x01	; 1
    1448:	f1 f7       	brne	.-4      	; 0x1446 <lcd_init+0x82>
    144a:	00 c0       	rjmp	.+0      	; 0x144c <lcd_init+0x88>
    144c:	00 00       	nop
	
  // lcd_wait(WAIT_15m);                // 1.53 mS  
     _delay_ms(2);                  
                               

   lcd_cmd_write(SET_ENTRY_MODE+INC_BIT);          //  +INC_BIT  // Entry mode set: shift cursor 1 position to right
    144e:	86 e0       	ldi	r24, 0x06	; 6
    1450:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1454:	87 e8       	ldi	r24, 0x87	; 135
    1456:	93 e1       	ldi	r25, 0x13	; 19
    1458:	01 97       	sbiw	r24, 0x01	; 1
    145a:	f1 f7       	brne	.-4      	; 0x1458 <lcd_init+0x94>
    145c:	00 c0       	rjmp	.+0      	; 0x145e <lcd_init+0x9a>
    145e:	00 00       	nop
  //   lcd_wait(WAIT_15m);      
  _delay_ms(2);
    lcd_cmd_write(SET_DISPLAY+ON_BIT+CUR_BIT+BLK_BIT); //+CUR_BIT+BLK_BIT);   Display ON/OFF control: 0x0f
    1460:	8c e0       	ldi	r24, 0x0C	; 12
    1462:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1466:	87 e8       	ldi	r24, 0x87	; 135
    1468:	93 e1       	ldi	r25, 0x13	; 19
    146a:	01 97       	sbiw	r24, 0x01	; 1
    146c:	f1 f7       	brne	.-4      	; 0x146a <lcd_init+0xa6>
    146e:	00 c0       	rjmp	.+0      	; 0x1470 <lcd_init+0xac>
    1470:	00 00       	nop
  //   lcd_wait(WAIT_15m);                               // Wait 39 uS                      // 1.53 mS     

  //lcd_wait(WAIT_15m);                            // 1.53 mS  
_delay_ms(2);
  createCustomFont();
    1472:	0e 94 45 09 	call	0x128a	; 0x128a <createCustomFont>
    1476:	87 e8       	ldi	r24, 0x87	; 135
    1478:	93 e1       	ldi	r25, 0x13	; 19
    147a:	01 97       	sbiw	r24, 0x01	; 1
    147c:	f1 f7       	brne	.-4      	; 0x147a <lcd_init+0xb6>
    147e:	00 c0       	rjmp	.+0      	; 0x1480 <lcd_init+0xbc>
    1480:	00 00       	nop
 _delay_ms(2);
 lcd_cmd_write(RTN_HOME);
    1482:	82 e0       	ldi	r24, 0x02	; 2
    1484:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1488:	08 95       	ret

0000148a <lcdClear>:
	_delay_us(60);
   } 

//clear the display
void lcdClear(void) {
	lcd_cmd_write(CLR_DISPLAY);
    148a:	81 e0       	ldi	r24, 0x01	; 1
    148c:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
	lcd_wait(WAIT_15m);
	lcd_cmd_write(CLR_DISPLAY+RTN_HOME);
    1490:	83 e0       	ldi	r24, 0x03	; 3
    1492:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1496:	08 95       	ret

00001498 <LCDPutString>:
 
}


//! write a zero-terminated ASCII string to the display
void LCDPutString(char *str) {
    1498:	0f 93       	push	r16
    149a:	1f 93       	push	r17
    149c:	cf 93       	push	r28
    149e:	df 93       	push	r29
    14a0:	ec 01       	movw	r28, r24
   char c,index=0;
	for (; (c = *str) != 0; str++){
    14a2:	88 81       	ld	r24, Y
    14a4:	88 23       	and	r24, r24
    14a6:	99 f0       	breq	.+38     	; 0x14ce <LCDPutString+0x36>
 
}


//! write a zero-terminated ASCII string to the display
void LCDPutString(char *str) {
    14a8:	21 96       	adiw	r28, 0x01	; 1
   char c,index=0;
    14aa:	10 e0       	ldi	r17, 0x00	; 0
		index++;

		if (index>=20) {
			lcd_cmd_write(SET_DRAM_ADDR+line_3);
			lcd_wait(WAIT_15m);
			index=0;
    14ac:	00 e0       	ldi	r16, 0x00	; 0
//! write a zero-terminated ASCII string to the display
void LCDPutString(char *str) {
   char c,index=0;
	for (; (c = *str) != 0; str++){
	
		if((c=='\r') || c=='\n');
    14ae:	8d 30       	cpi	r24, 0x0D	; 13
    14b0:	21 f0       	breq	.+8      	; 0x14ba <LCDPutString+0x22>
    14b2:	8a 30       	cpi	r24, 0x0A	; 10
    14b4:	11 f0       	breq	.+4      	; 0x14ba <LCDPutString+0x22>
		else
		lcd_data_write(c);
    14b6:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>

		index++;
    14ba:	1f 5f       	subi	r17, 0xFF	; 255

		if (index>=20) {
    14bc:	14 31       	cpi	r17, 0x14	; 20
    14be:	20 f0       	brcs	.+8      	; 0x14c8 <LCDPutString+0x30>
			lcd_cmd_write(SET_DRAM_ADDR+line_3);
    14c0:	84 ed       	ldi	r24, 0xD4	; 212
    14c2:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
			lcd_wait(WAIT_15m);
			index=0;
    14c6:	10 2f       	mov	r17, r16


//! write a zero-terminated ASCII string to the display
void LCDPutString(char *str) {
   char c,index=0;
	for (; (c = *str) != 0; str++){
    14c8:	89 91       	ld	r24, Y+
    14ca:	81 11       	cpse	r24, r1
    14cc:	f0 cf       	rjmp	.-32     	; 0x14ae <LCDPutString+0x16>
			lcd_wait(WAIT_15m);
			index=0;
		}

	}
}
    14ce:	df 91       	pop	r29
    14d0:	cf 91       	pop	r28
    14d2:	1f 91       	pop	r17
    14d4:	0f 91       	pop	r16
    14d6:	08 95       	ret

000014d8 <GoTo>:

//*goto x-position and y-line called by parameters x, y used in main() and internally LCDPutChar()*/

void GoTo(unsigned char x, unsigned char y){
	switch (y) {
    14d8:	61 30       	cpi	r22, 0x01	; 1
    14da:	51 f0       	breq	.+20     	; 0x14f0 <GoTo+0x18>
    14dc:	28 f0       	brcs	.+10     	; 0x14e8 <GoTo+0x10>
    14de:	62 30       	cpi	r22, 0x02	; 2
    14e0:	59 f0       	breq	.+22     	; 0x14f8 <GoTo+0x20>
    14e2:	63 30       	cpi	r22, 0x03	; 3
    14e4:	81 f4       	brne	.+32     	; 0x1506 <GoTo+0x2e>
    14e6:	0c c0       	rjmp	.+24     	; 0x1500 <GoTo+0x28>
		case 0: 

		lcd_cmd_write(SET_DRAM_ADDR+x);
    14e8:	80 58       	subi	r24, 0x80	; 128
    14ea:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
		lcd_wait(WAIT_15m);  
		break;
    14ee:	08 95       	ret

		case 1: 

		lcd_cmd_write(SET_DRAM_ADDR+line_1+x);
    14f0:	80 54       	subi	r24, 0x40	; 64
    14f2:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
		lcd_wait(WAIT_15m);  
		break;
    14f6:	08 95       	ret

		case 2:
		lcd_cmd_write(SET_DRAM_ADDR+line_2+x);
    14f8:	8c 56       	subi	r24, 0x6C	; 108
    14fa:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
		lcd_wait(WAIT_15m);  
		break;
    14fe:	08 95       	ret

		case 3:
		lcd_cmd_write(SET_DRAM_ADDR+line_3+x);
    1500:	8c 52       	subi	r24, 0x2C	; 44
    1502:	0e 94 3c 09 	call	0x1278	; 0x1278 <lcd_cmd_write>
    1506:	08 95       	ret

00001508 <endSessionm>:
function. In both cases the last action is to restart
controller in order to have a clean start with all the
registers cleared. For that, watchdog timer is set to 15ms.
-----------------------------------------------------*/ 
void endSessionm(void){ 
    lcdClear(); 
    1508:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    150c:	87 ea       	ldi	r24, 0xA7	; 167
    150e:	91 e6       	ldi	r25, 0x61	; 97
    1510:	01 97       	sbiw	r24, 0x01	; 1
    1512:	f1 f7       	brne	.-4      	; 0x1510 <endSessionm+0x8>
    1514:	00 c0       	rjmp	.+0      	; 0x1516 <endSessionm+0xe>
    1516:	00 00       	nop
    _delay_ms(10); 
      
    if (offline_mode && charged) 
    1518:	80 91 83 05 	lds	r24, 0x0583
    151c:	88 23       	and	r24, r24
    151e:	09 f4       	brne	.+2      	; 0x1522 <endSessionm+0x1a>
    1520:	7a c0       	rjmp	.+244    	; 0x1616 <endSessionm+0x10e>
    1522:	80 91 88 05 	lds	r24, 0x0588
    1526:	88 23       	and	r24, r24
    1528:	09 f4       	brne	.+2      	; 0x152c <endSessionm+0x24>
    152a:	75 c0       	rjmp	.+234    	; 0x1616 <endSessionm+0x10e>
    { 
            GoTo(0,0); 
    152c:	60 e0       	ldi	r22, 0x00	; 0
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
            LCDPutString("You've been debited"); 
    1534:	8d ec       	ldi	r24, 0xCD	; 205
    1536:	93 e0       	ldi	r25, 0x03	; 3
    1538:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
//          GoTo(0,1); 
//          LCDPutString("for 1500dkk"); 
            GoTo(0,2); 
    153c:	62 e0       	ldi	r22, 0x02	; 2
    153e:	80 e0       	ldi	r24, 0x00	; 0
    1540:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
            LCDPutString("Please use RFID card"); 
    1544:	81 ee       	ldi	r24, 0xE1	; 225
    1546:	93 e0       	ldi	r25, 0x03	; 3
    1548:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
            GoTo(0,3); 
    154c:	63 e0       	ldi	r22, 0x03	; 3
    154e:	80 e0       	ldi	r24, 0x00	; 0
    1550:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
            LCDPutString("to recalculate"); 
    1554:	86 ef       	ldi	r24, 0xF6	; 246
    1556:	93 e0       	ldi	r25, 0x03	; 3
    1558:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
            rfidDone = false; 
    155c:	10 92 8e 05 	sts	0x058E, r1
            offlineWrite = true; 
    1560:	81 e0       	ldi	r24, 0x01	; 1
    1562:	80 93 93 05 	sts	0x0593, r24
        //  int exl = strlen(expenseToPayChar); 
            //int enl = strlen(energyStr); 
              
              
            //make a 16byte memory card block format data + 0000 
            memset(pastEnChar, 0, 16); 
    1566:	80 e1       	ldi	r24, 0x10	; 16
    1568:	eb ef       	ldi	r30, 0xFB	; 251
    156a:	f7 e0       	ldi	r31, 0x07	; 7
    156c:	df 01       	movw	r26, r30
    156e:	28 2f       	mov	r18, r24
    1570:	1d 92       	st	X+, r1
    1572:	2a 95       	dec	r18
    1574:	e9 f7       	brne	.-6      	; 0x1570 <endSessionm+0x68>
            memset(debtChar, 0, 16); 
    1576:	e0 e7       	ldi	r30, 0x70	; 112
    1578:	f7 e0       	ldi	r31, 0x07	; 7
    157a:	df 01       	movw	r26, r30
    157c:	28 2f       	mov	r18, r24
    157e:	1d 92       	st	X+, r1
    1580:	2a 95       	dec	r18
    1582:	e9 f7       	brne	.-6      	; 0x157e <endSessionm+0x76>
            memset(pastExChar, 0, 16); 
    1584:	e6 e8       	ldi	r30, 0x86	; 134
    1586:	f7 e0       	ldi	r31, 0x07	; 7
    1588:	df 01       	movw	r26, r30
    158a:	1d 92       	st	X+, r1
    158c:	8a 95       	dec	r24
    158e:	e9 f7       	brne	.-6      	; 0x158a <endSessionm+0x82>
              
            memcpy(pastEnChar, energyStr, 8); 
    1590:	88 e0       	ldi	r24, 0x08	; 8
    1592:	e9 ee       	ldi	r30, 0xE9	; 233
    1594:	f6 e0       	ldi	r31, 0x06	; 6
    1596:	ab ef       	ldi	r26, 0xFB	; 251
    1598:	b7 e0       	ldi	r27, 0x07	; 7
    159a:	01 90       	ld	r0, Z+
    159c:	0d 92       	st	X+, r0
    159e:	8a 95       	dec	r24
    15a0:	e1 f7       	brne	.-8      	; 0x159a <endSessionm+0x92>
            memcpy(pastExChar, expenseToPayChar, 8); 
    15a2:	88 e0       	ldi	r24, 0x08	; 8
    15a4:	e4 ef       	ldi	r30, 0xF4	; 244
    15a6:	f6 e0       	ldi	r31, 0x06	; 6
    15a8:	a6 e8       	ldi	r26, 0x86	; 134
    15aa:	b7 e0       	ldi	r27, 0x07	; 7
    15ac:	01 90       	ld	r0, Z+
    15ae:	0d 92       	st	X+, r0
    15b0:	8a 95       	dec	r24
    15b2:	e1 f7       	brne	.-8      	; 0x15ac <endSessionm+0xa4>
            memcpy(debtChar, expenseToPayChar, 8); 
    15b4:	88 e0       	ldi	r24, 0x08	; 8
    15b6:	e4 ef       	ldi	r30, 0xF4	; 244
    15b8:	f6 e0       	ldi	r31, 0x06	; 6
    15ba:	a0 e7       	ldi	r26, 0x70	; 112
    15bc:	b7 e0       	ldi	r27, 0x07	; 7
    15be:	01 90       	ld	r0, Z+
    15c0:	0d 92       	st	X+, r0
    15c2:	8a 95       	dec	r24
    15c4:	e1 f7       	brne	.-8      	; 0x15be <endSessionm+0xb6>
              
              
            while (!RFIDinit(5, "write", 5)); 
    15c6:	45 e0       	ldi	r20, 0x05	; 5
    15c8:	50 e0       	ldi	r21, 0x00	; 0
    15ca:	65 e0       	ldi	r22, 0x05	; 5
    15cc:	74 e0       	ldi	r23, 0x04	; 4
    15ce:	85 e0       	ldi	r24, 0x05	; 5
    15d0:	90 e0       	ldi	r25, 0x00	; 0
    15d2:	0e 94 2c 11 	call	0x2258	; 0x2258 <RFIDinit>
    15d6:	88 23       	and	r24, r24
    15d8:	b1 f3       	breq	.-20     	; 0x15c6 <endSessionm+0xbe>
            offlineWrite = false; 
    15da:	10 92 93 05 	sts	0x0593, r1
            restart = true; 
    15de:	81 e0       	ldi	r24, 0x01	; 1
    15e0:	80 93 89 05 	sts	0x0589, r24
            lcdClear(); 
    15e4:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
            LCDPutString("Logged out"); 
    15e8:	8b e0       	ldi	r24, 0x0B	; 11
    15ea:	94 e0       	ldi	r25, 0x04	; 4
    15ec:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    15f0:	bf e3       	ldi	r27, 0x3F	; 63
    15f2:	2d e0       	ldi	r18, 0x0D	; 13
    15f4:	83 e0       	ldi	r24, 0x03	; 3
    15f6:	b1 50       	subi	r27, 0x01	; 1
    15f8:	20 40       	sbci	r18, 0x00	; 0
    15fa:	80 40       	sbci	r24, 0x00	; 0
    15fc:	e1 f7       	brne	.-8      	; 0x15f6 <endSessionm+0xee>
    15fe:	00 c0       	rjmp	.+0      	; 0x1600 <endSessionm+0xf8>
    1600:	00 00       	nop
            _delay_ms(100); 
            wdt_enable(WDTO_15MS); 
    1602:	28 e0       	ldi	r18, 0x08	; 8
    1604:	88 e1       	ldi	r24, 0x18	; 24
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	0f b6       	in	r0, 0x3f	; 63
    160a:	f8 94       	cli
    160c:	a8 95       	wdr
    160e:	81 bd       	out	0x21, r24	; 33
    1610:	0f be       	out	0x3f, r0	; 63
    1612:	21 bd       	out	0x21, r18	; 33
    1614:	ff cf       	rjmp	.-2      	; 0x1614 <endSessionm+0x10c>
            while(true){ 
              
            } 
          
    }else{ 
            formPacket("02", "01","99", "EndofSession"); 
    1616:	2b e0       	ldi	r18, 0x0B	; 11
    1618:	33 e0       	ldi	r19, 0x03	; 3
    161a:	48 e1       	ldi	r20, 0x18	; 24
    161c:	53 e0       	ldi	r21, 0x03	; 3
    161e:	6c eb       	ldi	r22, 0xBC	; 188
    1620:	72 e0       	ldi	r23, 0x02	; 2
    1622:	8f eb       	ldi	r24, 0xBF	; 191
    1624:	92 e0       	ldi	r25, 0x02	; 2
    1626:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
            sendStringUSART(formedDataPackageToSend);  
    162a:	8a e1       	ldi	r24, 0x1A	; 26
    162c:	95 e0       	ldi	r25, 0x05	; 5
    162e:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
        GoTo(0,1); 
        LCDPutString("Log out with RFID"); 
        while (!RFIDinit(4, "write", 5)); 
    }*/
      
    charged = false; 
    1632:	10 92 88 05 	sts	0x0588, r1
    default_menu = true; 
    1636:	81 e0       	ldi	r24, 0x01	; 1
    1638:	80 93 8e 01 	sts	0x018E, r24
    stMenuItem = 1; 
    163c:	81 e0       	ldi	r24, 0x01	; 1
    163e:	90 e0       	ldi	r25, 0x00	; 0
    1640:	90 93 92 01 	sts	0x0192, r25
    1644:	80 93 91 01 	sts	0x0191, r24
    menu_position = 1; 
    1648:	90 93 94 01 	sts	0x0194, r25
    164c:	80 93 93 01 	sts	0x0193, r24
    1650:	9f e3       	ldi	r25, 0x3F	; 63
    1652:	ad e0       	ldi	r26, 0x0D	; 13
    1654:	b3 e0       	ldi	r27, 0x03	; 3
    1656:	91 50       	subi	r25, 0x01	; 1
    1658:	a0 40       	sbci	r26, 0x00	; 0
    165a:	b0 40       	sbci	r27, 0x00	; 0
    165c:	e1 f7       	brne	.-8      	; 0x1656 <endSessionm+0x14e>
    165e:	00 c0       	rjmp	.+0      	; 0x1660 <endSessionm+0x158>
    1660:	00 00       	nop
    1662:	2f e3       	ldi	r18, 0x3F	; 63
    1664:	8d e0       	ldi	r24, 0x0D	; 13
    1666:	93 e0       	ldi	r25, 0x03	; 3
    1668:	21 50       	subi	r18, 0x01	; 1
    166a:	80 40       	sbci	r24, 0x00	; 0
    166c:	90 40       	sbci	r25, 0x00	; 0
    166e:	e1 f7       	brne	.-8      	; 0x1668 <endSessionm+0x160>
    1670:	00 c0       	rjmp	.+0      	; 0x1672 <endSessionm+0x16a>
    1672:	00 00       	nop
    _delay_ms(100); 
    _delay_ms(100); 
    wdt_enable(WDTO_15MS); 
    1674:	28 e0       	ldi	r18, 0x08	; 8
    1676:	88 e1       	ldi	r24, 0x18	; 24
    1678:	90 e0       	ldi	r25, 0x00	; 0
    167a:	0f b6       	in	r0, 0x3f	; 63
    167c:	f8 94       	cli
    167e:	a8 95       	wdr
    1680:	81 bd       	out	0x21, r24	; 33
    1682:	0f be       	out	0x3f, r0	; 63
    1684:	21 bd       	out	0x21, r18	; 33
    1686:	ff cf       	rjmp	.-2      	; 0x1686 <endSessionm+0x17e>

00001688 <stateEval_menu>:
Function that finds next state and corresponding action
according to the event passed as a parameter and current
state variable.
-----------------------------------------------------*/  
void stateEval_menu(event_menu w) { 
    stateElement_menu stateEvaluation = stateMatrix_menu[currentState_m][w];    //suranda sekancia state pagal esama state ir ivyki 
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	dc 01       	movw	r26, r24
    168c:	aa 0f       	add	r26, r26
    168e:	bb 1f       	adc	r27, r27
    1690:	8a 0f       	add	r24, r26
    1692:	9b 1f       	adc	r25, r27
    1694:	20 91 32 01 	lds	r18, 0x0132
    1698:	30 e0       	ldi	r19, 0x00	; 0
    169a:	22 0f       	add	r18, r18
    169c:	33 1f       	adc	r19, r19
    169e:	d9 01       	movw	r26, r18
    16a0:	aa 0f       	add	r26, r26
    16a2:	bb 1f       	adc	r27, r27
    16a4:	aa 0f       	add	r26, r26
    16a6:	bb 1f       	adc	r27, r27
    16a8:	aa 0f       	add	r26, r26
    16aa:	bb 1f       	adc	r27, r27
    16ac:	2a 0f       	add	r18, r26
    16ae:	3b 1f       	adc	r19, r27
    16b0:	dc 01       	movw	r26, r24
    16b2:	a2 0f       	add	r26, r18
    16b4:	b3 1f       	adc	r27, r19
    16b6:	ad 5c       	subi	r26, 0xCD	; 205
    16b8:	be 4f       	sbci	r27, 0xFE	; 254
    16ba:	11 96       	adiw	r26, 0x01	; 1
    16bc:	ed 91       	ld	r30, X+
    16be:	fc 91       	ld	r31, X
    16c0:	12 97       	sbiw	r26, 0x02	; 2
    currentState_m = stateEvaluation.nextState;                     //sauna action'a busimos 
    16c2:	8c 91       	ld	r24, X
    16c4:	80 93 32 01 	sts	0x0132, r24
    (*stateEvaluation.actionToDo)(); 
    16c8:	09 95       	icall
    16ca:	08 95       	ret

000016cc <waitUntilKeyPressed>:
bool waitUntilKeyPressed(char mkey)
Function that initiates keypad, waits for any key to be
pressed, checks if it is equal to the parameter passed.
If it is same, returns true, else - false.
-----------------------------------------------------*/  
bool waitUntilKeyPressed(char mkey){ 
    16cc:	cf 93       	push	r28
    16ce:	c8 2f       	mov	r28, r24
    char keyPressedm; 
    while (scanKeyPad()!=1); 
    16d0:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
    16d4:	81 30       	cpi	r24, 0x01	; 1
    16d6:	e1 f7       	brne	.-8      	; 0x16d0 <waitUntilKeyPressed+0x4>
    keyPressedm = returnKey(); 
    16d8:	0e 94 0c 09 	call	0x1218	; 0x1218 <returnKey>
      
    if (keyPressedm == mkey) 
    16dc:	91 e0       	ldi	r25, 0x01	; 1
    16de:	8c 13       	cpse	r24, r28
    16e0:	90 e0       	ldi	r25, 0x00	; 0
    else
    { 
        return false; 
    } 
    return false; 
}
    16e2:	89 2f       	mov	r24, r25
    16e4:	cf 91       	pop	r28
    16e6:	08 95       	ret

000016e8 <stateTransition_m>:
handy at testing stages and as generated event is stored, 
let's stimulate state and action change from anywhere from
this module.
 -----------------------------------------------------*/
void stateTransition_m(event_menu curr){ 
    EventOccured_menu = curr; 
    16e8:	80 93 87 05 	sts	0x0587, r24
    stateEval_menu((event_menu)curr); 
    16ec:	0e 94 44 0b 	call	0x1688	; 0x1688 <stateEval_menu>
    16f0:	08 95       	ret

000016f2 <retrieve_price>:
OFFLINE_PRICE variable. Else, sends data packet with request
to retrieve online price form server. Latter stored in 
price_str variable and used in menu template as well as
to calculate totals.
 -----------------------------------------------------*/  
void retrieve_price(void){ 
    16f2:	cf 93       	push	r28
    16f4:	df 93       	push	r29
    if (offline_mode) 
    16f6:	80 91 83 05 	lds	r24, 0x0583
    16fa:	88 23       	and	r24, r24
    16fc:	91 f0       	breq	.+36     	; 0x1722 <retrieve_price+0x30>
    { 
        price = OFFLINE_PRICE; 
    16fe:	80 91 1f 01 	lds	r24, 0x011F
    1702:	90 91 20 01 	lds	r25, 0x0120
    1706:	90 93 fd 06 	sts	0x06FD, r25
    170a:	80 93 fc 06 	sts	0x06FC, r24
        itoa(price, price_str, 10); 
    170e:	4a e0       	ldi	r20, 0x0A	; 10
    1710:	50 e0       	ldi	r21, 0x00	; 0
    1712:	61 ef       	ldi	r22, 0xF1	; 241
    1714:	76 e0       	ldi	r23, 0x06	; 6
    1716:	0e 94 0f 1b 	call	0x361e	; 0x361e <itoa>
        //snprintf(price_str,2, "%i \r\n", price); 
        stateTransition_m(b2); 
    171a:	82 e0       	ldi	r24, 0x02	; 2
    171c:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
    1720:	35 c0       	rjmp	.+106    	; 0x178c <retrieve_price+0x9a>
    } 
    else{ 
    formPacket("02","01","50", "SendCurrentPrice"); 
    1722:	26 e1       	ldi	r18, 0x16	; 22
    1724:	34 e0       	ldi	r19, 0x04	; 4
    1726:	47 e2       	ldi	r20, 0x27	; 39
    1728:	54 e0       	ldi	r21, 0x04	; 4
    172a:	6c eb       	ldi	r22, 0xBC	; 188
    172c:	72 e0       	ldi	r23, 0x02	; 2
    172e:	8f eb       	ldi	r24, 0xBF	; 191
    1730:	92 e0       	ldi	r25, 0x02	; 2
    1732:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
    sendStringUSART(formedDataPackageToSend); 
    1736:	8a e1       	ldi	r24, 0x1A	; 26
    1738:	95 e0       	ldi	r25, 0x05	; 5
    173a:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    while(!packageReceived()); 
    173e:	0e 94 c1 03 	call	0x782	; 0x782 <packageReceived>
    1742:	88 23       	and	r24, r24
    1744:	e1 f3       	breq	.-8      	; 0x173e <retrieve_price+0x4c>
    if ( _command == 51   ) 
    1746:	80 91 1c 06 	lds	r24, 0x061C
    174a:	90 91 1d 06 	lds	r25, 0x061D
    174e:	c3 97       	sbiw	r24, 0x33	; 51
    1750:	e9 f4       	brne	.+58     	; 0x178c <retrieve_price+0x9a>
    { 
        price = atoi(actualData); //retrieve price, conv string to int and assign to the field 
    1752:	82 e2       	ldi	r24, 0x22	; 34
    1754:	96 e0       	ldi	r25, 0x06	; 6
    1756:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <atoi>
    175a:	90 93 fd 06 	sts	0x06FD, r25
    175e:	80 93 fc 06 	sts	0x06FC, r24
        memset(price_str, '\0', dl);  
    1762:	c1 ef       	ldi	r28, 0xF1	; 241
    1764:	d6 e0       	ldi	r29, 0x06	; 6
    1766:	40 91 86 06 	lds	r20, 0x0686
    176a:	50 91 87 06 	lds	r21, 0x0687
    176e:	60 e0       	ldi	r22, 0x00	; 0
    1770:	70 e0       	ldi	r23, 0x00	; 0
    1772:	8c 2f       	mov	r24, r28
    1774:	9d 2f       	mov	r25, r29
    1776:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <memset>
        memcpy(price_str, actualData, 2);//init known size string with price value as char 
    177a:	80 91 22 06 	lds	r24, 0x0622
    177e:	90 91 23 06 	lds	r25, 0x0623
    1782:	99 83       	std	Y+1, r25	; 0x01
    1784:	88 83       	st	Y, r24
        stateTransition_m(b2); 
    1786:	82 e0       	ldi	r24, 0x02	; 2
    1788:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
    } 
      
    } 
} 
    178c:	df 91       	pop	r29
    178e:	cf 91       	pop	r28
    1790:	08 95       	ret

00001792 <arrow_mov>:
and wait for user interaction with keyboard. Returns true
if menu option is chosen and generates appropriate event
so that corresponding action could be fired.
-----------------------------------------------------*/  
bool arrow_mov(void) 
{ 
    1792:	cf 93       	push	r28
    int old_menu_position; 
      
    if(default_menu){ 
    1794:	80 91 8e 01 	lds	r24, 0x018E
    1798:	88 23       	and	r24, r24
    179a:	81 f0       	breq	.+32     	; 0x17bc <arrow_mov+0x2a>
        default_menu = false; 
    179c:	10 92 8e 01 	sts	0x018E, r1
        GoTo(0,1); 
    17a0:	61 e0       	ldi	r22, 0x01	; 1
    17a2:	80 e0       	ldi	r24, 0x00	; 0
    17a4:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        lcd_data_write(arrow); 
    17a8:	80 91 8d 01 	lds	r24, 0x018D
    17ac:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
        menu_position = 1; 
    17b0:	81 e0       	ldi	r24, 0x01	; 1
    17b2:	90 e0       	ldi	r25, 0x00	; 0
    17b4:	90 93 94 01 	sts	0x0194, r25
    17b8:	80 93 93 01 	sts	0x0193, r24
    } 
    if(charged){ 
    17bc:	80 91 88 05 	lds	r24, 0x0588
    17c0:	88 23       	and	r24, r24
    17c2:	41 f0       	breq	.+16     	; 0x17d4 <arrow_mov+0x42>
        GoTo(0,1); 
    17c4:	61 e0       	ldi	r22, 0x01	; 1
    17c6:	80 e0       	ldi	r24, 0x00	; 0
    17c8:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        lcd_data_write(doneChar); 
    17cc:	80 91 8a 05 	lds	r24, 0x058A
    17d0:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    } 
    if (defChargMenu){ 
    17d4:	80 91 8b 05 	lds	r24, 0x058B
    17d8:	88 23       	and	r24, r24
    17da:	51 f0       	breq	.+20     	; 0x17f0 <arrow_mov+0x5e>
        defChargMenu = false; 
    17dc:	10 92 8b 05 	sts	0x058B, r1
        GoTo(0,2); 
    17e0:	62 e0       	ldi	r22, 0x02	; 2
    17e2:	80 e0       	ldi	r24, 0x00	; 0
    17e4:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        lcd_data_write(arrow); 
    17e8:	80 91 8d 01 	lds	r24, 0x018D
    17ec:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    } 
    old_menu_position = menu_position; 
    17f0:	c0 91 93 01 	lds	r28, 0x0193
  
    while(scanKeyPad()!=1); 
    17f4:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
    17f8:	81 30       	cpi	r24, 0x01	; 1
    17fa:	e1 f7       	brne	.-8      	; 0x17f4 <arrow_mov+0x62>
    char key = returnKey(); 
    17fc:	0e 94 0c 09 	call	0x1218	; 0x1218 <returnKey>
      
    switch(key){ 
    1800:	82 34       	cpi	r24, 0x42	; 66
    1802:	09 f4       	brne	.+2      	; 0x1806 <arrow_mov+0x74>
    1804:	59 c0       	rjmp	.+178    	; 0x18b8 <arrow_mov+0x126>
    1806:	20 f4       	brcc	.+8      	; 0x1810 <arrow_mov+0x7e>
    1808:	81 34       	cpi	r24, 0x41	; 65
    180a:	09 f0       	breq	.+2      	; 0x180e <arrow_mov+0x7c>
    180c:	5a c0       	rjmp	.+180    	; 0x18c2 <arrow_mov+0x130>
    180e:	39 c0       	rjmp	.+114    	; 0x1882 <arrow_mov+0xf0>
    1810:	83 34       	cpi	r24, 0x43	; 67
    1812:	e9 f0       	breq	.+58     	; 0x184e <arrow_mov+0xbc>
    1814:	86 34       	cpi	r24, 0x46	; 70
    1816:	09 f0       	breq	.+2      	; 0x181a <arrow_mov+0x88>
    1818:	54 c0       	rjmp	.+168    	; 0x18c2 <arrow_mov+0x130>
        case 'F'  : 
          
            if (menu_position == stMenuItem){ 
    181a:	80 91 93 01 	lds	r24, 0x0193
    181e:	90 91 94 01 	lds	r25, 0x0194
    1822:	20 91 91 01 	lds	r18, 0x0191
    1826:	30 91 92 01 	lds	r19, 0x0192
    182a:	82 17       	cp	r24, r18
    182c:	93 07       	cpc	r25, r19
    182e:	49 f4       	brne	.+18     	; 0x1842 <arrow_mov+0xb0>
                menu_position = lastMenuItem; 
    1830:	80 91 8f 01 	lds	r24, 0x018F
    1834:	90 91 90 01 	lds	r25, 0x0190
    1838:	90 93 94 01 	sts	0x0194, r25
    183c:	80 93 93 01 	sts	0x0193, r24
    1840:	46 c0       	rjmp	.+140    	; 0x18ce <arrow_mov+0x13c>
            }else{ 
                menu_position--; 
    1842:	01 97       	sbiw	r24, 0x01	; 1
    1844:	90 93 94 01 	sts	0x0194, r25
    1848:	80 93 93 01 	sts	0x0193, r24
    184c:	40 c0       	rjmp	.+128    	; 0x18ce <arrow_mov+0x13c>
          
            break; 
          
        case 'C'  : 
          
            if (menu_position == lastMenuItem){ 
    184e:	80 91 93 01 	lds	r24, 0x0193
    1852:	90 91 94 01 	lds	r25, 0x0194
    1856:	20 91 8f 01 	lds	r18, 0x018F
    185a:	30 91 90 01 	lds	r19, 0x0190
    185e:	82 17       	cp	r24, r18
    1860:	93 07       	cpc	r25, r19
    1862:	49 f4       	brne	.+18     	; 0x1876 <arrow_mov+0xe4>
                menu_position = stMenuItem; 
    1864:	80 91 91 01 	lds	r24, 0x0191
    1868:	90 91 92 01 	lds	r25, 0x0192
    186c:	90 93 94 01 	sts	0x0194, r25
    1870:	80 93 93 01 	sts	0x0193, r24
    1874:	2c c0       	rjmp	.+88     	; 0x18ce <arrow_mov+0x13c>
            }else{ 
                menu_position++; 
    1876:	01 96       	adiw	r24, 0x01	; 1
    1878:	90 93 94 01 	sts	0x0194, r25
    187c:	80 93 93 01 	sts	0x0193, r24
    1880:	26 c0       	rjmp	.+76     	; 0x18ce <arrow_mov+0x13c>
            } 
            break;  
        case 'A'  : 
            if (menu_position == 1) 
    1882:	80 91 93 01 	lds	r24, 0x0193
    1886:	90 91 94 01 	lds	r25, 0x0194
    188a:	81 30       	cpi	r24, 0x01	; 1
    188c:	91 05       	cpc	r25, r1
    188e:	29 f4       	brne	.+10     	; 0x189a <arrow_mov+0x108>
            { 
                stateTransition_m(c3); 
    1890:	83 e0       	ldi	r24, 0x03	; 3
    1892:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
                return true; 
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	2b c0       	rjmp	.+86     	; 0x18f0 <arrow_mov+0x15e>
            }  
            else if (menu_position == 2) 
    189a:	82 30       	cpi	r24, 0x02	; 2
    189c:	91 05       	cpc	r25, r1
    189e:	29 f4       	brne	.+10     	; 0x18aa <arrow_mov+0x118>
            { 
                stateTransition_m(d4); 
    18a0:	84 e0       	ldi	r24, 0x04	; 4
    18a2:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
                return true; 
    18a6:	81 e0       	ldi	r24, 0x01	; 1
    18a8:	23 c0       	rjmp	.+70     	; 0x18f0 <arrow_mov+0x15e>
            } 
            else if (menu_position == 3) 
    18aa:	03 97       	sbiw	r24, 0x03	; 3
    18ac:	81 f4       	brne	.+32     	; 0x18ce <arrow_mov+0x13c>
            { 
                stateTransition_m(e5); 
    18ae:	85 e0       	ldi	r24, 0x05	; 5
    18b0:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
                return true; 
    18b4:	81 e0       	ldi	r24, 0x01	; 1
    18b6:	1c c0       	rjmp	.+56     	; 0x18f0 <arrow_mov+0x15e>
            } 
            break; 
        case 'B'    : 
            stateTransition_m(zeroevent); 
    18b8:	80 e0       	ldi	r24, 0x00	; 0
    18ba:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
            return true; 
    18be:	81 e0       	ldi	r24, 0x01	; 1
    18c0:	17 c0       	rjmp	.+46     	; 0x18f0 <arrow_mov+0x15e>
              
        default :  
            menu_position = 1; 
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	90 e0       	ldi	r25, 0x00	; 0
    18c6:	90 93 94 01 	sts	0x0194, r25
    18ca:	80 93 93 01 	sts	0x0193, r24
    } 
    GoTo(0,old_menu_position); 
    18ce:	6c 2f       	mov	r22, r28
    18d0:	80 e0       	ldi	r24, 0x00	; 0
    18d2:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    lcd_data_write(' '); 
    18d6:	80 e2       	ldi	r24, 0x20	; 32
    18d8:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    GoTo(0,menu_position); 
    18dc:	60 91 93 01 	lds	r22, 0x0193
    18e0:	80 e0       	ldi	r24, 0x00	; 0
    18e2:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    lcd_data_write(arrow); 
    18e6:	80 91 8d 01 	lds	r24, 0x018D
    18ea:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    return false; 
    18ee:	80 e0       	ldi	r24, 0x00	; 0
} 
    18f0:	cf 91       	pop	r28
    18f2:	08 95       	ret

000018f4 <draw_menu>:
menu for user. In case it is offline, instead of balance
check option, there is deposit check option where the 
value is taken from RFID.
 -----------------------------------------------------*/    
void draw_menu(void){ 
    lcdClear(); 
    18f4:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    18f8:	87 ea       	ldi	r24, 0xA7	; 167
    18fa:	91 e6       	ldi	r25, 0x61	; 97
    18fc:	01 97       	sbiw	r24, 0x01	; 1
    18fe:	f1 f7       	brne	.-4      	; 0x18fc <draw_menu+0x8>
    1900:	00 c0       	rjmp	.+0      	; 0x1902 <draw_menu+0xe>
    1902:	00 00       	nop
    _delay_ms(10); 
    //Header 
    GoTo(5,0); 
    1904:	60 e0       	ldi	r22, 0x00	; 0
    1906:	85 e0       	ldi	r24, 0x05	; 5
    1908:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Price "); 
    190c:	8a e2       	ldi	r24, 0x2A	; 42
    190e:	94 e0       	ldi	r25, 0x04	; 4
    1910:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(11,0); 
    1914:	60 e0       	ldi	r22, 0x00	; 0
    1916:	8b e0       	ldi	r24, 0x0B	; 11
    1918:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString(price_str); 
    191c:	81 ef       	ldi	r24, 0xF1	; 241
    191e:	96 e0       	ldi	r25, 0x06	; 6
    1920:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(13,0); 
    1924:	60 e0       	ldi	r22, 0x00	; 0
    1926:	8d e0       	ldi	r24, 0x0D	; 13
    1928:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("dkk/kWs"); 
    192c:	8d ea       	ldi	r24, 0xAD	; 173
    192e:	93 e0       	ldi	r25, 0x03	; 3
    1930:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
      
    //Second line 
    GoTo(1,1); 
    1934:	61 e0       	ldi	r22, 0x01	; 1
    1936:	81 e0       	ldi	r24, 0x01	; 1
    1938:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Charge"); 
    193c:	81 ef       	ldi	r24, 0xF1	; 241
    193e:	92 e0       	ldi	r25, 0x02	; 2
    1940:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
  
    //Third line 
    GoTo(1,2); 
    1944:	62 e0       	ldi	r22, 0x02	; 2
    1946:	81 e0       	ldi	r24, 0x01	; 1
    1948:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Consumption"); 
    194c:	81 e3       	ldi	r24, 0x31	; 49
    194e:	94 e0       	ldi	r25, 0x04	; 4
    1950:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
      
    //fourth line 
    GoTo(1,3); 
    1954:	63 e0       	ldi	r22, 0x03	; 3
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
      
    if (offline_mode) 
    195c:	80 91 83 05 	lds	r24, 0x0583
    1960:	88 23       	and	r24, r24
    1962:	29 f0       	breq	.+10     	; 0x196e <draw_menu+0x7a>
    { 
        LCDPutString("Debit");   
    1964:	8d e3       	ldi	r24, 0x3D	; 61
    1966:	94 e0       	ldi	r25, 0x04	; 4
    1968:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    196c:	04 c0       	rjmp	.+8      	; 0x1976 <draw_menu+0x82>
    }else{ 
      
    LCDPutString("Balance"); 
    196e:	8a e5       	ldi	r24, 0x5A	; 90
    1970:	94 e0       	ldi	r25, 0x04	; 4
    1972:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    } 
    while(!arrow_mov()); 
    1976:	0e 94 c9 0b 	call	0x1792	; 0x1792 <arrow_mov>
    197a:	88 23       	and	r24, r24
    197c:	e1 f3       	breq	.-8      	; 0x1976 <draw_menu+0x82>
    197e:	08 95       	ret

00001980 <getBalance>:
If online, sends request data packet, interprets it, and puts value 
in LCD template.
Consequently, it adjusts menu configuration values and
generates event to shift back to menu.
-----------------------------------------------------*/  
void getBalance(void){ 
    1980:	0f 93       	push	r16
    1982:	1f 93       	push	r17
    1984:	cf 93       	push	r28
    1986:	df 93       	push	r29
    1988:	cd b7       	in	r28, 0x3d	; 61
    198a:	de b7       	in	r29, 0x3e	; 62
    198c:	2a 97       	sbiw	r28, 0x0a	; 10
    198e:	0f b6       	in	r0, 0x3f	; 63
    1990:	f8 94       	cli
    1992:	de bf       	out	0x3e, r29	; 62
    1994:	0f be       	out	0x3f, r0	; 63
    1996:	cd bf       	out	0x3d, r28	; 61
    char balanceStr[10]; 
    lcdClear(); 
    1998:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    199c:	87 ea       	ldi	r24, 0xA7	; 167
    199e:	91 e6       	ldi	r25, 0x61	; 97
    19a0:	01 97       	sbiw	r24, 0x01	; 1
    19a2:	f1 f7       	brne	.-4      	; 0x19a0 <getBalance+0x20>
    19a4:	00 c0       	rjmp	.+0      	; 0x19a6 <getBalance+0x26>
    19a6:	00 00       	nop
    _delay_ms(10); 
    if (offline_mode) 
    19a8:	80 91 83 05 	lds	r24, 0x0583
    19ac:	88 23       	and	r24, r24
    19ae:	61 f1       	breq	.+88     	; 0x1a08 <getBalance+0x88>
    { 
        memset(balanceStr, '\0', 10); 
    19b0:	8e 01       	movw	r16, r28
    19b2:	0f 5f       	subi	r16, 0xFF	; 255
    19b4:	1f 4f       	sbci	r17, 0xFF	; 255
    19b6:	8a e0       	ldi	r24, 0x0A	; 10
    19b8:	f8 01       	movw	r30, r16
    19ba:	11 92       	st	Z+, r1
    19bc:	8a 95       	dec	r24
    19be:	e9 f7       	brne	.-6      	; 0x19ba <getBalance+0x3a>
        memcpy(balanceStr, credit_, strlen(credit_)); 
    19c0:	ea ea       	ldi	r30, 0xAA	; 170
    19c2:	f6 e0       	ldi	r31, 0x06	; 6
    19c4:	df 01       	movw	r26, r30
    19c6:	0d 90       	ld	r0, X+
    19c8:	00 20       	and	r0, r0
    19ca:	e9 f7       	brne	.-6      	; 0x19c6 <getBalance+0x46>
    19cc:	11 97       	sbiw	r26, 0x01	; 1
    19ce:	ae 1b       	sub	r26, r30
    19d0:	bf 0b       	sbc	r27, r31
    19d2:	4a 2f       	mov	r20, r26
    19d4:	5b 2f       	mov	r21, r27
    19d6:	6e 2f       	mov	r22, r30
    19d8:	7f 2f       	mov	r23, r31
    19da:	c8 01       	movw	r24, r16
    19dc:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
        GoTo(0,0); 
    19e0:	60 e0       	ldi	r22, 0x00	; 0
    19e2:	80 e0       	ldi	r24, 0x00	; 0
    19e4:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString("Account debit"); 
    19e8:	83 e4       	ldi	r24, 0x43	; 67
    19ea:	94 e0       	ldi	r25, 0x04	; 4
    19ec:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        GoTo(0,1); 
    19f0:	61 e0       	ldi	r22, 0x01	; 1
    19f2:	80 e0       	ldi	r24, 0x00	; 0
    19f4:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
        LCDPutString(balanceStr); 
    19f8:	c8 01       	movw	r24, r16
    19fa:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
        LCDPutString(" Dkk"); 
    19fe:	81 e5       	ldi	r24, 0x51	; 81
    1a00:	94 e0       	ldi	r25, 0x04	; 4
    1a02:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    1a06:	45 c0       	rjmp	.+138    	; 0x1a92 <getBalance+0x112>
    }else{ 
        formPacket("02", "01", "66", "SendBalance"); 
    1a08:	26 e5       	ldi	r18, 0x56	; 86
    1a0a:	34 e0       	ldi	r19, 0x04	; 4
    1a0c:	42 e6       	ldi	r20, 0x62	; 98
    1a0e:	54 e0       	ldi	r21, 0x04	; 4
    1a10:	6c eb       	ldi	r22, 0xBC	; 188
    1a12:	72 e0       	ldi	r23, 0x02	; 2
    1a14:	8f eb       	ldi	r24, 0xBF	; 191
    1a16:	92 e0       	ldi	r25, 0x02	; 2
    1a18:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
    sendStringUSART(formedDataPackageToSend); 
    1a1c:	8a e1       	ldi	r24, 0x1A	; 26
    1a1e:	95 e0       	ldi	r25, 0x05	; 5
    1a20:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    while(!packageReceived()); 
    1a24:	0e 94 c1 03 	call	0x782	; 0x782 <packageReceived>
    1a28:	88 23       	and	r24, r24
    1a2a:	e1 f3       	breq	.-8      	; 0x1a24 <getBalance+0xa4>
      
    if (  _command == 67    ) 
    1a2c:	80 91 1c 06 	lds	r24, 0x061C
    1a30:	90 91 1d 06 	lds	r25, 0x061D
    1a34:	83 34       	cpi	r24, 0x43	; 67
    1a36:	91 05       	cpc	r25, r1
    1a38:	c1 f4       	brne	.+48     	; 0x1a6a <getBalance+0xea>
    { 
        memset(balanceStr, '\0', dl+1); 
    1a3a:	00 91 86 06 	lds	r16, 0x0686
    1a3e:	10 91 87 06 	lds	r17, 0x0687
    1a42:	c8 01       	movw	r24, r16
    1a44:	01 96       	adiw	r24, 0x01	; 1
    1a46:	48 2f       	mov	r20, r24
    1a48:	59 2f       	mov	r21, r25
    1a4a:	60 e0       	ldi	r22, 0x00	; 0
    1a4c:	70 e0       	ldi	r23, 0x00	; 0
    1a4e:	ce 01       	movw	r24, r28
    1a50:	01 96       	adiw	r24, 0x01	; 1
    1a52:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <memset>
        memcpy(balanceStr, actualData, dl); 
    1a56:	82 e2       	ldi	r24, 0x22	; 34
    1a58:	96 e0       	ldi	r25, 0x06	; 6
    1a5a:	40 2f       	mov	r20, r16
    1a5c:	51 2f       	mov	r21, r17
    1a5e:	68 2f       	mov	r22, r24
    1a60:	79 2f       	mov	r23, r25
    1a62:	ce 01       	movw	r24, r28
    1a64:	01 96       	adiw	r24, 0x01	; 1
    1a66:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
    }
    GoTo(0,0); 
    1a6a:	60 e0       	ldi	r22, 0x00	; 0
    1a6c:	80 e0       	ldi	r24, 0x00	; 0
    1a6e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Account balance"); 
    1a72:	85 e6       	ldi	r24, 0x65	; 101
    1a74:	94 e0       	ldi	r25, 0x04	; 4
    1a76:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,1); 
    1a7a:	61 e0       	ldi	r22, 0x01	; 1
    1a7c:	80 e0       	ldi	r24, 0x00	; 0
    1a7e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString(balanceStr); 
    1a82:	ce 01       	movw	r24, r28
    1a84:	01 96       	adiw	r24, 0x01	; 1
    1a86:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(" Dkk"); 
    1a8a:	81 e5       	ldi	r24, 0x51	; 81
    1a8c:	94 e0       	ldi	r25, 0x04	; 4
    1a8e:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    } 
      
      
    GoTo(14,3); 
    1a92:	63 e0       	ldi	r22, 0x03	; 3
    1a94:	8e e0       	ldi	r24, 0x0E	; 14
    1a96:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    lcd_data_write(arrow); 
    1a9a:	80 91 8d 01 	lds	r24, 0x018D
    1a9e:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    LCDPutString(" Back"); 
    1aa2:	85 e7       	ldi	r24, 0x75	; 117
    1aa4:	94 e0       	ldi	r25, 0x04	; 4
    1aa6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    while(!waitUntilKeyPressed('B')); 
    1aaa:	82 e4       	ldi	r24, 0x42	; 66
    1aac:	0e 94 66 0b 	call	0x16cc	; 0x16cc <waitUntilKeyPressed>
    1ab0:	88 23       	and	r24, r24
    1ab2:	d9 f3       	breq	.-10     	; 0x1aaa <getBalance+0x12a>
    lcdClear(); 
    1ab4:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    1ab8:	87 ea       	ldi	r24, 0xA7	; 167
    1aba:	91 e6       	ldi	r25, 0x61	; 97
    1abc:	01 97       	sbiw	r24, 0x01	; 1
    1abe:	f1 f7       	brne	.-4      	; 0x1abc <getBalance+0x13c>
    1ac0:	00 c0       	rjmp	.+0      	; 0x1ac2 <getBalance+0x142>
    1ac2:	00 00       	nop
    _delay_ms(10); 
    if (!charged) 
    1ac4:	80 91 88 05 	lds	r24, 0x0588
    1ac8:	81 11       	cpse	r24, r1
    1aca:	0a c0       	rjmp	.+20     	; 0x1ae0 <getBalance+0x160>
    { 
        menu_position = 1; 
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	90 e0       	ldi	r25, 0x00	; 0
    1ad0:	90 93 94 01 	sts	0x0194, r25
    1ad4:	80 93 93 01 	sts	0x0193, r24
        default_menu = true; 
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	80 93 8e 01 	sts	0x018E, r24
    1ade:	09 c0       	rjmp	.+18     	; 0x1af2 <getBalance+0x172>
    }else{ 
        menu_position = 2; 
    1ae0:	82 e0       	ldi	r24, 0x02	; 2
    1ae2:	90 e0       	ldi	r25, 0x00	; 0
    1ae4:	90 93 94 01 	sts	0x0194, r25
    1ae8:	80 93 93 01 	sts	0x0193, r24
        defChargMenu = true; 
    1aec:	81 e0       	ldi	r24, 0x01	; 1
    1aee:	80 93 8b 05 	sts	0x058B, r24
    } 
    stateTransition_m(a1); 
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
} 
    1af8:	2a 96       	adiw	r28, 0x0a	; 10
    1afa:	0f b6       	in	r0, 0x3f	; 63
    1afc:	f8 94       	cli
    1afe:	de bf       	out	0x3e, r29	; 62
    1b00:	0f be       	out	0x3f, r0	; 63
    1b02:	cd bf       	out	0x3d, r28	; 61
    1b04:	df 91       	pop	r29
    1b06:	cf 91       	pop	r28
    1b08:	1f 91       	pop	r17
    1b0a:	0f 91       	pop	r16
    1b0c:	08 95       	ret

00001b0e <getConsumption>:
in LCD template. If online, sends request data packets,
interprets them, and puts values in LCD template. 
Consequently, it adjusts menu configuration values and
generates event to shift back to menu.
-----------------------------------------------------*/ 
void getConsumption(void){ 
    1b0e:	ef 92       	push	r14
    1b10:	ff 92       	push	r15
    1b12:	0f 93       	push	r16
    1b14:	1f 93       	push	r17
    1b16:	cf 93       	push	r28
    1b18:	df 93       	push	r29
    1b1a:	cd b7       	in	r28, 0x3d	; 61
    1b1c:	de b7       	in	r29, 0x3e	; 62
    1b1e:	64 97       	sbiw	r28, 0x14	; 20
    1b20:	0f b6       	in	r0, 0x3f	; 63
    1b22:	f8 94       	cli
    1b24:	de bf       	out	0x3e, r29	; 62
    1b26:	0f be       	out	0x3f, r0	; 63
    1b28:	cd bf       	out	0x3d, r28	; 61
    char consumedEnergyStr[10]; 
    char consumedTotal[10]; 
    lcdClear(); 
    1b2a:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    1b2e:	87 ea       	ldi	r24, 0xA7	; 167
    1b30:	91 e6       	ldi	r25, 0x61	; 97
    1b32:	01 97       	sbiw	r24, 0x01	; 1
    1b34:	f1 f7       	brne	.-4      	; 0x1b32 <getConsumption+0x24>
    1b36:	00 c0       	rjmp	.+0      	; 0x1b38 <getConsumption+0x2a>
    1b38:	00 00       	nop
    _delay_ms(10); 
      
    if (offline_mode) 
    1b3a:	80 91 83 05 	lds	r24, 0x0583
    1b3e:	88 23       	and	r24, r24
    1b40:	81 f1       	breq	.+96     	; 0x1ba2 <getConsumption+0x94>
    { 
        memset(consumedEnergyStr, '\0', 10); 
    1b42:	2a e0       	ldi	r18, 0x0A	; 10
    1b44:	ce 01       	movw	r24, r28
    1b46:	01 96       	adiw	r24, 0x01	; 1
    1b48:	fc 01       	movw	r30, r24
    1b4a:	32 2f       	mov	r19, r18
    1b4c:	11 92       	st	Z+, r1
    1b4e:	3a 95       	dec	r19
    1b50:	e9 f7       	brne	.-6      	; 0x1b4c <getConsumption+0x3e>
        memset(consumedTotal, '\0', 10); 
    1b52:	8e 01       	movw	r16, r28
    1b54:	05 5f       	subi	r16, 0xF5	; 245
    1b56:	1f 4f       	sbci	r17, 0xFF	; 255
    1b58:	f8 01       	movw	r30, r16
    1b5a:	11 92       	st	Z+, r1
    1b5c:	2a 95       	dec	r18
    1b5e:	e9 f7       	brne	.-6      	; 0x1b5a <getConsumption+0x4c>
        memcpy(consumedEnergyStr, pastEnergy_, strlen(pastEnergy_)); 
    1b60:	ec ec       	ldi	r30, 0xCC	; 204
    1b62:	f6 e0       	ldi	r31, 0x06	; 6
    1b64:	df 01       	movw	r26, r30
    1b66:	0d 90       	ld	r0, X+
    1b68:	00 20       	and	r0, r0
    1b6a:	e9 f7       	brne	.-6      	; 0x1b66 <getConsumption+0x58>
    1b6c:	11 97       	sbiw	r26, 0x01	; 1
    1b6e:	ae 1b       	sub	r26, r30
    1b70:	bf 0b       	sbc	r27, r31
    1b72:	4a 2f       	mov	r20, r26
    1b74:	5b 2f       	mov	r21, r27
    1b76:	6e 2f       	mov	r22, r30
    1b78:	7f 2f       	mov	r23, r31
    1b7a:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
        memcpy(consumedTotal, pastExpense_, strlen(pastExpense_)); 
    1b7e:	eb eb       	ldi	r30, 0xBB	; 187
    1b80:	f6 e0       	ldi	r31, 0x06	; 6
    1b82:	df 01       	movw	r26, r30
    1b84:	0d 90       	ld	r0, X+
    1b86:	00 20       	and	r0, r0
    1b88:	e9 f7       	brne	.-6      	; 0x1b84 <getConsumption+0x76>
    1b8a:	11 97       	sbiw	r26, 0x01	; 1
    1b8c:	ae 1b       	sub	r26, r30
    1b8e:	bf 0b       	sbc	r27, r31
    1b90:	4a 2f       	mov	r20, r26
    1b92:	5b 2f       	mov	r21, r27
    1b94:	6e 2f       	mov	r22, r30
    1b96:	7f 2f       	mov	r23, r31
    1b98:	80 2f       	mov	r24, r16
    1b9a:	91 2f       	mov	r25, r17
    1b9c:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
    1ba0:	64 c0       	rjmp	.+200    	; 0x1c6a <getConsumption+0x15c>
          
    }else{ 
        formPacket("02", "01", "61", "SendLastConsumedEnergy"); 
    1ba2:	2b e7       	ldi	r18, 0x7B	; 123
    1ba4:	34 e0       	ldi	r19, 0x04	; 4
    1ba6:	42 e9       	ldi	r20, 0x92	; 146
    1ba8:	54 e0       	ldi	r21, 0x04	; 4
    1baa:	6c eb       	ldi	r22, 0xBC	; 188
    1bac:	72 e0       	ldi	r23, 0x02	; 2
    1bae:	8f eb       	ldi	r24, 0xBF	; 191
    1bb0:	92 e0       	ldi	r25, 0x02	; 2
    1bb2:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
		sendStringUSART(formedDataPackageToSend); 
    1bb6:	8a e1       	ldi	r24, 0x1A	; 26
    1bb8:	95 e0       	ldi	r25, 0x05	; 5
    1bba:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
		
		while(!packageReceived()); 
    1bbe:	0e 94 c1 03 	call	0x782	; 0x782 <packageReceived>
    1bc2:	88 23       	and	r24, r24
    1bc4:	e1 f3       	breq	.-8      	; 0x1bbe <getConsumption+0xb0>
      
		if (  _command == 62    ) 
    1bc6:	80 91 1c 06 	lds	r24, 0x061C
    1bca:	90 91 1d 06 	lds	r25, 0x061D
    1bce:	ce 97       	sbiw	r24, 0x3e	; 62
    1bd0:	c1 f4       	brne	.+48     	; 0x1c02 <getConsumption+0xf4>
		{ 
			memset(consumedEnergyStr, '\0', dl+1); 
    1bd2:	00 91 86 06 	lds	r16, 0x0686
    1bd6:	10 91 87 06 	lds	r17, 0x0687
    1bda:	c8 01       	movw	r24, r16
    1bdc:	01 96       	adiw	r24, 0x01	; 1
    1bde:	48 2f       	mov	r20, r24
    1be0:	59 2f       	mov	r21, r25
    1be2:	60 e0       	ldi	r22, 0x00	; 0
    1be4:	70 e0       	ldi	r23, 0x00	; 0
    1be6:	ce 01       	movw	r24, r28
    1be8:	01 96       	adiw	r24, 0x01	; 1
    1bea:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <memset>
			memcpy(consumedEnergyStr, actualData, dl); 
    1bee:	82 e2       	ldi	r24, 0x22	; 34
    1bf0:	96 e0       	ldi	r25, 0x06	; 6
    1bf2:	40 2f       	mov	r20, r16
    1bf4:	51 2f       	mov	r21, r17
    1bf6:	68 2f       	mov	r22, r24
    1bf8:	79 2f       	mov	r23, r25
    1bfa:	ce 01       	movw	r24, r28
    1bfc:	01 96       	adiw	r24, 0x01	; 1
    1bfe:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
		} 
      
		formPacket("02", "01", "63", "SendLastTotal"); 
    1c02:	25 e9       	ldi	r18, 0x95	; 149
    1c04:	34 e0       	ldi	r19, 0x04	; 4
    1c06:	43 ea       	ldi	r20, 0xA3	; 163
    1c08:	54 e0       	ldi	r21, 0x04	; 4
    1c0a:	6c eb       	ldi	r22, 0xBC	; 188
    1c0c:	72 e0       	ldi	r23, 0x02	; 2
    1c0e:	8f eb       	ldi	r24, 0xBF	; 191
    1c10:	92 e0       	ldi	r25, 0x02	; 2
    1c12:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
		sendStringUSART(formedDataPackageToSend); 
    1c16:	8a e1       	ldi	r24, 0x1A	; 26
    1c18:	95 e0       	ldi	r25, 0x05	; 5
    1c1a:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
		while(!packageReceived()); 
    1c1e:	0e 94 c1 03 	call	0x782	; 0x782 <packageReceived>
    1c22:	88 23       	and	r24, r24
    1c24:	e1 f3       	breq	.-8      	; 0x1c1e <getConsumption+0x110>
      
		if (_command == 64  ) 
    1c26:	80 91 1c 06 	lds	r24, 0x061C
    1c2a:	90 91 1d 06 	lds	r25, 0x061D
    1c2e:	80 34       	cpi	r24, 0x40	; 64
    1c30:	91 05       	cpc	r25, r1
    1c32:	d9 f4       	brne	.+54     	; 0x1c6a <getConsumption+0x15c>
		{ 
			memset(consumedTotal, '\0', dl+1); 
    1c34:	e0 90 86 06 	lds	r14, 0x0686
    1c38:	f0 90 87 06 	lds	r15, 0x0687
    1c3c:	c7 01       	movw	r24, r14
    1c3e:	01 96       	adiw	r24, 0x01	; 1
    1c40:	8e 01       	movw	r16, r28
    1c42:	05 5f       	subi	r16, 0xF5	; 245
    1c44:	1f 4f       	sbci	r17, 0xFF	; 255
    1c46:	48 2f       	mov	r20, r24
    1c48:	59 2f       	mov	r21, r25
    1c4a:	60 e0       	ldi	r22, 0x00	; 0
    1c4c:	70 e0       	ldi	r23, 0x00	; 0
    1c4e:	80 2f       	mov	r24, r16
    1c50:	91 2f       	mov	r25, r17
    1c52:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <memset>
			memcpy(consumedTotal, actualData, dl); 
    1c56:	82 e2       	ldi	r24, 0x22	; 34
    1c58:	96 e0       	ldi	r25, 0x06	; 6
    1c5a:	4e 2d       	mov	r20, r14
    1c5c:	5f 2d       	mov	r21, r15
    1c5e:	68 2f       	mov	r22, r24
    1c60:	79 2f       	mov	r23, r25
    1c62:	80 2f       	mov	r24, r16
    1c64:	91 2f       	mov	r25, r17
    1c66:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
		}
    } 
      
      
    GoTo(0,0); 
    1c6a:	60 e0       	ldi	r22, 0x00	; 0
    1c6c:	80 e0       	ldi	r24, 0x00	; 0
    1c6e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("The last consumption"); 
    1c72:	86 ea       	ldi	r24, 0xA6	; 166
    1c74:	94 e0       	ldi	r25, 0x04	; 4
    1c76:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,1); 
    1c7a:	61 e0       	ldi	r22, 0x01	; 1
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
    1c7e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Energy:  "); 
    1c82:	8b eb       	ldi	r24, 0xBB	; 187
    1c84:	94 e0       	ldi	r25, 0x04	; 4
    1c86:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(consumedEnergyStr); 
    1c8a:	ce 01       	movw	r24, r28
    1c8c:	01 96       	adiw	r24, 0x01	; 1
    1c8e:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(" kWs"); 
    1c92:	85 ec       	ldi	r24, 0xC5	; 197
    1c94:	94 e0       	ldi	r25, 0x04	; 4
    1c96:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,2); 
    1c9a:	62 e0       	ldi	r22, 0x02	; 2
    1c9c:	80 e0       	ldi	r24, 0x00	; 0
    1c9e:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Charged: "); 
    1ca2:	8a ec       	ldi	r24, 0xCA	; 202
    1ca4:	94 e0       	ldi	r25, 0x04	; 4
    1ca6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(consumedTotal); 
    1caa:	ce 01       	movw	r24, r28
    1cac:	0b 96       	adiw	r24, 0x0b	; 11
    1cae:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(" dkk"); 
    1cb2:	84 ed       	ldi	r24, 0xD4	; 212
    1cb4:	94 e0       	ldi	r25, 0x04	; 4
    1cb6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(14,3); 
    1cba:	63 e0       	ldi	r22, 0x03	; 3
    1cbc:	8e e0       	ldi	r24, 0x0E	; 14
    1cbe:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    lcd_data_write(arrow); 
    1cc2:	80 91 8d 01 	lds	r24, 0x018D
    1cc6:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    LCDPutString(" Back"); 
    1cca:	85 e7       	ldi	r24, 0x75	; 117
    1ccc:	94 e0       	ldi	r25, 0x04	; 4
    1cce:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    while(!waitUntilKeyPressed('B')); 
    1cd2:	82 e4       	ldi	r24, 0x42	; 66
    1cd4:	0e 94 66 0b 	call	0x16cc	; 0x16cc <waitUntilKeyPressed>
    1cd8:	88 23       	and	r24, r24
    1cda:	d9 f3       	breq	.-10     	; 0x1cd2 <getConsumption+0x1c4>
    lcdClear(); 
    1cdc:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    1ce0:	87 ea       	ldi	r24, 0xA7	; 167
    1ce2:	91 e6       	ldi	r25, 0x61	; 97
    1ce4:	01 97       	sbiw	r24, 0x01	; 1
    1ce6:	f1 f7       	brne	.-4      	; 0x1ce4 <getConsumption+0x1d6>
    1ce8:	00 c0       	rjmp	.+0      	; 0x1cea <getConsumption+0x1dc>
    1cea:	00 00       	nop
    _delay_ms(10); 
    if (!charged) 
    1cec:	80 91 88 05 	lds	r24, 0x0588
    1cf0:	81 11       	cpse	r24, r1
    1cf2:	0a c0       	rjmp	.+20     	; 0x1d08 <getConsumption+0x1fa>
    { 
        default_menu = true; 
    1cf4:	81 e0       	ldi	r24, 0x01	; 1
    1cf6:	80 93 8e 01 	sts	0x018E, r24
        menu_position = 1; 
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	90 e0       	ldi	r25, 0x00	; 0
    1cfe:	90 93 94 01 	sts	0x0194, r25
    1d02:	80 93 93 01 	sts	0x0193, r24
    1d06:	09 c0       	rjmp	.+18     	; 0x1d1a <getConsumption+0x20c>
    }else{ 
        menu_position = 2; 
    1d08:	82 e0       	ldi	r24, 0x02	; 2
    1d0a:	90 e0       	ldi	r25, 0x00	; 0
    1d0c:	90 93 94 01 	sts	0x0194, r25
    1d10:	80 93 93 01 	sts	0x0193, r24
        defChargMenu = true; 
    1d14:	81 e0       	ldi	r24, 0x01	; 1
    1d16:	80 93 8b 05 	sts	0x058B, r24
    } 
    stateTransition_m(a1); 
    1d1a:	81 e0       	ldi	r24, 0x01	; 1
    1d1c:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
} 
    1d20:	64 96       	adiw	r28, 0x14	; 20
    1d22:	0f b6       	in	r0, 0x3f	; 63
    1d24:	f8 94       	cli
    1d26:	de bf       	out	0x3e, r29	; 62
    1d28:	0f be       	out	0x3f, r0	; 63
    1d2a:	cd bf       	out	0x3d, r28	; 61
    1d2c:	df 91       	pop	r29
    1d2e:	cf 91       	pop	r28
    1d30:	1f 91       	pop	r17
    1d32:	0f 91       	pop	r16
    1d34:	ff 90       	pop	r15
    1d36:	ef 90       	pop	r14
    1d38:	08 95       	ret

00001d3a <charging>:
LCD and waits user to confirm it. Also, adjusts menu
configuration values so that after charging, charging 
option is not available to choose anymore. After confirmation, 
generates event to get back to menu. 
-----------------------------------------------------*/   
void charging(void){ 
    1d3a:	8f 92       	push	r8
    1d3c:	9f 92       	push	r9
    1d3e:	af 92       	push	r10
    1d40:	bf 92       	push	r11
    1d42:	cf 92       	push	r12
    1d44:	df 92       	push	r13
    1d46:	ef 92       	push	r14
    1d48:	ff 92       	push	r15
    1d4a:	0f 93       	push	r16
    1d4c:	1f 93       	push	r17
    1d4e:	cf 93       	push	r28
    1d50:	df 93       	push	r29
	
	memset(expenseToPayChar, '\0', 8);
    1d52:	88 e0       	ldi	r24, 0x08	; 8
    1d54:	e4 ef       	ldi	r30, 0xF4	; 244
    1d56:	f6 e0       	ldi	r31, 0x06	; 6
    1d58:	df 01       	movw	r26, r30
    1d5a:	28 2f       	mov	r18, r24
    1d5c:	1d 92       	st	X+, r1
    1d5e:	2a 95       	dec	r18
    1d60:	e9 f7       	brne	.-6      	; 0x1d5c <charging+0x22>
	memset(energyStr, '\0', 8);
    1d62:	e9 ee       	ldi	r30, 0xE9	; 233
    1d64:	f6 e0       	ldi	r31, 0x06	; 6
    1d66:	df 01       	movw	r26, r30
    1d68:	1d 92       	st	X+, r1
    1d6a:	8a 95       	dec	r24
    1d6c:	e9 f7       	brne	.-6      	; 0x1d68 <charging+0x2e>
	
    initCharge(); 
    1d6e:	0e 94 27 01 	call	0x24e	; 0x24e <initCharge>
    while(!startCharge()); 
    1d72:	0e 94 97 02 	call	0x52e	; 0x52e <startCharge>
    1d76:	88 23       	and	r24, r24
    1d78:	e1 f3       	breq	.-8      	; 0x1d72 <charging+0x38>
	
    double sum = (double)price * (double)energy;
    1d7a:	60 91 fc 06 	lds	r22, 0x06FC
    1d7e:	70 91 fd 06 	lds	r23, 0x06FD
    1d82:	88 27       	eor	r24, r24
    1d84:	77 fd       	sbrc	r23, 7
    1d86:	80 95       	com	r24
    1d88:	98 2f       	mov	r25, r24
    1d8a:	0e 94 d0 14 	call	0x29a0	; 0x29a0 <__floatsisf>
    1d8e:	20 91 0d 05 	lds	r18, 0x050D
    1d92:	30 91 0e 05 	lds	r19, 0x050E
    1d96:	40 91 0f 05 	lds	r20, 0x050F
    1d9a:	50 91 10 05 	lds	r21, 0x0510
    1d9e:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__mulsf3>
    1da2:	16 2f       	mov	r17, r22
    1da4:	07 2f       	mov	r16, r23
    1da6:	d8 2e       	mov	r13, r24
    1da8:	c9 2e       	mov	r12, r25
	
	int sizeofArray1 = sprintf(expenseToPayChar, "%.2f \r\n", sum); 
    1daa:	9f 93       	push	r25
    1dac:	8f 93       	push	r24
    1dae:	7f 93       	push	r23
    1db0:	6f 93       	push	r22
    1db2:	c6 e4       	ldi	r28, 0x46	; 70
    1db4:	d3 e0       	ldi	r29, 0x03	; 3
    1db6:	df 93       	push	r29
    1db8:	cf 93       	push	r28
    1dba:	0f 2e       	mov	r0, r31
    1dbc:	f4 ef       	ldi	r31, 0xF4	; 244
    1dbe:	ef 2e       	mov	r14, r31
    1dc0:	f6 e0       	ldi	r31, 0x06	; 6
    1dc2:	ff 2e       	mov	r15, r31
    1dc4:	f0 2d       	mov	r31, r0
    1dc6:	ff 92       	push	r15
    1dc8:	ef 92       	push	r14
    1dca:	0e 94 b9 1b 	call	0x3772	; 0x3772 <sprintf>
    1dce:	98 2e       	mov	r9, r24
    1dd0:	89 2e       	mov	r8, r25
	int sizeofArray2 = sprintf(energyStr, "%.2f \r\n", energy);
    1dd2:	80 91 10 05 	lds	r24, 0x0510
    1dd6:	8f 93       	push	r24
    1dd8:	80 91 0f 05 	lds	r24, 0x050F
    1ddc:	8f 93       	push	r24
    1dde:	80 91 0e 05 	lds	r24, 0x050E
    1de2:	8f 93       	push	r24
    1de4:	80 91 0d 05 	lds	r24, 0x050D
    1de8:	8f 93       	push	r24
    1dea:	df 93       	push	r29
    1dec:	cf 93       	push	r28
    1dee:	c9 ee       	ldi	r28, 0xE9	; 233
    1df0:	d6 e0       	ldi	r29, 0x06	; 6
    1df2:	df 93       	push	r29
    1df4:	cf 93       	push	r28
    1df6:	0e 94 b9 1b 	call	0x3772	; 0x3772 <sprintf>
    1dfa:	b8 2e       	mov	r11, r24
    1dfc:	a9 2e       	mov	r10, r25
	
    snprintf(expenseToPayChar,sizeofArray1, "%.2f", sum); 
    1dfe:	cf 92       	push	r12
    1e00:	df 92       	push	r13
    1e02:	0f 93       	push	r16
    1e04:	1f 93       	push	r17
    1e06:	09 ed       	ldi	r16, 0xD9	; 217
    1e08:	14 e0       	ldi	r17, 0x04	; 4
    1e0a:	1f 93       	push	r17
    1e0c:	0f 93       	push	r16
    1e0e:	8f 92       	push	r8
    1e10:	9f 92       	push	r9
    1e12:	ff 92       	push	r15
    1e14:	ef 92       	push	r14
    1e16:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
      
    snprintf(energyStr,sizeofArray2, "%.2f", (double)energy ); 
    1e1a:	80 91 10 05 	lds	r24, 0x0510
    1e1e:	8f 93       	push	r24
    1e20:	80 91 0f 05 	lds	r24, 0x050F
    1e24:	8f 93       	push	r24
    1e26:	80 91 0e 05 	lds	r24, 0x050E
    1e2a:	8f 93       	push	r24
    1e2c:	80 91 0d 05 	lds	r24, 0x050D
    1e30:	8f 93       	push	r24
    1e32:	1f 93       	push	r17
    1e34:	0f 93       	push	r16
    1e36:	af 92       	push	r10
    1e38:	bf 92       	push	r11
    1e3a:	df 93       	push	r29
    1e3c:	cf 93       	push	r28
    1e3e:	0e 94 89 1b 	call	0x3712	; 0x3712 <snprintf>
    if (!offline_mode){
    1e42:	ad b7       	in	r26, 0x3d	; 61
    1e44:	be b7       	in	r27, 0x3e	; 62
    1e46:	94 96       	adiw	r26, 0x24	; 36
    1e48:	0f b6       	in	r0, 0x3f	; 63
    1e4a:	f8 94       	cli
    1e4c:	be bf       	out	0x3e, r27	; 62
    1e4e:	0f be       	out	0x3f, r0	; 63
    1e50:	ad bf       	out	0x3d, r26	; 61
    1e52:	80 91 83 05 	lds	r24, 0x0583
    1e56:	81 11       	cpse	r24, r1
    1e58:	23 c0       	rjmp	.+70     	; 0x1ea0 <charging+0x166>
        formPacket("02", "01", "86", energyStr); 
    1e5a:	9e 01       	movw	r18, r28
    1e5c:	4e ed       	ldi	r20, 0xDE	; 222
    1e5e:	54 e0       	ldi	r21, 0x04	; 4
    1e60:	6c eb       	ldi	r22, 0xBC	; 188
    1e62:	72 e0       	ldi	r23, 0x02	; 2
    1e64:	8f eb       	ldi	r24, 0xBF	; 191
    1e66:	92 e0       	ldi	r25, 0x02	; 2
    1e68:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
        sendStringUSART(formedDataPackageToSend);
    1e6c:	8a e1       	ldi	r24, 0x1A	; 26
    1e6e:	95 e0       	ldi	r25, 0x05	; 5
    1e70:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    1e74:	bf e3       	ldi	r27, 0x3F	; 63
    1e76:	22 e4       	ldi	r18, 0x42	; 66
    1e78:	8f e0       	ldi	r24, 0x0F	; 15
    1e7a:	b1 50       	subi	r27, 0x01	; 1
    1e7c:	20 40       	sbci	r18, 0x00	; 0
    1e7e:	80 40       	sbci	r24, 0x00	; 0
    1e80:	e1 f7       	brne	.-8      	; 0x1e7a <charging+0x140>
    1e82:	00 c0       	rjmp	.+0      	; 0x1e84 <charging+0x14a>
    1e84:	00 00       	nop
		_delay_ms(500); 
        formPacket("02", "01", "87", expenseToPayChar); 
    1e86:	97 01       	movw	r18, r14
    1e88:	41 ee       	ldi	r20, 0xE1	; 225
    1e8a:	54 e0       	ldi	r21, 0x04	; 4
    1e8c:	6c eb       	ldi	r22, 0xBC	; 188
    1e8e:	72 e0       	ldi	r23, 0x02	; 2
    1e90:	8f eb       	ldi	r24, 0xBF	; 191
    1e92:	92 e0       	ldi	r25, 0x02	; 2
    1e94:	0e 94 c7 03 	call	0x78e	; 0x78e <formPacket>
        sendStringUSART(formedDataPackageToSend); 
    1e98:	8a e1       	ldi	r24, 0x1A	; 26
    1e9a:	95 e0       	ldi	r25, 0x05	; 5
    1e9c:	0e 94 b2 13 	call	0x2764	; 0x2764 <sendStringUSART>
    } 
    charged = true; 
    1ea0:	21 e0       	ldi	r18, 0x01	; 1
    1ea2:	20 93 88 05 	sts	0x0588, r18
    stMenuItem = 2; 
    1ea6:	82 e0       	ldi	r24, 0x02	; 2
    1ea8:	90 e0       	ldi	r25, 0x00	; 0
    1eaa:	90 93 92 01 	sts	0x0192, r25
    1eae:	80 93 91 01 	sts	0x0191, r24
    menu_position = 2; 
    1eb2:	90 93 94 01 	sts	0x0194, r25
    1eb6:	80 93 93 01 	sts	0x0193, r24
    defChargMenu = true; 
    1eba:	20 93 8b 05 	sts	0x058B, r18
    lcdClear(); 
    1ebe:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    1ec2:	a3 ed       	ldi	r26, 0xD3	; 211
    1ec4:	b0 e3       	ldi	r27, 0x30	; 48
    1ec6:	11 97       	sbiw	r26, 0x01	; 1
    1ec8:	f1 f7       	brne	.-4      	; 0x1ec6 <charging+0x18c>
    1eca:	00 c0       	rjmp	.+0      	; 0x1ecc <charging+0x192>
    1ecc:	00 00       	nop
    _delay_ms(5); 
      
    GoTo(0,0); 
    1ece:	60 e0       	ldi	r22, 0x00	; 0
    1ed0:	80 e0       	ldi	r24, 0x00	; 0
    1ed2:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Charging's complete"); 
    1ed6:	84 ee       	ldi	r24, 0xE4	; 228
    1ed8:	94 e0       	ldi	r25, 0x04	; 4
    1eda:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    lcd_data_write(doneChar); 
    1ede:	80 91 8a 05 	lds	r24, 0x058A
    1ee2:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    GoTo(0,1); 
    1ee6:	61 e0       	ldi	r22, 0x01	; 1
    1ee8:	80 e0       	ldi	r24, 0x00	; 0
    1eea:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Energy:  "); 
    1eee:	8b eb       	ldi	r24, 0xBB	; 187
    1ef0:	94 e0       	ldi	r25, 0x04	; 4
    1ef2:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(energyStr); 
    1ef6:	89 ee       	ldi	r24, 0xE9	; 233
    1ef8:	96 e0       	ldi	r25, 0x06	; 6
    1efa:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(" kWs"); 
    1efe:	85 ec       	ldi	r24, 0xC5	; 197
    1f00:	94 e0       	ldi	r25, 0x04	; 4
    1f02:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,2); 
    1f06:	62 e0       	ldi	r22, 0x02	; 2
    1f08:	80 e0       	ldi	r24, 0x00	; 0
    1f0a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Charged: "); 
    1f0e:	8a ec       	ldi	r24, 0xCA	; 202
    1f10:	94 e0       	ldi	r25, 0x04	; 4
    1f12:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(expenseToPayChar); 
    1f16:	84 ef       	ldi	r24, 0xF4	; 244
    1f18:	96 e0       	ldi	r25, 0x06	; 6
    1f1a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    LCDPutString(" dkk"); 
    1f1e:	84 ed       	ldi	r24, 0xD4	; 212
    1f20:	94 e0       	ldi	r25, 0x04	; 4
    1f22:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,3); 
    1f26:	63 e0       	ldi	r22, 0x03	; 3
    1f28:	80 e0       	ldi	r24, 0x00	; 0
    1f2a:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    lcd_data_write(arrow); 
    1f2e:	80 91 8d 01 	lds	r24, 0x018D
    1f32:	0e 94 33 09 	call	0x1266	; 0x1266 <lcd_data_write>
    LCDPutString(" Accept"); 
    1f36:	88 ef       	ldi	r24, 0xF8	; 248
    1f38:	94 e0       	ldi	r25, 0x04	; 4
    1f3a:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    while(!waitUntilKeyPressed('A')); 
    1f3e:	81 e4       	ldi	r24, 0x41	; 65
    1f40:	0e 94 66 0b 	call	0x16cc	; 0x16cc <waitUntilKeyPressed>
    1f44:	88 23       	and	r24, r24
    1f46:	d9 f3       	breq	.-10     	; 0x1f3e <charging+0x204>
    lcdClear(); 
    1f48:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    1f4c:	83 ed       	ldi	r24, 0xD3	; 211
    1f4e:	90 e3       	ldi	r25, 0x30	; 48
    1f50:	01 97       	sbiw	r24, 0x01	; 1
    1f52:	f1 f7       	brne	.-4      	; 0x1f50 <charging+0x216>
    1f54:	00 c0       	rjmp	.+0      	; 0x1f56 <charging+0x21c>
    1f56:	00 00       	nop
    _delay_ms(5); 
    stateTransition_m(a1); 
    1f58:	81 e0       	ldi	r24, 0x01	; 1
    1f5a:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
} 
    1f5e:	df 91       	pop	r29
    1f60:	cf 91       	pop	r28
    1f62:	1f 91       	pop	r17
    1f64:	0f 91       	pop	r16
    1f66:	ff 90       	pop	r15
    1f68:	ef 90       	pop	r14
    1f6a:	df 90       	pop	r13
    1f6c:	cf 90       	pop	r12
    1f6e:	bf 90       	pop	r11
    1f70:	af 90       	pop	r10
    1f72:	9f 90       	pop	r9
    1f74:	8f 90       	pop	r8
    1f76:	08 95       	ret

00001f78 <idleWaiting>:
flag is true, it restarts controller in order to clear
registers. It is in case if it did not restart at 
endSession action.
-----------------------------------------------------*/
void idleWaiting(){ 
    if (restart) 
    1f78:	80 91 89 05 	lds	r24, 0x0589
    1f7c:	88 23       	and	r24, r24
    1f7e:	51 f0       	breq	.+20     	; 0x1f94 <idleWaiting+0x1c>
    { 
        wdt_enable(WDTO_15MS); 
    1f80:	28 e0       	ldi	r18, 0x08	; 8
    1f82:	88 e1       	ldi	r24, 0x18	; 24
    1f84:	90 e0       	ldi	r25, 0x00	; 0
    1f86:	0f b6       	in	r0, 0x3f	; 63
    1f88:	f8 94       	cli
    1f8a:	a8 95       	wdr
    1f8c:	81 bd       	out	0x21, r24	; 33
    1f8e:	0f be       	out	0x3f, r0	; 63
    1f90:	21 bd       	out	0x21, r18	; 33
    1f92:	ff cf       	rjmp	.-2      	; 0x1f92 <idleWaiting+0x1a>
        while(1); 
    } 
    lcdClear(); 
    1f94:	0e 94 45 0a 	call	0x148a	; 0x148a <lcdClear>
    1f98:	87 ea       	ldi	r24, 0xA7	; 167
    1f9a:	91 e6       	ldi	r25, 0x61	; 97
    1f9c:	01 97       	sbiw	r24, 0x01	; 1
    1f9e:	f1 f7       	brne	.-4      	; 0x1f9c <idleWaiting+0x24>
    1fa0:	00 c0       	rjmp	.+0      	; 0x1fa2 <idleWaiting+0x2a>
    1fa2:	00 00       	nop
    _delay_ms(10); 
    GoTo(0,1);
    1fa4:	61 e0       	ldi	r22, 0x01	; 1
    1fa6:	80 e0       	ldi	r24, 0x00	; 0
    1fa8:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Ultra 2000 eCharger");
    1fac:	8e e4       	ldi	r24, 0x4E	; 78
    1fae:	93 e0       	ldi	r25, 0x03	; 3
    1fb0:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    GoTo(0,2);
    1fb4:	62 e0       	ldi	r22, 0x02	; 2
    1fb6:	80 e0       	ldi	r24, 0x00	; 0
    1fb8:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <GoTo>
    LCDPutString("Press any key"); 
    1fbc:	82 e6       	ldi	r24, 0x62	; 98
    1fbe:	93 e0       	ldi	r25, 0x03	; 3
    1fc0:	0e 94 4c 0a 	call	0x1498	; 0x1498 <LCDPutString>
    while (scanKeyPad()!=1); 
    1fc4:	0e 94 66 08 	call	0x10cc	; 0x10cc <scanKeyPad>
    1fc8:	81 30       	cpi	r24, 0x01	; 1
    1fca:	e1 f7       	brne	.-8      	; 0x1fc4 <idleWaiting+0x4c>
    stateTransition_m(b2); 
    1fcc:	82 e0       	ldi	r24, 0x02	; 2
    1fce:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
    1fd2:	08 95       	ret

00001fd4 <identification>:
Function that waits until authentication process is done,
returns true and generates event to shift states and fire
actions.
-----------------------------------------------------*/  
void identification(void){ 
    while(!id()); 
    1fd4:	0e 94 3a 06 	call	0xc74	; 0xc74 <id>
    1fd8:	88 23       	and	r24, r24
    1fda:	e1 f3       	breq	.-8      	; 0x1fd4 <identification>
    stateTransition_m(a1); 
    1fdc:	81 e0       	ldi	r24, 0x01	; 1
    1fde:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
    1fe2:	08 95       	ret

00001fe4 <main>:
default event that is passed as parameter to state transition
mechanism.
-----------------------------------------------------*/  
int main(void) 
{ 
    USART_Init(64); 
    1fe4:	80 e4       	ldi	r24, 0x40	; 64
    1fe6:	90 e0       	ldi	r25, 0x00	; 0
    1fe8:	0e 94 c1 13 	call	0x2782	; 0x2782 <USART_Init>
    lcd_init(); 
    1fec:	0e 94 e2 09 	call	0x13c4	; 0x13c4 <lcd_init>
    sei(); 
    1ff0:	78 94       	sei
    keypad_init(); 
    1ff2:	0e 94 0f 09 	call	0x121e	; 0x121e <keypad_init>
    stateTransition_m(a1); 
    1ff6:	81 e0       	ldi	r24, 0x01	; 1
    1ff8:	0e 94 74 0b 	call	0x16e8	; 0x16e8 <stateTransition_m>
  
}
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	08 95       	ret

00002002 <nilAction>:
	 (*stateEvaluationRFID.actionToDoRFID)();
	 
	 
 }
 
 void nilAction(){
    2002:	08 95       	ret

00002004 <sendCommand>:
/* -----------------------------------------------------
void sendCommand()
This function sends commands and parameters to the RFID 
reader through SPI according to the flags that are set.
-----------------------------------------------------*/	 
 void sendCommand(){
    2004:	0f 93       	push	r16
    2006:	1f 93       	push	r17
    2008:	cf 93       	push	r28
    200a:	df 93       	push	r29
	
if (uid)
    200c:	80 91 9b 05 	lds	r24, 0x059B
    2010:	88 23       	and	r24, r24
    2012:	19 f0       	breq	.+6      	; 0x201a <sendCommand+0x16>
{
	SPItransmit(0x55);
    2014:	85 e5       	ldi	r24, 0x55	; 85
    2016:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
}

if (pinB)
    201a:	80 91 9a 05 	lds	r24, 0x059A
    201e:	88 23       	and	r24, r24
    2020:	49 f0       	breq	.+18     	; 0x2034 <sendCommand+0x30>
{
	SPItransmit(0x52);
    2022:	82 e5       	ldi	r24, 0x52	; 82
    2024:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    2028:	81 e0       	ldi	r24, 0x01	; 1
    202a:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    202e:	81 e0       	ldi	r24, 0x01	; 1
    2030:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
}
if (debt)
    2034:	80 91 99 05 	lds	r24, 0x0599
    2038:	88 23       	and	r24, r24
    203a:	49 f0       	breq	.+18     	; 0x204e <sendCommand+0x4a>
{
	SPItransmit(0x52);
    203c:	82 e5       	ldi	r24, 0x52	; 82
    203e:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x02);
    2042:	82 e0       	ldi	r24, 0x02	; 2
    2044:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    2048:	81 e0       	ldi	r24, 0x01	; 1
    204a:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
}
if (pastExpB)
    204e:	80 91 95 05 	lds	r24, 0x0595
    2052:	88 23       	and	r24, r24
    2054:	49 f0       	breq	.+18     	; 0x2068 <sendCommand+0x64>
{
	SPItransmit(0x52);
    2056:	82 e5       	ldi	r24, 0x52	; 82
    2058:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x04);
    205c:	84 e0       	ldi	r24, 0x04	; 4
    205e:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    2062:	81 e0       	ldi	r24, 0x01	; 1
    2064:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
}
if (pastConsB)
    2068:	80 91 96 05 	lds	r24, 0x0596
    206c:	88 23       	and	r24, r24
    206e:	49 f0       	breq	.+18     	; 0x2082 <sendCommand+0x7e>
{
	SPItransmit(0x52);
    2070:	82 e5       	ldi	r24, 0x52	; 82
    2072:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x05);
    2076:	85 e0       	ldi	r24, 0x05	; 5
    2078:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    207c:	81 e0       	ldi	r24, 0x01	; 1
    207e:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
}
if (writeCredit)
    2082:	80 91 98 05 	lds	r24, 0x0598
    2086:	88 23       	and	r24, r24
    2088:	09 f4       	brne	.+2      	; 0x208c <sendCommand+0x88>
    208a:	56 c0       	rjmp	.+172    	; 0x2138 <sendCommand+0x134>
{
	char blockAddress = 0x02;
	if (writeAction == 1)
    208c:	80 91 95 01 	lds	r24, 0x0195
    2090:	90 91 96 01 	lds	r25, 0x0196
    2094:	81 30       	cpi	r24, 0x01	; 1
    2096:	91 05       	cpc	r25, r1
    2098:	91 f4       	brne	.+36     	; 0x20be <sendCommand+0xba>
	{
		blockAddress = 0x02; //debt
		memset(parammeter, '\0', 17);
    209a:	81 e1       	ldi	r24, 0x11	; 17
    209c:	ec e0       	ldi	r30, 0x0C	; 12
    209e:	f7 e0       	ldi	r31, 0x07	; 7
    20a0:	df 01       	movw	r26, r30
    20a2:	1d 92       	st	X+, r1
    20a4:	8a 95       	dec	r24
    20a6:	e9 f7       	brne	.-6      	; 0x20a2 <sendCommand+0x9e>
		memcpy(parammeter, debtChar, 16);
    20a8:	80 e1       	ldi	r24, 0x10	; 16
    20aa:	e0 e7       	ldi	r30, 0x70	; 112
    20ac:	f7 e0       	ldi	r31, 0x07	; 7
    20ae:	ac e0       	ldi	r26, 0x0C	; 12
    20b0:	b7 e0       	ldi	r27, 0x07	; 7
    20b2:	01 90       	ld	r0, Z+
    20b4:	0d 92       	st	X+, r0
    20b6:	8a 95       	dec	r24
    20b8:	e1 f7       	brne	.-8      	; 0x20b2 <sendCommand+0xae>
if (writeCredit)
{
	char blockAddress = 0x02;
	if (writeAction == 1)
	{
		blockAddress = 0x02; //debt
    20ba:	c2 e0       	ldi	r28, 0x02	; 2
    20bc:	2a c0       	rjmp	.+84     	; 0x2112 <sendCommand+0x10e>
		memset(parammeter, '\0', 17);
		memcpy(parammeter, debtChar, 16);
		//usart_transmit('1');
	}else if (writeAction == 2)
    20be:	82 30       	cpi	r24, 0x02	; 2
    20c0:	91 05       	cpc	r25, r1
    20c2:	91 f4       	brne	.+36     	; 0x20e8 <sendCommand+0xe4>
	{
		blockAddress = 0x05; //exp
		memset(parammeter, '\0', 17);
    20c4:	81 e1       	ldi	r24, 0x11	; 17
    20c6:	ec e0       	ldi	r30, 0x0C	; 12
    20c8:	f7 e0       	ldi	r31, 0x07	; 7
    20ca:	df 01       	movw	r26, r30
    20cc:	1d 92       	st	X+, r1
    20ce:	8a 95       	dec	r24
    20d0:	e9 f7       	brne	.-6      	; 0x20cc <sendCommand+0xc8>
		memcpy(parammeter, pastEnChar, 16);
    20d2:	80 e1       	ldi	r24, 0x10	; 16
    20d4:	eb ef       	ldi	r30, 0xFB	; 251
    20d6:	f7 e0       	ldi	r31, 0x07	; 7
    20d8:	ac e0       	ldi	r26, 0x0C	; 12
    20da:	b7 e0       	ldi	r27, 0x07	; 7
    20dc:	01 90       	ld	r0, Z+
    20de:	0d 92       	st	X+, r0
    20e0:	8a 95       	dec	r24
    20e2:	e1 f7       	brne	.-8      	; 0x20dc <sendCommand+0xd8>
		memset(parammeter, '\0', 17);
		memcpy(parammeter, debtChar, 16);
		//usart_transmit('1');
	}else if (writeAction == 2)
	{
		blockAddress = 0x05; //exp
    20e4:	c5 e0       	ldi	r28, 0x05	; 5
    20e6:	15 c0       	rjmp	.+42     	; 0x2112 <sendCommand+0x10e>
		memset(parammeter, '\0', 17);
		memcpy(parammeter, pastEnChar, 16);
		//usart_transmit('2');
	}else if (writeAction == 3)
    20e8:	03 97       	sbiw	r24, 0x03	; 3
    20ea:	91 f4       	brne	.+36     	; 0x2110 <sendCommand+0x10c>
	{
		blockAddress = 0x04; //cons
		memset(parammeter, '\0', 17);
    20ec:	81 e1       	ldi	r24, 0x11	; 17
    20ee:	ec e0       	ldi	r30, 0x0C	; 12
    20f0:	f7 e0       	ldi	r31, 0x07	; 7
    20f2:	df 01       	movw	r26, r30
    20f4:	1d 92       	st	X+, r1
    20f6:	8a 95       	dec	r24
    20f8:	e9 f7       	brne	.-6      	; 0x20f4 <sendCommand+0xf0>
		memcpy(parammeter, pastExChar, 16);
    20fa:	80 e1       	ldi	r24, 0x10	; 16
    20fc:	e6 e8       	ldi	r30, 0x86	; 134
    20fe:	f7 e0       	ldi	r31, 0x07	; 7
    2100:	ac e0       	ldi	r26, 0x0C	; 12
    2102:	b7 e0       	ldi	r27, 0x07	; 7
    2104:	01 90       	ld	r0, Z+
    2106:	0d 92       	st	X+, r0
    2108:	8a 95       	dec	r24
    210a:	e1 f7       	brne	.-8      	; 0x2104 <sendCommand+0x100>
		memset(parammeter, '\0', 17);
		memcpy(parammeter, pastEnChar, 16);
		//usart_transmit('2');
	}else if (writeAction == 3)
	{
		blockAddress = 0x04; //cons
    210c:	c4 e0       	ldi	r28, 0x04	; 4
    210e:	01 c0       	rjmp	.+2      	; 0x2112 <sendCommand+0x10e>
	SPItransmit(0x05);
	SPItransmit(0x01);
}
if (writeCredit)
{
	char blockAddress = 0x02;
    2110:	c2 e0       	ldi	r28, 0x02	; 2
		blockAddress = 0x04; //cons
		memset(parammeter, '\0', 17);
		memcpy(parammeter, pastExChar, 16);
		//usart_transmit('3');
	}
	SPItransmit(0x57);
    2112:	87 e5       	ldi	r24, 0x57	; 87
    2114:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(blockAddress);
    2118:	8c 2f       	mov	r24, r28
    211a:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    211e:	81 e0       	ldi	r24, 0x01	; 1
    2120:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
    2124:	cc e0       	ldi	r28, 0x0C	; 12
    2126:	d7 e0       	ldi	r29, 0x07	; 7
/* -----------------------------------------------------
void sendCommand()
This function sends commands and parameters to the RFID 
reader through SPI according to the flags that are set.
-----------------------------------------------------*/	 
 void sendCommand(){
    2128:	0c e1       	ldi	r16, 0x1C	; 28
    212a:	17 e0       	ldi	r17, 0x07	; 7
	SPItransmit(blockAddress);
	SPItransmit(0x01);
	
	for (int i = 0; i < 16; i++)
	{
		SPItransmit(parammeter[i]);
    212c:	89 91       	ld	r24, Y+
    212e:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	}
	SPItransmit(0x57);
	SPItransmit(blockAddress);
	SPItransmit(0x01);
	
	for (int i = 0; i < 16; i++)
    2132:	c0 17       	cp	r28, r16
    2134:	d1 07       	cpc	r29, r17
    2136:	d1 f7       	brne	.-12     	; 0x212c <sendCommand+0x128>
	{
		SPItransmit(parammeter[i]);
	}
}
if (deleteCredit)
    2138:	80 91 97 05 	lds	r24, 0x0597
    213c:	88 23       	and	r24, r24
    213e:	29 f1       	breq	.+74     	; 0x218a <sendCommand+0x186>
{
	SPItransmit(0x57);
    2140:	87 e5       	ldi	r24, 0x57	; 87
    2142:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x02);
    2146:	82 e0       	ldi	r24, 0x02	; 2
    2148:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	SPItransmit(0x01);
    214c:	81 e0       	ldi	r24, 0x01	; 1
    214e:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
	
	for (i = 0; i < 6; i++)
    2152:	10 92 98 01 	sts	0x0198, r1
    2156:	10 92 97 01 	sts	0x0197, r1
    215a:	80 91 97 01 	lds	r24, 0x0197
    215e:	90 91 98 01 	lds	r25, 0x0198
    2162:	06 97       	sbiw	r24, 0x06	; 6
    2164:	94 f4       	brge	.+36     	; 0x218a <sendCommand+0x186>
	{
		SPItransmit('0');
    2166:	80 e3       	ldi	r24, 0x30	; 48
    2168:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
{
	SPItransmit(0x57);
	SPItransmit(0x02);
	SPItransmit(0x01);
	
	for (i = 0; i < 6; i++)
    216c:	80 91 97 01 	lds	r24, 0x0197
    2170:	90 91 98 01 	lds	r25, 0x0198
    2174:	01 96       	adiw	r24, 0x01	; 1
    2176:	90 93 98 01 	sts	0x0198, r25
    217a:	80 93 97 01 	sts	0x0197, r24
    217e:	80 91 97 01 	lds	r24, 0x0197
    2182:	90 91 98 01 	lds	r25, 0x0198
    2186:	06 97       	sbiw	r24, 0x06	; 6
    2188:	74 f3       	brlt	.-36     	; 0x2166 <sendCommand+0x162>
	{
		SPItransmit('0');
	}

}
}
    218a:	df 91       	pop	r29
    218c:	cf 91       	pop	r28
    218e:	1f 91       	pop	r17
    2190:	0f 91       	pop	r16
    2192:	08 95       	ret

00002194 <init>:
Initializes charging simulation by initializing other
modules and drawing graphical template.
-----------------------------------------------------*/
void init ()
{
	DDRB |= (1<< DDB0);
    2194:	b8 9a       	sbi	0x17, 0	; 23
	USART_Init(64);
    2196:	80 e4       	ldi	r24, 0x40	; 64
    2198:	90 e0       	ldi	r25, 0x00	; 0
    219a:	0e 94 c1 13 	call	0x2782	; 0x2782 <USART_Init>
	GICR |=(1<<INT0)|(1<<INT1);//
    219e:	8b b7       	in	r24, 0x3b	; 59
    21a0:	80 6c       	ori	r24, 0xC0	; 192
    21a2:	8b bf       	out	0x3b, r24	; 59
	MCUCR|=(1<<ISC00)|(1<<ISC10); //(1<<ISC11)|(1<<ISC01)| rising edge and falling edge int0 card present/removed
    21a4:	85 b7       	in	r24, 0x35	; 53
    21a6:	85 60       	ori	r24, 0x05	; 5
    21a8:	85 bf       	out	0x35, r24	; 53
	asm("SEI");
    21aa:	78 94       	sei
    21ac:	08 95       	ret

000021ae <__vector_2>:
ISR(INT1_vect)
Uses external interrupt to shift between states and determine
an appropriate event. This routine determines whenever card data 
is ready, on sequential initiation it starts the command transmission.
-----------------------------------------------------*/
ISR(INT1_vect) {
    21ae:	1f 92       	push	r1
    21b0:	0f 92       	push	r0
    21b2:	0f b6       	in	r0, 0x3f	; 63
    21b4:	0f 92       	push	r0
    21b6:	11 24       	eor	r1, r1
    21b8:	8f 93       	push	r24
static char togle=0;
	if(togle==0) {
    21ba:	80 91 9e 05 	lds	r24, 0x059E
    21be:	81 11       	cpse	r24, r1
    21c0:	07 c0       	rjmp	.+14     	; 0x21d0 <__vector_2+0x22>
		eventOccuredRFID=cardDatareadyEvent;
    21c2:	82 e0       	ldi	r24, 0x02	; 2
    21c4:	80 93 8d 05 	sts	0x058D, r24
		togle=1;
    21c8:	81 e0       	ldi	r24, 0x01	; 1
    21ca:	80 93 9e 05 	sts	0x059E, r24
    21ce:	05 c0       	rjmp	.+10     	; 0x21da <__vector_2+0x2c>
	}
	else {
		eventOccuredRFID=startTransmitEvent;
    21d0:	83 e0       	ldi	r24, 0x03	; 3
    21d2:	80 93 8d 05 	sts	0x058D, r24
		togle=0;
    21d6:	10 92 9e 05 	sts	0x059E, r1
	}
}
    21da:	8f 91       	pop	r24
    21dc:	0f 90       	pop	r0
    21de:	0f be       	out	0x3f, r0	; 63
    21e0:	0f 90       	pop	r0
    21e2:	1f 90       	pop	r1
    21e4:	18 95       	reti

000021e6 <__vector_1>:
ISR(INT0_vect)
Uses external interrupt to shift between states and determine
an appropriate event. This routine determines whenever card is
put, on sequential initiation it goes to idle state.
-----------------------------------------------------*/
ISR(INT0_vect) {
    21e6:	1f 92       	push	r1
    21e8:	0f 92       	push	r0
    21ea:	0f b6       	in	r0, 0x3f	; 63
    21ec:	0f 92       	push	r0
    21ee:	11 24       	eor	r1, r1
    21f0:	8f 93       	push	r24
static char togle=0;
   
   if (togle==0){
    21f2:	80 91 9f 05 	lds	r24, 0x059F
    21f6:	81 11       	cpse	r24, r1
    21f8:	06 c0       	rjmp	.+12     	; 0x2206 <__vector_1+0x20>
	eventOccuredRFID=cardEvent;
    21fa:	81 e0       	ldi	r24, 0x01	; 1
    21fc:	80 93 8d 05 	sts	0x058D, r24
	 togle=1;
    2200:	80 93 9f 05 	sts	0x059F, r24
    2204:	04 c0       	rjmp	.+8      	; 0x220e <__vector_1+0x28>
   }
	 else {
		 togle=0;
    2206:	10 92 9f 05 	sts	0x059F, r1
		 eventOccuredRFID=nilEvent;
    220a:	10 92 8d 05 	sts	0x058D, r1
	 }
	
}
    220e:	8f 91       	pop	r24
    2210:	0f 90       	pop	r0
    2212:	0f be       	out	0x3f, r0	; 63
    2214:	0f 90       	pop	r0
    2216:	1f 90       	pop	r1
    2218:	18 95       	reti

0000221a <stateEvalRFID>:
This function is being passed an event as a parameter and 
determines a state and action according to the a new event
and current state. 
-----------------------------------------------------*/
void stateEvalRFID(eventRFID e){
	 stateElementRFID stateEvaluationRFID = stateMatrixRFID[currentStateRFID][e];
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	dc 01       	movw	r26, r24
    221e:	aa 0f       	add	r26, r26
    2220:	bb 1f       	adc	r27, r27
    2222:	a8 0f       	add	r26, r24
    2224:	b9 1f       	adc	r27, r25
    2226:	20 91 8c 05 	lds	r18, 0x058C
    222a:	30 e0       	ldi	r19, 0x00	; 0
    222c:	c9 01       	movw	r24, r18
    222e:	88 0f       	add	r24, r24
    2230:	99 1f       	adc	r25, r25
    2232:	28 0f       	add	r18, r24
    2234:	39 1f       	adc	r19, r25
    2236:	22 0f       	add	r18, r18
    2238:	33 1f       	adc	r19, r19
    223a:	22 0f       	add	r18, r18
    223c:	33 1f       	adc	r19, r19
    223e:	a2 0f       	add	r26, r18
    2240:	b3 1f       	adc	r27, r19
    2242:	a7 56       	subi	r26, 0x67	; 103
    2244:	be 4f       	sbci	r27, 0xFE	; 254
    2246:	11 96       	adiw	r26, 0x01	; 1
    2248:	ed 91       	ld	r30, X+
    224a:	fc 91       	ld	r31, X
    224c:	12 97       	sbiw	r26, 0x02	; 2
	 currentStateRFID=stateEvaluationRFID.nextstateRFID;
    224e:	8c 91       	ld	r24, X
    2250:	80 93 8c 05 	sts	0x058C, r24
	 (*stateEvaluationRFID.actionToDoRFID)();
    2254:	09 95       	icall
    2256:	08 95       	ret

00002258 <RFIDinit>:
in case it is offlineWrite and parameter size. It also initiates
serial communication with RFID reader as well as sets up interface
and stimulates event change.
-----------------------------------------------------*/
bool RFIDinit(int command, char _parammeter[], int sizeOfPar)
{
    2258:	cf 92       	push	r12
    225a:	df 92       	push	r13
    225c:	ef 92       	push	r14
    225e:	ff 92       	push	r15
    2260:	0f 93       	push	r16
    2262:	1f 93       	push	r17
    2264:	cf 93       	push	r28
    2266:	df 93       	push	r29
    2268:	7c 01       	movw	r14, r24
    226a:	c6 2e       	mov	r12, r22
    226c:	d7 2e       	mov	r13, r23
    226e:	8a 01       	movw	r16, r20
	pl = sizeOfPar;
    2270:	50 93 91 05 	sts	0x0591, r21
    2274:	40 93 90 05 	sts	0x0590, r20
	memset(parammeter, '\0', sizeOfPar+1);
    2278:	ca 01       	movw	r24, r20
    227a:	01 96       	adiw	r24, 0x01	; 1
    227c:	cc e0       	ldi	r28, 0x0C	; 12
    227e:	d7 e0       	ldi	r29, 0x07	; 7
    2280:	48 2f       	mov	r20, r24
    2282:	59 2f       	mov	r21, r25
    2284:	60 e0       	ldi	r22, 0x00	; 0
    2286:	70 e0       	ldi	r23, 0x00	; 0
    2288:	8c 2f       	mov	r24, r28
    228a:	9d 2f       	mov	r25, r29
    228c:	0e 94 fd 1a 	call	0x35fa	; 0x35fa <memset>
	memcpy(parammeter, _parammeter, sizeOfPar);
    2290:	40 2f       	mov	r20, r16
    2292:	51 2f       	mov	r21, r17
    2294:	6c 2d       	mov	r22, r12
    2296:	7d 2d       	mov	r23, r13
    2298:	8c 2f       	mov	r24, r28
    229a:	9d 2f       	mov	r25, r29
    229c:	0e 94 f4 1a 	call	0x35e8	; 0x35e8 <memcpy>
	memset(pinChar, '\0', 5);
    22a0:	85 e0       	ldi	r24, 0x05	; 5
    22a2:	e1 e8       	ldi	r30, 0x81	; 129
    22a4:	f7 e0       	ldi	r31, 0x07	; 7
    22a6:	df 01       	movw	r26, r30
    22a8:	1d 92       	st	X+, r1
    22aa:	8a 95       	dec	r24
    22ac:	e9 f7       	brne	.-6      	; 0x22a8 <RFIDinit+0x50>
	memset(superBuffer, '\0', 100);
    22ae:	84 e6       	ldi	r24, 0x64	; 100
    22b0:	e7 e9       	ldi	r30, 0x97	; 151
    22b2:	f7 e0       	ldi	r31, 0x07	; 7
    22b4:	df 01       	movw	r26, r30
    22b6:	1d 92       	st	X+, r1
    22b8:	8a 95       	dec	r24
    22ba:	e9 f7       	brne	.-6      	; 0x22b6 <RFIDinit+0x5e>
	
	switch(command){
    22bc:	b4 e0       	ldi	r27, 0x04	; 4
    22be:	eb 16       	cp	r14, r27
    22c0:	f1 04       	cpc	r15, r1
    22c2:	01 f1       	breq	.+64     	; 0x2304 <RFIDinit+0xac>
    22c4:	4c f4       	brge	.+18     	; 0x22d8 <RFIDinit+0x80>
    22c6:	a2 e0       	ldi	r26, 0x02	; 2
    22c8:	ea 16       	cp	r14, r26
    22ca:	f1 04       	cpc	r15, r1
    22cc:	99 f0       	breq	.+38     	; 0x22f4 <RFIDinit+0x9c>
    22ce:	b4 f4       	brge	.+44     	; 0x22fc <RFIDinit+0xa4>
    22d0:	ea 94       	dec	r14
    22d2:	ef 28       	or	r14, r15
    22d4:	31 f5       	brne	.+76     	; 0x2322 <RFIDinit+0xca>
    22d6:	0a c0       	rjmp	.+20     	; 0x22ec <RFIDinit+0x94>
    22d8:	a6 e0       	ldi	r26, 0x06	; 6
    22da:	ea 16       	cp	r14, r26
    22dc:	f1 04       	cpc	r15, r1
    22de:	d1 f0       	breq	.+52     	; 0x2314 <RFIDinit+0xbc>
    22e0:	ac f0       	brlt	.+42     	; 0x230c <RFIDinit+0xb4>
    22e2:	87 e0       	ldi	r24, 0x07	; 7
    22e4:	e8 16       	cp	r14, r24
    22e6:	f1 04       	cpc	r15, r1
    22e8:	e1 f4       	brne	.+56     	; 0x2322 <RFIDinit+0xca>
    22ea:	18 c0       	rjmp	.+48     	; 0x231c <RFIDinit+0xc4>
		case 1 :
			uid = true;
    22ec:	81 e0       	ldi	r24, 0x01	; 1
    22ee:	80 93 9b 05 	sts	0x059B, r24
		break;
    22f2:	17 c0       	rjmp	.+46     	; 0x2322 <RFIDinit+0xca>
		
		case 2 :
			debt = true;
    22f4:	81 e0       	ldi	r24, 0x01	; 1
    22f6:	80 93 99 05 	sts	0x0599, r24
		break;
    22fa:	13 c0       	rjmp	.+38     	; 0x2322 <RFIDinit+0xca>
		
		case 3 :
			pinB = true;
    22fc:	81 e0       	ldi	r24, 0x01	; 1
    22fe:	80 93 9a 05 	sts	0x059A, r24
			
		break;
    2302:	0f c0       	rjmp	.+30     	; 0x2322 <RFIDinit+0xca>
		
		case 4 :
			deleteCredit = true;
    2304:	81 e0       	ldi	r24, 0x01	; 1
    2306:	80 93 97 05 	sts	0x0597, r24
		break;
    230a:	0b c0       	rjmp	.+22     	; 0x2322 <RFIDinit+0xca>
		
		case 5 :
			writeCredit = true;
    230c:	81 e0       	ldi	r24, 0x01	; 1
    230e:	80 93 98 05 	sts	0x0598, r24
		break;
    2312:	07 c0       	rjmp	.+14     	; 0x2322 <RFIDinit+0xca>
		
		case 6 :
			pastConsB = true;
    2314:	81 e0       	ldi	r24, 0x01	; 1
    2316:	80 93 96 05 	sts	0x0596, r24
		break;
    231a:	03 c0       	rjmp	.+6      	; 0x2322 <RFIDinit+0xca>
		
		case 7 :
			pastExpB = true;
    231c:	81 e0       	ldi	r24, 0x01	; 1
    231e:	80 93 95 05 	sts	0x0595, r24
		break;
		
	}
	 init();
    2322:	0e 94 ca 10 	call	0x2194	; 0x2194 <init>
	 SPIinit();
    2326:	0e 94 59 13 	call	0x26b2	; 0x26b2 <SPIinit>
	

while (!rfidDone)
    232a:	80 91 8e 05 	lds	r24, 0x058E
    232e:	81 11       	cpse	r24, r1
    2330:	08 c0       	rjmp	.+16     	; 0x2342 <RFIDinit+0xea>
{
	  stateEvalRFID(eventOccuredRFID);
    2332:	80 91 8d 05 	lds	r24, 0x058D
    2336:	0e 94 0d 11 	call	0x221a	; 0x221a <stateEvalRFID>
	}
	 init();
	 SPIinit();
	

while (!rfidDone)
    233a:	80 91 8e 05 	lds	r24, 0x058E
    233e:	88 23       	and	r24, r24
    2340:	c1 f3       	breq	.-16     	; 0x2332 <RFIDinit+0xda>
{
	  stateEvalRFID(eventOccuredRFID);
}	
return true;	   
}
    2342:	81 e0       	ldi	r24, 0x01	; 1
    2344:	df 91       	pop	r29
    2346:	cf 91       	pop	r28
    2348:	1f 91       	pop	r17
    234a:	0f 91       	pop	r16
    234c:	ff 90       	pop	r15
    234e:	ef 90       	pop	r14
    2350:	df 90       	pop	r13
    2352:	cf 90       	pop	r12
    2354:	08 95       	ret

00002356 <SPItransmit_>:
char byte as a parameter, shifts it to RFID and puts received
one to the superBuffer array. Acts as a usual buffer.
-----------------------------------------------------*/
 void SPItransmit_(unsigned char byte)
 {
	 SPDR = byte;					//Load byte to Data register
    2356:	8f b9       	out	0x0f, r24	; 15
	 while(!(SPSR & (1<<SPIF))); 	// Wait for transmission complete
    2358:	77 9b       	sbis	0x0e, 7	; 14
    235a:	fe cf       	rjmp	.-4      	; 0x2358 <SPItransmit_+0x2>
	 char dd = SPDR;
    235c:	2f b1       	in	r18, 0x0f	; 15
	 superBuffer[index_] = dd;
    235e:	80 91 9c 05 	lds	r24, 0x059C
    2362:	90 91 9d 05 	lds	r25, 0x059D
    2366:	fc 01       	movw	r30, r24
    2368:	e9 56       	subi	r30, 0x69	; 105
    236a:	f8 4f       	sbci	r31, 0xF8	; 248
    236c:	20 83       	st	Z, r18
// 	 usart_transmit('f');
// 	 usart_transmit(dd);
	 index_++;
    236e:	01 96       	adiw	r24, 0x01	; 1
    2370:	90 93 9d 05 	sts	0x059D, r25
    2374:	80 93 9c 05 	sts	0x059C, r24
    2378:	08 95       	ret

0000237a <readBuffer>:
true for card id reading and converts id bit value to ASCII
representation and stores it to RfidBufferToRead array. On
second case it calls SPItransmit_ where register is shift
and bytes are stored to superBuffer array.
-----------------------------------------------------*/ 
 void readBuffer(){ 
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	00 d0       	rcall	.+0      	; 0x2380 <readBuffer+0x6>
    2380:	cd b7       	in	r28, 0x3d	; 61
    2382:	de b7       	in	r29, 0x3e	; 62
	 if (uid)
    2384:	80 91 9b 05 	lds	r24, 0x059B
    2388:	88 23       	and	r24, r24
    238a:	09 f4       	brne	.+2      	; 0x238e <readBuffer+0x14>
    238c:	3f c0       	rjmp	.+126    	; 0x240c <readBuffer+0x92>
    238e:	87 e8       	ldi	r24, 0x87	; 135
    2390:	93 e1       	ldi	r25, 0x13	; 19
    2392:	01 97       	sbiw	r24, 0x01	; 1
    2394:	f1 f7       	brne	.-4      	; 0x2392 <readBuffer+0x18>
    2396:	00 c0       	rjmp	.+0      	; 0x2398 <readBuffer+0x1e>
    2398:	00 00       	nop
	 {
			 _delay_ms(2);
			 SPItransmit(0xF5);
    239a:	85 ef       	ldi	r24, 0xF5	; 245
    239c:	0e 94 5e 13 	call	0x26bc	; 0x26bc <SPItransmit>
			 char data = SPDR;
    23a0:	8f b1       	in	r24, 0x0f	; 15
			 char HEXbuffer[2];
			 sprintf(HEXbuffer,"%02X", data);
    23a2:	1f 92       	push	r1
    23a4:	8f 93       	push	r24
    23a6:	80 e0       	ldi	r24, 0x00	; 0
    23a8:	95 e0       	ldi	r25, 0x05	; 5
    23aa:	9f 93       	push	r25
    23ac:	8f 93       	push	r24
    23ae:	ce 01       	movw	r24, r28
    23b0:	01 96       	adiw	r24, 0x01	; 1
    23b2:	9f 93       	push	r25
    23b4:	8f 93       	push	r24
    23b6:	0e 94 b9 1b 	call	0x3772	; 0x3772 <sprintf>
			 //RfidBufferToRead[15]='\0';
			 RfidBufferToRead[i]=HEXbuffer[1];
    23ba:	e0 91 97 01 	lds	r30, 0x0197
    23be:	f0 91 98 01 	lds	r31, 0x0198
    23c2:	e2 50       	subi	r30, 0x02	; 2
    23c4:	f9 4f       	sbci	r31, 0xF9	; 249
    23c6:	8a 81       	ldd	r24, Y+2	; 0x02
    23c8:	80 83       	st	Z, r24
			 i--;
    23ca:	80 91 97 01 	lds	r24, 0x0197
    23ce:	90 91 98 01 	lds	r25, 0x0198
    23d2:	01 97       	sbiw	r24, 0x01	; 1
    23d4:	90 93 98 01 	sts	0x0198, r25
    23d8:	80 93 97 01 	sts	0x0197, r24
			 RfidBufferToRead[i]=HEXbuffer[0];
    23dc:	e0 91 97 01 	lds	r30, 0x0197
    23e0:	f0 91 98 01 	lds	r31, 0x0198
    23e4:	e2 50       	subi	r30, 0x02	; 2
    23e6:	f9 4f       	sbci	r31, 0xF9	; 249
    23e8:	89 81       	ldd	r24, Y+1	; 0x01
    23ea:	80 83       	st	Z, r24
			 i--;
    23ec:	80 91 97 01 	lds	r24, 0x0197
    23f0:	90 91 98 01 	lds	r25, 0x0198
    23f4:	01 97       	sbiw	r24, 0x01	; 1
    23f6:	90 93 98 01 	sts	0x0198, r25
    23fa:	80 93 97 01 	sts	0x0197, r24
    23fe:	0f 90       	pop	r0
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	0f 90       	pop	r0
    2406:	0f 90       	pop	r0
    2408:	0f 90       	pop	r0
    240a:	09 c0       	rjmp	.+18     	; 0x241e <readBuffer+0xa4>
    240c:	87 e8       	ldi	r24, 0x87	; 135
    240e:	93 e1       	ldi	r25, 0x13	; 19
    2410:	01 97       	sbiw	r24, 0x01	; 1
    2412:	f1 f7       	brne	.-4      	; 0x2410 <readBuffer+0x96>
    2414:	00 c0       	rjmp	.+0      	; 0x2416 <readBuffer+0x9c>
    2416:	00 00       	nop
	 }else{
			_delay_ms(2);
			SPItransmit_(0xF5);
    2418:	85 ef       	ldi	r24, 0xF5	; 245
    241a:	0e 94 ab 11 	call	0x2356	; 0x2356 <SPItransmit_>
			//usart_transmit('r');
	 }
}
    241e:	0f 90       	pop	r0
    2420:	0f 90       	pop	r0
    2422:	df 91       	pop	r29
    2424:	cf 91       	pop	r28
    2426:	08 95       	ret

00002428 <OnlineFirstReading>:
		 onlineFirstREad = false;
		 putString("deleted");
		 eventOccuredRFID=nilEvent;
	 }*/
	 
	 if (onlineFirstREad && debt)
    2428:	80 91 92 05 	lds	r24, 0x0592
    242c:	88 23       	and	r24, r24
    242e:	91 f1       	breq	.+100    	; 0x2494 <OnlineFirstReading+0x6c>
    2430:	80 91 99 05 	lds	r24, 0x0599
    2434:	88 23       	and	r24, r24
    2436:	f9 f0       	breq	.+62     	; 0x2476 <OnlineFirstReading+0x4e>
	 {
		 rfidDone = true;
    2438:	81 e0       	ldi	r24, 0x01	; 1
    243a:	80 93 8e 05 	sts	0x058E, r24
		 deleteCredit = true;
    243e:	80 93 97 05 	sts	0x0597, r24
		 debt = false;
    2442:	10 92 99 05 	sts	0x0599, r1
		 //creditDetected = true;
		 onlineFirstREad = true;
    2446:	80 93 92 05 	sts	0x0592, r24
		 memcpy(debtChar, superBuffer + 1, 16);
    244a:	80 e1       	ldi	r24, 0x10	; 16
    244c:	e8 e9       	ldi	r30, 0x98	; 152
    244e:	f7 e0       	ldi	r31, 0x07	; 7
    2450:	a0 e7       	ldi	r26, 0x70	; 112
    2452:	b7 e0       	ldi	r27, 0x07	; 7
    2454:	01 90       	ld	r0, Z+
    2456:	0d 92       	st	X+, r0
    2458:	8a 95       	dec	r24
    245a:	e1 f7       	brne	.-8      	; 0x2454 <OnlineFirstReading+0x2c>
		 memset(superBuffer, '\0', 100);
    245c:	84 e6       	ldi	r24, 0x64	; 100
    245e:	e7 e9       	ldi	r30, 0x97	; 151
    2460:	f7 e0       	ldi	r31, 0x07	; 7
    2462:	df 01       	movw	r26, r30
    2464:	1d 92       	st	X+, r1
    2466:	8a 95       	dec	r24
    2468:	e9 f7       	brne	.-6      	; 0x2464 <OnlineFirstReading+0x3c>
		 eventOccuredRFID=nilEvent;
    246a:	10 92 8d 05 	sts	0x058D, r1
	 }
	 
	 
	 if (onlineFirstREad && uid)
    246e:	80 91 92 05 	lds	r24, 0x0592
    2472:	88 23       	and	r24, r24
    2474:	79 f0       	breq	.+30     	; 0x2494 <OnlineFirstReading+0x6c>
    2476:	80 91 9b 05 	lds	r24, 0x059B
    247a:	88 23       	and	r24, r24
    247c:	59 f0       	breq	.+22     	; 0x2494 <OnlineFirstReading+0x6c>
	 {
		uid = false;
    247e:	10 92 9b 05 	sts	0x059B, r1
		debt = true;
    2482:	81 e0       	ldi	r24, 0x01	; 1
    2484:	80 93 99 05 	sts	0x0599, r24
		onlineFirstREad = true;
    2488:	80 93 92 05 	sts	0x0592, r24
		RfidBufferToRead[16]='\0';
    248c:	10 92 0e 07 	sts	0x070E, r1
		//putString(RfidBufferToRead);
		//putString("\nfirstonline\n");
		eventOccuredRFID=cardEvent;
    2490:	80 93 8d 05 	sts	0x058D, r24
    2494:	08 95       	ret

00002496 <OfflineWriting>:
to the RFID card at consecutive states and events. By default
first write action is to write debt, then it automatically sets
flag to write last consumption and then - last expense.
-----------------------------------------------------*/
 void OfflineWriting(){
	  if (offlineWrite && writeCredit && writeAction == 3)
    2496:	80 91 93 05 	lds	r24, 0x0593
    249a:	88 23       	and	r24, r24
    249c:	b1 f1       	breq	.+108    	; 0x250a <OfflineWriting+0x74>
    249e:	80 91 98 05 	lds	r24, 0x0598
    24a2:	88 23       	and	r24, r24
    24a4:	91 f1       	breq	.+100    	; 0x250a <OfflineWriting+0x74>
    24a6:	80 91 95 01 	lds	r24, 0x0195
    24aa:	90 91 96 01 	lds	r25, 0x0196
    24ae:	03 97       	sbiw	r24, 0x03	; 3
    24b0:	51 f4       	brne	.+20     	; 0x24c6 <OfflineWriting+0x30>
	  {
		  rfidDone = true;
    24b2:	81 e0       	ldi	r24, 0x01	; 1
    24b4:	80 93 8e 05 	sts	0x058E, r24
		  offlineWrite = false;
    24b8:	10 92 93 05 	sts	0x0593, r1
		  writeCredit = false;
    24bc:	10 92 98 05 	sts	0x0598, r1
		  //putString("\ndoneOfflinewrite\n");
		  eventOccuredRFID=nilEvent;
    24c0:	10 92 8d 05 	sts	0x058D, r1
    24c4:	08 95       	ret
	  }
	  
	   if (offlineWrite && writeCredit && writeAction == 2)
    24c6:	80 91 95 01 	lds	r24, 0x0195
    24ca:	90 91 96 01 	lds	r25, 0x0196
    24ce:	02 97       	sbiw	r24, 0x02	; 2
    24d0:	69 f4       	brne	.+26     	; 0x24ec <OfflineWriting+0x56>
	   {
		   writeCredit = true;
		   writeAction = 3;
    24d2:	83 e0       	ldi	r24, 0x03	; 3
    24d4:	90 e0       	ldi	r25, 0x00	; 0
    24d6:	90 93 96 01 	sts	0x0196, r25
    24da:	80 93 95 01 	sts	0x0195, r24
		   
		   eventOccuredRFID=cardEvent;
    24de:	81 e0       	ldi	r24, 0x01	; 1
    24e0:	80 93 8d 05 	sts	0x058D, r24
	   }
	   
	    if (offlineWrite && writeCredit && writeAction == 1)
    24e4:	80 91 98 05 	lds	r24, 0x0598
    24e8:	88 23       	and	r24, r24
    24ea:	79 f0       	breq	.+30     	; 0x250a <OfflineWriting+0x74>
    24ec:	80 91 95 01 	lds	r24, 0x0195
    24f0:	90 91 96 01 	lds	r25, 0x0196
    24f4:	01 97       	sbiw	r24, 0x01	; 1
    24f6:	49 f4       	brne	.+18     	; 0x250a <OfflineWriting+0x74>
	    {
		    writeCredit = true;
			writeAction = 2;
    24f8:	82 e0       	ldi	r24, 0x02	; 2
    24fa:	90 e0       	ldi	r25, 0x00	; 0
    24fc:	90 93 96 01 	sts	0x0196, r25
    2500:	80 93 95 01 	sts	0x0195, r24
		    
		    eventOccuredRFID=cardEvent;
    2504:	81 e0       	ldi	r24, 0x01	; 1
    2506:	80 93 8d 05 	sts	0x058D, r24
    250a:	08 95       	ret

0000250c <OfflineFirstReading>:
Consecutively it performs same action for storing pin, 
past expenditure and past expense values.
-----------------------------------------------------*/
 void OfflineFirstReading(){
	 
	 if (offlineFirstRead && pastExpB)
    250c:	80 91 94 05 	lds	r24, 0x0594
    2510:	88 23       	and	r24, r24
    2512:	09 f4       	brne	.+2      	; 0x2516 <OfflineFirstReading+0xa>
    2514:	92 c0       	rjmp	.+292    	; 0x263a <OfflineFirstReading+0x12e>
    2516:	80 91 95 05 	lds	r24, 0x0595
    251a:	88 23       	and	r24, r24
    251c:	01 f1       	breq	.+64     	; 0x255e <OfflineFirstReading+0x52>
	 {
		 rfidDone = true;
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	80 93 8e 05 	sts	0x058E, r24
		 pastConsB = false;
    2524:	10 92 96 05 	sts	0x0596, r1
		 pastExpB = false;
    2528:	10 92 95 05 	sts	0x0595, r1
		 offlineFirstRead = false;
    252c:	10 92 94 05 	sts	0x0594, r1
		 memcpy(pastExChar, superBuffer + 1, 16);
    2530:	80 e1       	ldi	r24, 0x10	; 16
    2532:	e8 e9       	ldi	r30, 0x98	; 152
    2534:	f7 e0       	ldi	r31, 0x07	; 7
    2536:	a6 e8       	ldi	r26, 0x86	; 134
    2538:	b7 e0       	ldi	r27, 0x07	; 7
    253a:	01 90       	ld	r0, Z+
    253c:	0d 92       	st	X+, r0
    253e:	8a 95       	dec	r24
    2540:	e1 f7       	brne	.-8      	; 0x253a <OfflineFirstReading+0x2e>
		// putString(pastExChar);
		//  putString("\ndoneoffline\n");
		 memset(superBuffer, '\0', 100);
    2542:	84 e6       	ldi	r24, 0x64	; 100
    2544:	e7 e9       	ldi	r30, 0x97	; 151
    2546:	f7 e0       	ldi	r31, 0x07	; 7
    2548:	df 01       	movw	r26, r30
    254a:	1d 92       	st	X+, r1
    254c:	8a 95       	dec	r24
    254e:	e9 f7       	brne	.-6      	; 0x254a <OfflineFirstReading+0x3e>
		 eventOccuredRFID=nilEvent;
    2550:	10 92 8d 05 	sts	0x058D, r1
	 }
	 
	 if (offlineFirstRead && pastConsB)
    2554:	80 91 94 05 	lds	r24, 0x0594
    2558:	88 23       	and	r24, r24
    255a:	09 f4       	brne	.+2      	; 0x255e <OfflineFirstReading+0x52>
    255c:	6e c0       	rjmp	.+220    	; 0x263a <OfflineFirstReading+0x12e>
    255e:	80 91 96 05 	lds	r24, 0x0596
    2562:	88 23       	and	r24, r24
    2564:	09 f4       	brne	.+2      	; 0x2568 <OfflineFirstReading+0x5c>
    2566:	5d c0       	rjmp	.+186    	; 0x2622 <OfflineFirstReading+0x116>
	 {
		 pastConsB = false;
    2568:	10 92 96 05 	sts	0x0596, r1
		 pastExpB = true;
    256c:	81 e0       	ldi	r24, 0x01	; 1
    256e:	80 93 95 05 	sts	0x0595, r24
		 memcpy(pastEnChar, superBuffer + 1, 16);
    2572:	90 e1       	ldi	r25, 0x10	; 16
    2574:	e8 e9       	ldi	r30, 0x98	; 152
    2576:	f7 e0       	ldi	r31, 0x07	; 7
    2578:	ab ef       	ldi	r26, 0xFB	; 251
    257a:	b7 e0       	ldi	r27, 0x07	; 7
    257c:	01 90       	ld	r0, Z+
    257e:	0d 92       	st	X+, r0
    2580:	9a 95       	dec	r25
    2582:	e1 f7       	brne	.-8      	; 0x257c <OfflineFirstReading+0x70>
	//	 putString(pastEnChar);
		 memset(superBuffer, '\0', 100);
    2584:	94 e6       	ldi	r25, 0x64	; 100
    2586:	e7 e9       	ldi	r30, 0x97	; 151
    2588:	f7 e0       	ldi	r31, 0x07	; 7
    258a:	df 01       	movw	r26, r30
    258c:	1d 92       	st	X+, r1
    258e:	9a 95       	dec	r25
    2590:	e9 f7       	brne	.-6      	; 0x258c <OfflineFirstReading+0x80>
		 eventOccuredRFID=cardEvent;
    2592:	80 93 8d 05 	sts	0x058D, r24
    2596:	45 c0       	rjmp	.+138    	; 0x2622 <OfflineFirstReading+0x116>
	 }
	 
	 if (offlineFirstRead && debt)
	 {
		 rfidDone = false;
    2598:	10 92 8e 05 	sts	0x058E, r1
		 debt = false;
    259c:	10 92 99 05 	sts	0x0599, r1
		 pastConsB = true;
    25a0:	81 e0       	ldi	r24, 0x01	; 1
    25a2:	80 93 96 05 	sts	0x0596, r24
		 memcpy(debtChar, superBuffer + 1, 16);
    25a6:	90 e1       	ldi	r25, 0x10	; 16
    25a8:	e8 e9       	ldi	r30, 0x98	; 152
    25aa:	f7 e0       	ldi	r31, 0x07	; 7
    25ac:	a0 e7       	ldi	r26, 0x70	; 112
    25ae:	b7 e0       	ldi	r27, 0x07	; 7
    25b0:	01 90       	ld	r0, Z+
    25b2:	0d 92       	st	X+, r0
    25b4:	9a 95       	dec	r25
    25b6:	e1 f7       	brne	.-8      	; 0x25b0 <OfflineFirstReading+0xa4>
	//	 putString(debtChar);
		 memset(superBuffer, '\0', 100);
    25b8:	94 e6       	ldi	r25, 0x64	; 100
    25ba:	e7 e9       	ldi	r30, 0x97	; 151
    25bc:	f7 e0       	ldi	r31, 0x07	; 7
    25be:	df 01       	movw	r26, r30
    25c0:	1d 92       	st	X+, r1
    25c2:	9a 95       	dec	r25
    25c4:	e9 f7       	brne	.-6      	; 0x25c0 <OfflineFirstReading+0xb4>
		 eventOccuredRFID=cardEvent;
    25c6:	80 93 8d 05 	sts	0x058D, r24
    25ca:	2f c0       	rjmp	.+94     	; 0x262a <OfflineFirstReading+0x11e>
	 }
	 
	 
	 if (offlineFirstRead && pinB)
	 {
		 rfidDone = false;
    25cc:	10 92 8e 05 	sts	0x058E, r1
		 pinB = false;
    25d0:	10 92 9a 05 	sts	0x059A, r1
		 debt = true;
    25d4:	21 e0       	ldi	r18, 0x01	; 1
    25d6:	20 93 99 05 	sts	0x0599, r18
		 memcpy(pinChar, superBuffer + 1, 4);
    25da:	80 91 98 07 	lds	r24, 0x0798
    25de:	90 91 99 07 	lds	r25, 0x0799
    25e2:	a0 91 9a 07 	lds	r26, 0x079A
    25e6:	b0 91 9b 07 	lds	r27, 0x079B
    25ea:	80 93 81 07 	sts	0x0781, r24
    25ee:	90 93 82 07 	sts	0x0782, r25
    25f2:	a0 93 83 07 	sts	0x0783, r26
    25f6:	b0 93 84 07 	sts	0x0784, r27
	//	 putString(pinChar);
		 memset(superBuffer, '\0', 100);
    25fa:	84 e6       	ldi	r24, 0x64	; 100
    25fc:	e7 e9       	ldi	r30, 0x97	; 151
    25fe:	f7 e0       	ldi	r31, 0x07	; 7
    2600:	df 01       	movw	r26, r30
    2602:	1d 92       	st	X+, r1
    2604:	8a 95       	dec	r24
    2606:	e9 f7       	brne	.-6      	; 0x2602 <OfflineFirstReading+0xf6>
		 eventOccuredRFID=cardEvent;
    2608:	20 93 8d 05 	sts	0x058D, r18
    260c:	12 c0       	rjmp	.+36     	; 0x2632 <OfflineFirstReading+0x126>
	 }
	 
	 if (offlineFirstRead && uid)
	 {
		 uid = false;
    260e:	10 92 9b 05 	sts	0x059B, r1
		 pinB = true;
    2612:	81 e0       	ldi	r24, 0x01	; 1
    2614:	80 93 9a 05 	sts	0x059A, r24
		 RfidBufferToRead[16]='\0';
    2618:	10 92 0e 07 	sts	0x070E, r1
	//	 putString(RfidBufferToRead);
		 eventOccuredRFID=cardEvent;
    261c:	80 93 8d 05 	sts	0x058D, r24
    2620:	08 95       	ret
	//	 putString(pastEnChar);
		 memset(superBuffer, '\0', 100);
		 eventOccuredRFID=cardEvent;
	 }
	 
	 if (offlineFirstRead && debt)
    2622:	80 91 99 05 	lds	r24, 0x0599
    2626:	81 11       	cpse	r24, r1
    2628:	b7 cf       	rjmp	.-146    	; 0x2598 <OfflineFirstReading+0x8c>
		 memset(superBuffer, '\0', 100);
		 eventOccuredRFID=cardEvent;
	 }
	 
	 
	 if (offlineFirstRead && pinB)
    262a:	80 91 9a 05 	lds	r24, 0x059A
    262e:	81 11       	cpse	r24, r1
    2630:	cd cf       	rjmp	.-102    	; 0x25cc <OfflineFirstReading+0xc0>
	//	 putString(pinChar);
		 memset(superBuffer, '\0', 100);
		 eventOccuredRFID=cardEvent;
	 }
	 
	 if (offlineFirstRead && uid)
    2632:	80 91 9b 05 	lds	r24, 0x059B
    2636:	81 11       	cpse	r24, r1
    2638:	ea cf       	rjmp	.-44     	; 0x260e <OfflineFirstReading+0x102>
    263a:	08 95       	ret

0000263c <transmitString>:
offlineWrite->OfflineWriting()
onlineFirstREad->OnlineFirstReading()
-----------------------------------------------------*/
 void transmitString(){
	
	memset(parammeter, '\0', 100);
    263c:	84 e6       	ldi	r24, 0x64	; 100
    263e:	ec e0       	ldi	r30, 0x0C	; 12
    2640:	f7 e0       	ldi	r31, 0x07	; 7
    2642:	df 01       	movw	r26, r30
    2644:	1d 92       	st	X+, r1
    2646:	8a 95       	dec	r24
    2648:	e9 f7       	brne	.-6      	; 0x2644 <transmitString+0x8>
	pl = 0;
    264a:	10 92 91 05 	sts	0x0591, r1
    264e:	10 92 90 05 	sts	0x0590, r1
	i = MAX;
    2652:	8e e0       	ldi	r24, 0x0E	; 14
    2654:	90 e0       	ldi	r25, 0x00	; 0
    2656:	90 93 98 01 	sts	0x0198, r25
    265a:	80 93 97 01 	sts	0x0197, r24
	index_ = 0;
    265e:	10 92 9d 05 	sts	0x059D, r1
    2662:	10 92 9c 05 	sts	0x059C, r1
	bufferRead=0;
    2666:	10 92 8f 05 	sts	0x058F, r1
	
	if (offlineFirstRead)
    266a:	80 91 94 05 	lds	r24, 0x0594
    266e:	88 23       	and	r24, r24
    2670:	19 f0       	breq	.+6      	; 0x2678 <transmitString+0x3c>
	{
		OfflineFirstReading();
    2672:	0e 94 86 12 	call	0x250c	; 0x250c <OfflineFirstReading>
    2676:	08 95       	ret
	}
	else if (offlineWrite)
    2678:	80 91 93 05 	lds	r24, 0x0593
    267c:	88 23       	and	r24, r24
    267e:	19 f0       	breq	.+6      	; 0x2686 <transmitString+0x4a>
	{
		OfflineWriting();
    2680:	0e 94 4b 12 	call	0x2496	; 0x2496 <OfflineWriting>
    2684:	08 95       	ret
		
	}else if(onlineFirstREad)
    2686:	80 91 92 05 	lds	r24, 0x0592
    268a:	88 23       	and	r24, r24
    268c:	19 f0       	breq	.+6      	; 0x2694 <transmitString+0x58>
	{
		OnlineFirstReading();
    268e:	0e 94 14 12 	call	0x2428	; 0x2428 <OnlineFirstReading>
    2692:	08 95       	ret
		
	}else if(deleteCredit){
    2694:	80 91 97 05 	lds	r24, 0x0597
    2698:	88 23       	and	r24, r24
    269a:	41 f0       	breq	.+16     	; 0x26ac <transmitString+0x70>
		
		rfidDone = true;
    269c:	81 e0       	ldi	r24, 0x01	; 1
    269e:	80 93 8e 05 	sts	0x058E, r24
		deleteCredit = false;
    26a2:	10 92 97 05 	sts	0x0597, r1
		//putString("deletedCredit");
		eventOccuredRFID=nilEvent;
    26a6:	10 92 8d 05 	sts	0x058D, r1
    26aa:	08 95       	ret
		
	}else{
		eventOccuredRFID=nilEvent;
    26ac:	10 92 8d 05 	sts	0x058D, r1
    26b0:	08 95       	ret

000026b2 <SPIinit>:
void SPIinit(void)
Initializes SPI.
-----------------------------------------------------*/
void SPIinit(void)
{
	DDRB = (1<<PB4) | (1<<PB5) | (1<<PB7);								// Set MOSI , SCK , and SS output
    26b2:	80 eb       	ldi	r24, 0xB0	; 176
    26b4:	87 bb       	out	0x17, r24	; 23
	SPCR = (1<<SPE) | (1<<MSTR) | (1<<SPR1) | (1<<SPI2X);				// Enable , SPI itself, Master, set clock rate fck/32
    26b6:	83 e5       	ldi	r24, 0x53	; 83
    26b8:	8d b9       	out	0x0d, r24	; 13
    26ba:	08 95       	ret

000026bc <SPItransmit>:
void SPItransmit(unsigned char byte)
Shifts a byte through SPI.
-----------------------------------------------------*/
void SPItransmit(unsigned char byte)
{
	SPDR = byte;					//Load byte to Data register
    26bc:	8f b9       	out	0x0f, r24	; 15
	while(!(SPSR & (1<<SPIF))); 	// Wait for transmission complete
    26be:	77 9b       	sbis	0x0e, 7	; 14
    26c0:	fe cf       	rjmp	.-4      	; 0x26be <SPItransmit+0x2>
}
    26c2:	08 95       	ret

000026c4 <init_timer1>:
If flagB is set to 1, timer 0 is enabled else timer 1 compareB
interrupt is disabled.
-----------------------------------------------------*/
void init_timer1(char flagA, char flagB){
	
	TCCR1A=(0<<COM1A1)|(0<<COM1B1)|(0<<COM1A0)|(0<<WGM11)|(0<<WGM10);   //enable timer1 out for simulation of pedal speed - phase and frequency correct mode
    26c4:	1f bc       	out	0x2f, r1	; 47
	TCCR1B=(1<<WGM10)|(3<<CS10); /*prescaling by 64 - 1250000 Hz*/ // (1<<WGM12) CTC
    26c6:	93 e0       	ldi	r25, 0x03	; 3
    26c8:	9e bd       	out	0x2e, r25	; 46

	OCR1A=0x04E2;  //04E2gives 1 msec compare og 30D4 gives 10ms 
    26ca:	22 ee       	ldi	r18, 0xE2	; 226
    26cc:	34 e0       	ldi	r19, 0x04	; 4
    26ce:	3b bd       	out	0x2b, r19	; 43
    26d0:	2a bd       	out	0x2a, r18	; 42
	TCCR1A=0x0000;
    26d2:	1f bc       	out	0x2f, r1	; 47
	if (flagA==1)
    26d4:	81 30       	cpi	r24, 0x01	; 1
    26d6:	21 f4       	brne	.+8      	; 0x26e0 <init_timer1+0x1c>
		TIMSK|=(1<<OCIE1A);   //enable timer 1 and disable timer 0 compare interrupt
    26d8:	89 b7       	in	r24, 0x39	; 57
    26da:	80 61       	ori	r24, 0x10	; 16
    26dc:	89 bf       	out	0x39, r24	; 57
    26de:	03 c0       	rjmp	.+6      	; 0x26e6 <init_timer1+0x22>
	else
		TIMSK&=~(1<<OCIE1A);
    26e0:	89 b7       	in	r24, 0x39	; 57
    26e2:	8f 7e       	andi	r24, 0xEF	; 239
    26e4:	89 bf       	out	0x39, r24	; 57

	if (flagB==1) {
    26e6:	61 30       	cpi	r22, 0x01	; 1
    26e8:	41 f4       	brne	.+16     	; 0x26fa <init_timer1+0x36>
		TIMSK|=(1<<OCIE1B);   //enable timer 1 and disable timer 0 compare interrupt
    26ea:	89 b7       	in	r24, 0x39	; 57
    26ec:	88 60       	ori	r24, 0x08	; 8
    26ee:	89 bf       	out	0x39, r24	; 57
		OCR1B =14375;  //count to 5 => 1 seconds - 1 ms is counted by compare A
    26f0:	87 e2       	ldi	r24, 0x27	; 39
    26f2:	98 e3       	ldi	r25, 0x38	; 56
    26f4:	99 bd       	out	0x29, r25	; 41
    26f6:	88 bd       	out	0x28, r24	; 40
    26f8:	08 95       	ret
	}
	else
	TIMSK&=~(1<<OCIE1B);
    26fa:	89 b7       	in	r24, 0x39	; 57
    26fc:	87 7f       	andi	r24, 0xF7	; 247
    26fe:	89 bf       	out	0x39, r24	; 57
    2700:	08 95       	ret

00002702 <__vector_7>:
ISR(TIMER1_COMPA_vect)
ISR timer1 compare interrupt that is executed every ms
and increments ms variable value.
-----------------------------------------------------*/
ISR(TIMER1_COMPA_vect)
{
    2702:	1f 92       	push	r1
    2704:	0f 92       	push	r0
    2706:	0f b6       	in	r0, 0x3f	; 63
    2708:	0f 92       	push	r0
    270a:	11 24       	eor	r1, r1
    270c:	8f 93       	push	r24
    270e:	9f 93       	push	r25
	timeOut++;
    2710:	80 91 a1 05 	lds	r24, 0x05A1
    2714:	90 91 a2 05 	lds	r25, 0x05A2
    2718:	01 96       	adiw	r24, 0x01	; 1
    271a:	90 93 a2 05 	sts	0x05A2, r25
    271e:	80 93 a1 05 	sts	0x05A1, r24
	ms++;
    2722:	80 91 a3 05 	lds	r24, 0x05A3
    2726:	8f 5f       	subi	r24, 0xFF	; 255
    2728:	80 93 a3 05 	sts	0x05A3, r24
}
    272c:	9f 91       	pop	r25
    272e:	8f 91       	pop	r24
    2730:	0f 90       	pop	r0
    2732:	0f be       	out	0x3f, r0	; 63
    2734:	0f 90       	pop	r0
    2736:	1f 90       	pop	r1
    2738:	18 95       	reti

0000273a <__vector_8>:
ISR(TIMER1_COMPB_vect)
ISR timer1 compare interrupt that is executed every s
and increments second variable value.
-----------------------------------------------------*/
ISR(TIMER1_COMPB_vect)
{
    273a:	1f 92       	push	r1
    273c:	0f 92       	push	r0
    273e:	0f b6       	in	r0, 0x3f	; 63
    2740:	0f 92       	push	r0
    2742:	11 24       	eor	r1, r1
    2744:	8f 93       	push	r24
	second++;
    2746:	80 91 a0 05 	lds	r24, 0x05A0
    274a:	8f 5f       	subi	r24, 0xFF	; 255
    274c:	80 93 a0 05 	sts	0x05A0, r24
}
    2750:	8f 91       	pop	r24
    2752:	0f 90       	pop	r0
    2754:	0f be       	out	0x3f, r0	; 63
    2756:	0f 90       	pop	r0
    2758:	1f 90       	pop	r1
    275a:	18 95       	reti

0000275c <transmitUSART>:
to UDR register. Sends data byte.
-----------------------------------------------------*/
void transmitUSART( char data)
{
	/* Wait for data to be transmitted */
	while ( !(UCSRA & (1<<UDRE)));
    275c:	5d 9b       	sbis	0x0b, 5	; 11
    275e:	fe cf       	rjmp	.-4      	; 0x275c <transmitUSART>

	UDR = data;
    2760:	8c b9       	out	0x0c, r24	; 12
    2762:	08 95       	ret

00002764 <sendStringUSART>:
void sendStringUSART (char *s)
Sends a string through USART. Shifts bytes of array
passed by *s pointer until terminator.
-----------------------------------------------------*/
void sendStringUSART (char *s)
{
    2764:	cf 93       	push	r28
    2766:	df 93       	push	r29
    2768:	ec 01       	movw	r28, r24
	char c = 0;
	for (;(( c=*s)!=0);s++){
    276a:	88 81       	ld	r24, Y
    276c:	88 23       	and	r24, r24
    276e:	31 f0       	breq	.+12     	; 0x277c <sendStringUSART+0x18>
/* -----------------------------------------------------
void sendStringUSART (char *s)
Sends a string through USART. Shifts bytes of array
passed by *s pointer until terminator.
-----------------------------------------------------*/
void sendStringUSART (char *s)
    2770:	21 96       	adiw	r28, 0x01	; 1
{
	char c = 0;
	for (;(( c=*s)!=0);s++){
		transmitUSART(*s); 
    2772:	0e 94 ae 13 	call	0x275c	; 0x275c <transmitUSART>
passed by *s pointer until terminator.
-----------------------------------------------------*/
void sendStringUSART (char *s)
{
	char c = 0;
	for (;(( c=*s)!=0);s++){
    2776:	89 91       	ld	r24, Y+
    2778:	81 11       	cpse	r24, r1
    277a:	fb cf       	rjmp	.-10     	; 0x2772 <sendStringUSART+0xe>
		transmitUSART(*s); 
	}
}
    277c:	df 91       	pop	r29
    277e:	cf 91       	pop	r28
    2780:	08 95       	ret

00002782 <USART_Init>:
format: 1 stop bit, 8 data bits, no parity, full duplex.
Uses int baud parameter to set baud rate while casted.
-----------------------------------------------------*/
void USART_Init( unsigned int baud )
{
	UBRRH = (unsigned char)(baud>>8); 
    2782:	90 bd       	out	0x20, r25	; 32
	UBRRL = (unsigned char)baud;
    2784:	89 b9       	out	0x09, r24	; 9
	/* Enable receiver and transmitter */
	UCSRB|= (1<<RXEN)|(1<<TXEN)|(1<<RXCIE); 
    2786:	8a b1       	in	r24, 0x0a	; 10
    2788:	88 69       	ori	r24, 0x98	; 152
    278a:	8a b9       	out	0x0a, r24	; 10
	/* Set frame format:enable the UCSRC for writing 1 stop bit, 8 data bit */
	UCSRC|= (1<<URSEL)|(0<<USBS)|(3<<UCSZ0);     
    278c:	80 b5       	in	r24, 0x20	; 32
    278e:	86 68       	ori	r24, 0x86	; 134
    2790:	80 bd       	out	0x20, r24	; 32
	UCSRA =(1<<U2X);        //double speed full duplex
    2792:	82 e0       	ldi	r24, 0x02	; 2
    2794:	8b b9       	out	0x0b, r24	; 11
    2796:	08 95       	ret

00002798 <__subsf3>:
    2798:	50 58       	subi	r21, 0x80	; 128

0000279a <__addsf3>:
    279a:	bb 27       	eor	r27, r27
    279c:	aa 27       	eor	r26, r26
    279e:	0e d0       	rcall	.+28     	; 0x27bc <__addsf3x>
    27a0:	b1 c1       	rjmp	.+866    	; 0x2b04 <__fp_round>
    27a2:	a2 d1       	rcall	.+836    	; 0x2ae8 <__fp_pscA>
    27a4:	30 f0       	brcs	.+12     	; 0x27b2 <__addsf3+0x18>
    27a6:	a7 d1       	rcall	.+846    	; 0x2af6 <__fp_pscB>
    27a8:	20 f0       	brcs	.+8      	; 0x27b2 <__addsf3+0x18>
    27aa:	31 f4       	brne	.+12     	; 0x27b8 <__addsf3+0x1e>
    27ac:	9f 3f       	cpi	r25, 0xFF	; 255
    27ae:	11 f4       	brne	.+4      	; 0x27b4 <__addsf3+0x1a>
    27b0:	1e f4       	brtc	.+6      	; 0x27b8 <__addsf3+0x1e>
    27b2:	97 c1       	rjmp	.+814    	; 0x2ae2 <__fp_nan>
    27b4:	0e f4       	brtc	.+2      	; 0x27b8 <__addsf3+0x1e>
    27b6:	e0 95       	com	r30
    27b8:	e7 fb       	bst	r30, 7
    27ba:	64 c1       	rjmp	.+712    	; 0x2a84 <__fp_inf>

000027bc <__addsf3x>:
    27bc:	e9 2f       	mov	r30, r25
    27be:	b3 d1       	rcall	.+870    	; 0x2b26 <__fp_split3>
    27c0:	80 f3       	brcs	.-32     	; 0x27a2 <__addsf3+0x8>
    27c2:	ba 17       	cp	r27, r26
    27c4:	62 07       	cpc	r22, r18
    27c6:	73 07       	cpc	r23, r19
    27c8:	84 07       	cpc	r24, r20
    27ca:	95 07       	cpc	r25, r21
    27cc:	18 f0       	brcs	.+6      	; 0x27d4 <__addsf3x+0x18>
    27ce:	71 f4       	brne	.+28     	; 0x27ec <__addsf3x+0x30>
    27d0:	9e f5       	brtc	.+102    	; 0x2838 <__addsf3x+0x7c>
    27d2:	e2 c1       	rjmp	.+964    	; 0x2b98 <__fp_zero>
    27d4:	0e f4       	brtc	.+2      	; 0x27d8 <__addsf3x+0x1c>
    27d6:	e0 95       	com	r30
    27d8:	0b 2e       	mov	r0, r27
    27da:	ba 2f       	mov	r27, r26
    27dc:	a0 2d       	mov	r26, r0
    27de:	0b 01       	movw	r0, r22
    27e0:	b9 01       	movw	r22, r18
    27e2:	90 01       	movw	r18, r0
    27e4:	0c 01       	movw	r0, r24
    27e6:	ca 01       	movw	r24, r20
    27e8:	a0 01       	movw	r20, r0
    27ea:	11 24       	eor	r1, r1
    27ec:	ff 27       	eor	r31, r31
    27ee:	59 1b       	sub	r21, r25
    27f0:	99 f0       	breq	.+38     	; 0x2818 <__addsf3x+0x5c>
    27f2:	59 3f       	cpi	r21, 0xF9	; 249
    27f4:	50 f4       	brcc	.+20     	; 0x280a <__addsf3x+0x4e>
    27f6:	50 3e       	cpi	r21, 0xE0	; 224
    27f8:	68 f1       	brcs	.+90     	; 0x2854 <__addsf3x+0x98>
    27fa:	1a 16       	cp	r1, r26
    27fc:	f0 40       	sbci	r31, 0x00	; 0
    27fe:	a2 2f       	mov	r26, r18
    2800:	23 2f       	mov	r18, r19
    2802:	34 2f       	mov	r19, r20
    2804:	44 27       	eor	r20, r20
    2806:	58 5f       	subi	r21, 0xF8	; 248
    2808:	f3 cf       	rjmp	.-26     	; 0x27f0 <__addsf3x+0x34>
    280a:	46 95       	lsr	r20
    280c:	37 95       	ror	r19
    280e:	27 95       	ror	r18
    2810:	a7 95       	ror	r26
    2812:	f0 40       	sbci	r31, 0x00	; 0
    2814:	53 95       	inc	r21
    2816:	c9 f7       	brne	.-14     	; 0x280a <__addsf3x+0x4e>
    2818:	7e f4       	brtc	.+30     	; 0x2838 <__addsf3x+0x7c>
    281a:	1f 16       	cp	r1, r31
    281c:	ba 0b       	sbc	r27, r26
    281e:	62 0b       	sbc	r22, r18
    2820:	73 0b       	sbc	r23, r19
    2822:	84 0b       	sbc	r24, r20
    2824:	ba f0       	brmi	.+46     	; 0x2854 <__addsf3x+0x98>
    2826:	91 50       	subi	r25, 0x01	; 1
    2828:	a1 f0       	breq	.+40     	; 0x2852 <__addsf3x+0x96>
    282a:	ff 0f       	add	r31, r31
    282c:	bb 1f       	adc	r27, r27
    282e:	66 1f       	adc	r22, r22
    2830:	77 1f       	adc	r23, r23
    2832:	88 1f       	adc	r24, r24
    2834:	c2 f7       	brpl	.-16     	; 0x2826 <__addsf3x+0x6a>
    2836:	0e c0       	rjmp	.+28     	; 0x2854 <__addsf3x+0x98>
    2838:	ba 0f       	add	r27, r26
    283a:	62 1f       	adc	r22, r18
    283c:	73 1f       	adc	r23, r19
    283e:	84 1f       	adc	r24, r20
    2840:	48 f4       	brcc	.+18     	; 0x2854 <__addsf3x+0x98>
    2842:	87 95       	ror	r24
    2844:	77 95       	ror	r23
    2846:	67 95       	ror	r22
    2848:	b7 95       	ror	r27
    284a:	f7 95       	ror	r31
    284c:	9e 3f       	cpi	r25, 0xFE	; 254
    284e:	08 f0       	brcs	.+2      	; 0x2852 <__addsf3x+0x96>
    2850:	b3 cf       	rjmp	.-154    	; 0x27b8 <__addsf3+0x1e>
    2852:	93 95       	inc	r25
    2854:	88 0f       	add	r24, r24
    2856:	08 f0       	brcs	.+2      	; 0x285a <__addsf3x+0x9e>
    2858:	99 27       	eor	r25, r25
    285a:	ee 0f       	add	r30, r30
    285c:	97 95       	ror	r25
    285e:	87 95       	ror	r24
    2860:	08 95       	ret

00002862 <__cmpsf2>:
    2862:	ec d0       	rcall	.+472    	; 0x2a3c <__fp_cmp>
    2864:	08 f4       	brcc	.+2      	; 0x2868 <__cmpsf2+0x6>
    2866:	81 e0       	ldi	r24, 0x01	; 1
    2868:	08 95       	ret

0000286a <__divsf3>:
    286a:	0c d0       	rcall	.+24     	; 0x2884 <__divsf3x>
    286c:	4b c1       	rjmp	.+662    	; 0x2b04 <__fp_round>
    286e:	43 d1       	rcall	.+646    	; 0x2af6 <__fp_pscB>
    2870:	40 f0       	brcs	.+16     	; 0x2882 <__divsf3+0x18>
    2872:	3a d1       	rcall	.+628    	; 0x2ae8 <__fp_pscA>
    2874:	30 f0       	brcs	.+12     	; 0x2882 <__divsf3+0x18>
    2876:	21 f4       	brne	.+8      	; 0x2880 <__divsf3+0x16>
    2878:	5f 3f       	cpi	r21, 0xFF	; 255
    287a:	19 f0       	breq	.+6      	; 0x2882 <__divsf3+0x18>
    287c:	03 c1       	rjmp	.+518    	; 0x2a84 <__fp_inf>
    287e:	51 11       	cpse	r21, r1
    2880:	8c c1       	rjmp	.+792    	; 0x2b9a <__fp_szero>
    2882:	2f c1       	rjmp	.+606    	; 0x2ae2 <__fp_nan>

00002884 <__divsf3x>:
    2884:	50 d1       	rcall	.+672    	; 0x2b26 <__fp_split3>
    2886:	98 f3       	brcs	.-26     	; 0x286e <__divsf3+0x4>

00002888 <__divsf3_pse>:
    2888:	99 23       	and	r25, r25
    288a:	c9 f3       	breq	.-14     	; 0x287e <__divsf3+0x14>
    288c:	55 23       	and	r21, r21
    288e:	b1 f3       	breq	.-20     	; 0x287c <__divsf3+0x12>
    2890:	95 1b       	sub	r25, r21
    2892:	55 0b       	sbc	r21, r21
    2894:	bb 27       	eor	r27, r27
    2896:	aa 27       	eor	r26, r26
    2898:	62 17       	cp	r22, r18
    289a:	73 07       	cpc	r23, r19
    289c:	84 07       	cpc	r24, r20
    289e:	38 f0       	brcs	.+14     	; 0x28ae <__divsf3_pse+0x26>
    28a0:	9f 5f       	subi	r25, 0xFF	; 255
    28a2:	5f 4f       	sbci	r21, 0xFF	; 255
    28a4:	22 0f       	add	r18, r18
    28a6:	33 1f       	adc	r19, r19
    28a8:	44 1f       	adc	r20, r20
    28aa:	aa 1f       	adc	r26, r26
    28ac:	a9 f3       	breq	.-22     	; 0x2898 <__divsf3_pse+0x10>
    28ae:	33 d0       	rcall	.+102    	; 0x2916 <__divsf3_pse+0x8e>
    28b0:	0e 2e       	mov	r0, r30
    28b2:	3a f0       	brmi	.+14     	; 0x28c2 <__divsf3_pse+0x3a>
    28b4:	e0 e8       	ldi	r30, 0x80	; 128
    28b6:	30 d0       	rcall	.+96     	; 0x2918 <__divsf3_pse+0x90>
    28b8:	91 50       	subi	r25, 0x01	; 1
    28ba:	50 40       	sbci	r21, 0x00	; 0
    28bc:	e6 95       	lsr	r30
    28be:	00 1c       	adc	r0, r0
    28c0:	ca f7       	brpl	.-14     	; 0x28b4 <__divsf3_pse+0x2c>
    28c2:	29 d0       	rcall	.+82     	; 0x2916 <__divsf3_pse+0x8e>
    28c4:	fe 2f       	mov	r31, r30
    28c6:	27 d0       	rcall	.+78     	; 0x2916 <__divsf3_pse+0x8e>
    28c8:	66 0f       	add	r22, r22
    28ca:	77 1f       	adc	r23, r23
    28cc:	88 1f       	adc	r24, r24
    28ce:	bb 1f       	adc	r27, r27
    28d0:	26 17       	cp	r18, r22
    28d2:	37 07       	cpc	r19, r23
    28d4:	48 07       	cpc	r20, r24
    28d6:	ab 07       	cpc	r26, r27
    28d8:	b0 e8       	ldi	r27, 0x80	; 128
    28da:	09 f0       	breq	.+2      	; 0x28de <__divsf3_pse+0x56>
    28dc:	bb 0b       	sbc	r27, r27
    28de:	80 2d       	mov	r24, r0
    28e0:	bf 01       	movw	r22, r30
    28e2:	ff 27       	eor	r31, r31
    28e4:	93 58       	subi	r25, 0x83	; 131
    28e6:	5f 4f       	sbci	r21, 0xFF	; 255
    28e8:	2a f0       	brmi	.+10     	; 0x28f4 <__divsf3_pse+0x6c>
    28ea:	9e 3f       	cpi	r25, 0xFE	; 254
    28ec:	51 05       	cpc	r21, r1
    28ee:	68 f0       	brcs	.+26     	; 0x290a <__divsf3_pse+0x82>
    28f0:	c9 c0       	rjmp	.+402    	; 0x2a84 <__fp_inf>
    28f2:	53 c1       	rjmp	.+678    	; 0x2b9a <__fp_szero>
    28f4:	5f 3f       	cpi	r21, 0xFF	; 255
    28f6:	ec f3       	brlt	.-6      	; 0x28f2 <__divsf3_pse+0x6a>
    28f8:	98 3e       	cpi	r25, 0xE8	; 232
    28fa:	dc f3       	brlt	.-10     	; 0x28f2 <__divsf3_pse+0x6a>
    28fc:	86 95       	lsr	r24
    28fe:	77 95       	ror	r23
    2900:	67 95       	ror	r22
    2902:	b7 95       	ror	r27
    2904:	f7 95       	ror	r31
    2906:	9f 5f       	subi	r25, 0xFF	; 255
    2908:	c9 f7       	brne	.-14     	; 0x28fc <__divsf3_pse+0x74>
    290a:	88 0f       	add	r24, r24
    290c:	91 1d       	adc	r25, r1
    290e:	96 95       	lsr	r25
    2910:	87 95       	ror	r24
    2912:	97 f9       	bld	r25, 7
    2914:	08 95       	ret
    2916:	e1 e0       	ldi	r30, 0x01	; 1
    2918:	66 0f       	add	r22, r22
    291a:	77 1f       	adc	r23, r23
    291c:	88 1f       	adc	r24, r24
    291e:	bb 1f       	adc	r27, r27
    2920:	62 17       	cp	r22, r18
    2922:	73 07       	cpc	r23, r19
    2924:	84 07       	cpc	r24, r20
    2926:	ba 07       	cpc	r27, r26
    2928:	20 f0       	brcs	.+8      	; 0x2932 <__divsf3_pse+0xaa>
    292a:	62 1b       	sub	r22, r18
    292c:	73 0b       	sbc	r23, r19
    292e:	84 0b       	sbc	r24, r20
    2930:	ba 0b       	sbc	r27, r26
    2932:	ee 1f       	adc	r30, r30
    2934:	88 f7       	brcc	.-30     	; 0x2918 <__divsf3_pse+0x90>
    2936:	e0 95       	com	r30
    2938:	08 95       	ret

0000293a <__fixsfsi>:
    293a:	04 d0       	rcall	.+8      	; 0x2944 <__fixunssfsi>
    293c:	68 94       	set
    293e:	b1 11       	cpse	r27, r1
    2940:	2c c1       	rjmp	.+600    	; 0x2b9a <__fp_szero>
    2942:	08 95       	ret

00002944 <__fixunssfsi>:
    2944:	f8 d0       	rcall	.+496    	; 0x2b36 <__fp_splitA>
    2946:	88 f0       	brcs	.+34     	; 0x296a <__fixunssfsi+0x26>
    2948:	9f 57       	subi	r25, 0x7F	; 127
    294a:	90 f0       	brcs	.+36     	; 0x2970 <__fixunssfsi+0x2c>
    294c:	b9 2f       	mov	r27, r25
    294e:	99 27       	eor	r25, r25
    2950:	b7 51       	subi	r27, 0x17	; 23
    2952:	a0 f0       	brcs	.+40     	; 0x297c <__fixunssfsi+0x38>
    2954:	d1 f0       	breq	.+52     	; 0x298a <__fixunssfsi+0x46>
    2956:	66 0f       	add	r22, r22
    2958:	77 1f       	adc	r23, r23
    295a:	88 1f       	adc	r24, r24
    295c:	99 1f       	adc	r25, r25
    295e:	1a f0       	brmi	.+6      	; 0x2966 <__fixunssfsi+0x22>
    2960:	ba 95       	dec	r27
    2962:	c9 f7       	brne	.-14     	; 0x2956 <__fixunssfsi+0x12>
    2964:	12 c0       	rjmp	.+36     	; 0x298a <__fixunssfsi+0x46>
    2966:	b1 30       	cpi	r27, 0x01	; 1
    2968:	81 f0       	breq	.+32     	; 0x298a <__fixunssfsi+0x46>
    296a:	16 d1       	rcall	.+556    	; 0x2b98 <__fp_zero>
    296c:	b1 e0       	ldi	r27, 0x01	; 1
    296e:	08 95       	ret
    2970:	13 c1       	rjmp	.+550    	; 0x2b98 <__fp_zero>
    2972:	67 2f       	mov	r22, r23
    2974:	78 2f       	mov	r23, r24
    2976:	88 27       	eor	r24, r24
    2978:	b8 5f       	subi	r27, 0xF8	; 248
    297a:	39 f0       	breq	.+14     	; 0x298a <__fixunssfsi+0x46>
    297c:	b9 3f       	cpi	r27, 0xF9	; 249
    297e:	cc f3       	brlt	.-14     	; 0x2972 <__fixunssfsi+0x2e>
    2980:	86 95       	lsr	r24
    2982:	77 95       	ror	r23
    2984:	67 95       	ror	r22
    2986:	b3 95       	inc	r27
    2988:	d9 f7       	brne	.-10     	; 0x2980 <__fixunssfsi+0x3c>
    298a:	3e f4       	brtc	.+14     	; 0x299a <__fixunssfsi+0x56>
    298c:	90 95       	com	r25
    298e:	80 95       	com	r24
    2990:	70 95       	com	r23
    2992:	61 95       	neg	r22
    2994:	7f 4f       	sbci	r23, 0xFF	; 255
    2996:	8f 4f       	sbci	r24, 0xFF	; 255
    2998:	9f 4f       	sbci	r25, 0xFF	; 255
    299a:	08 95       	ret

0000299c <__floatunsisf>:
    299c:	e8 94       	clt
    299e:	09 c0       	rjmp	.+18     	; 0x29b2 <__floatsisf+0x12>

000029a0 <__floatsisf>:
    29a0:	97 fb       	bst	r25, 7
    29a2:	3e f4       	brtc	.+14     	; 0x29b2 <__floatsisf+0x12>
    29a4:	90 95       	com	r25
    29a6:	80 95       	com	r24
    29a8:	70 95       	com	r23
    29aa:	61 95       	neg	r22
    29ac:	7f 4f       	sbci	r23, 0xFF	; 255
    29ae:	8f 4f       	sbci	r24, 0xFF	; 255
    29b0:	9f 4f       	sbci	r25, 0xFF	; 255
    29b2:	99 23       	and	r25, r25
    29b4:	a9 f0       	breq	.+42     	; 0x29e0 <__floatsisf+0x40>
    29b6:	f9 2f       	mov	r31, r25
    29b8:	96 e9       	ldi	r25, 0x96	; 150
    29ba:	bb 27       	eor	r27, r27
    29bc:	93 95       	inc	r25
    29be:	f6 95       	lsr	r31
    29c0:	87 95       	ror	r24
    29c2:	77 95       	ror	r23
    29c4:	67 95       	ror	r22
    29c6:	b7 95       	ror	r27
    29c8:	f1 11       	cpse	r31, r1
    29ca:	f8 cf       	rjmp	.-16     	; 0x29bc <__floatsisf+0x1c>
    29cc:	fa f4       	brpl	.+62     	; 0x2a0c <__floatsisf+0x6c>
    29ce:	bb 0f       	add	r27, r27
    29d0:	11 f4       	brne	.+4      	; 0x29d6 <__floatsisf+0x36>
    29d2:	60 ff       	sbrs	r22, 0
    29d4:	1b c0       	rjmp	.+54     	; 0x2a0c <__floatsisf+0x6c>
    29d6:	6f 5f       	subi	r22, 0xFF	; 255
    29d8:	7f 4f       	sbci	r23, 0xFF	; 255
    29da:	8f 4f       	sbci	r24, 0xFF	; 255
    29dc:	9f 4f       	sbci	r25, 0xFF	; 255
    29de:	16 c0       	rjmp	.+44     	; 0x2a0c <__floatsisf+0x6c>
    29e0:	88 23       	and	r24, r24
    29e2:	11 f0       	breq	.+4      	; 0x29e8 <__floatsisf+0x48>
    29e4:	96 e9       	ldi	r25, 0x96	; 150
    29e6:	11 c0       	rjmp	.+34     	; 0x2a0a <__floatsisf+0x6a>
    29e8:	77 23       	and	r23, r23
    29ea:	21 f0       	breq	.+8      	; 0x29f4 <__floatsisf+0x54>
    29ec:	9e e8       	ldi	r25, 0x8E	; 142
    29ee:	87 2f       	mov	r24, r23
    29f0:	76 2f       	mov	r23, r22
    29f2:	05 c0       	rjmp	.+10     	; 0x29fe <__floatsisf+0x5e>
    29f4:	66 23       	and	r22, r22
    29f6:	71 f0       	breq	.+28     	; 0x2a14 <__floatsisf+0x74>
    29f8:	96 e8       	ldi	r25, 0x86	; 134
    29fa:	86 2f       	mov	r24, r22
    29fc:	70 e0       	ldi	r23, 0x00	; 0
    29fe:	60 e0       	ldi	r22, 0x00	; 0
    2a00:	2a f0       	brmi	.+10     	; 0x2a0c <__floatsisf+0x6c>
    2a02:	9a 95       	dec	r25
    2a04:	66 0f       	add	r22, r22
    2a06:	77 1f       	adc	r23, r23
    2a08:	88 1f       	adc	r24, r24
    2a0a:	da f7       	brpl	.-10     	; 0x2a02 <__floatsisf+0x62>
    2a0c:	88 0f       	add	r24, r24
    2a0e:	96 95       	lsr	r25
    2a10:	87 95       	ror	r24
    2a12:	97 f9       	bld	r25, 7
    2a14:	08 95       	ret

00002a16 <floor>:
    2a16:	a9 d0       	rcall	.+338    	; 0x2b6a <__fp_trunc>
    2a18:	80 f0       	brcs	.+32     	; 0x2a3a <floor+0x24>
    2a1a:	9f 37       	cpi	r25, 0x7F	; 127
    2a1c:	40 f4       	brcc	.+16     	; 0x2a2e <floor+0x18>
    2a1e:	91 11       	cpse	r25, r1
    2a20:	0e f0       	brts	.+2      	; 0x2a24 <floor+0xe>
    2a22:	bb c0       	rjmp	.+374    	; 0x2b9a <__fp_szero>
    2a24:	60 e0       	ldi	r22, 0x00	; 0
    2a26:	70 e0       	ldi	r23, 0x00	; 0
    2a28:	80 e8       	ldi	r24, 0x80	; 128
    2a2a:	9f eb       	ldi	r25, 0xBF	; 191
    2a2c:	08 95       	ret
    2a2e:	26 f4       	brtc	.+8      	; 0x2a38 <floor+0x22>
    2a30:	1b 16       	cp	r1, r27
    2a32:	61 1d       	adc	r22, r1
    2a34:	71 1d       	adc	r23, r1
    2a36:	81 1d       	adc	r24, r1
    2a38:	2b c0       	rjmp	.+86     	; 0x2a90 <__fp_mintl>
    2a3a:	45 c0       	rjmp	.+138    	; 0x2ac6 <__fp_mpack>

00002a3c <__fp_cmp>:
    2a3c:	99 0f       	add	r25, r25
    2a3e:	00 08       	sbc	r0, r0
    2a40:	55 0f       	add	r21, r21
    2a42:	aa 0b       	sbc	r26, r26
    2a44:	e0 e8       	ldi	r30, 0x80	; 128
    2a46:	fe ef       	ldi	r31, 0xFE	; 254
    2a48:	16 16       	cp	r1, r22
    2a4a:	17 06       	cpc	r1, r23
    2a4c:	e8 07       	cpc	r30, r24
    2a4e:	f9 07       	cpc	r31, r25
    2a50:	c0 f0       	brcs	.+48     	; 0x2a82 <__fp_cmp+0x46>
    2a52:	12 16       	cp	r1, r18
    2a54:	13 06       	cpc	r1, r19
    2a56:	e4 07       	cpc	r30, r20
    2a58:	f5 07       	cpc	r31, r21
    2a5a:	98 f0       	brcs	.+38     	; 0x2a82 <__fp_cmp+0x46>
    2a5c:	62 1b       	sub	r22, r18
    2a5e:	73 0b       	sbc	r23, r19
    2a60:	84 0b       	sbc	r24, r20
    2a62:	95 0b       	sbc	r25, r21
    2a64:	39 f4       	brne	.+14     	; 0x2a74 <__fp_cmp+0x38>
    2a66:	0a 26       	eor	r0, r26
    2a68:	61 f0       	breq	.+24     	; 0x2a82 <__fp_cmp+0x46>
    2a6a:	23 2b       	or	r18, r19
    2a6c:	24 2b       	or	r18, r20
    2a6e:	25 2b       	or	r18, r21
    2a70:	21 f4       	brne	.+8      	; 0x2a7a <__fp_cmp+0x3e>
    2a72:	08 95       	ret
    2a74:	0a 26       	eor	r0, r26
    2a76:	09 f4       	brne	.+2      	; 0x2a7a <__fp_cmp+0x3e>
    2a78:	a1 40       	sbci	r26, 0x01	; 1
    2a7a:	a6 95       	lsr	r26
    2a7c:	8f ef       	ldi	r24, 0xFF	; 255
    2a7e:	81 1d       	adc	r24, r1
    2a80:	81 1d       	adc	r24, r1
    2a82:	08 95       	ret

00002a84 <__fp_inf>:
    2a84:	97 f9       	bld	r25, 7
    2a86:	9f 67       	ori	r25, 0x7F	; 127
    2a88:	80 e8       	ldi	r24, 0x80	; 128
    2a8a:	70 e0       	ldi	r23, 0x00	; 0
    2a8c:	60 e0       	ldi	r22, 0x00	; 0
    2a8e:	08 95       	ret

00002a90 <__fp_mintl>:
    2a90:	88 23       	and	r24, r24
    2a92:	71 f4       	brne	.+28     	; 0x2ab0 <__fp_mintl+0x20>
    2a94:	77 23       	and	r23, r23
    2a96:	21 f0       	breq	.+8      	; 0x2aa0 <__fp_mintl+0x10>
    2a98:	98 50       	subi	r25, 0x08	; 8
    2a9a:	87 2b       	or	r24, r23
    2a9c:	76 2f       	mov	r23, r22
    2a9e:	07 c0       	rjmp	.+14     	; 0x2aae <__fp_mintl+0x1e>
    2aa0:	66 23       	and	r22, r22
    2aa2:	11 f4       	brne	.+4      	; 0x2aa8 <__fp_mintl+0x18>
    2aa4:	99 27       	eor	r25, r25
    2aa6:	0d c0       	rjmp	.+26     	; 0x2ac2 <__fp_mintl+0x32>
    2aa8:	90 51       	subi	r25, 0x10	; 16
    2aaa:	86 2b       	or	r24, r22
    2aac:	70 e0       	ldi	r23, 0x00	; 0
    2aae:	60 e0       	ldi	r22, 0x00	; 0
    2ab0:	2a f0       	brmi	.+10     	; 0x2abc <__fp_mintl+0x2c>
    2ab2:	9a 95       	dec	r25
    2ab4:	66 0f       	add	r22, r22
    2ab6:	77 1f       	adc	r23, r23
    2ab8:	88 1f       	adc	r24, r24
    2aba:	da f7       	brpl	.-10     	; 0x2ab2 <__fp_mintl+0x22>
    2abc:	88 0f       	add	r24, r24
    2abe:	96 95       	lsr	r25
    2ac0:	87 95       	ror	r24
    2ac2:	97 f9       	bld	r25, 7
    2ac4:	08 95       	ret

00002ac6 <__fp_mpack>:
    2ac6:	9f 3f       	cpi	r25, 0xFF	; 255
    2ac8:	31 f0       	breq	.+12     	; 0x2ad6 <__fp_mpack_finite+0xc>

00002aca <__fp_mpack_finite>:
    2aca:	91 50       	subi	r25, 0x01	; 1
    2acc:	20 f4       	brcc	.+8      	; 0x2ad6 <__fp_mpack_finite+0xc>
    2ace:	87 95       	ror	r24
    2ad0:	77 95       	ror	r23
    2ad2:	67 95       	ror	r22
    2ad4:	b7 95       	ror	r27
    2ad6:	88 0f       	add	r24, r24
    2ad8:	91 1d       	adc	r25, r1
    2ada:	96 95       	lsr	r25
    2adc:	87 95       	ror	r24
    2ade:	97 f9       	bld	r25, 7
    2ae0:	08 95       	ret

00002ae2 <__fp_nan>:
    2ae2:	9f ef       	ldi	r25, 0xFF	; 255
    2ae4:	80 ec       	ldi	r24, 0xC0	; 192
    2ae6:	08 95       	ret

00002ae8 <__fp_pscA>:
    2ae8:	00 24       	eor	r0, r0
    2aea:	0a 94       	dec	r0
    2aec:	16 16       	cp	r1, r22
    2aee:	17 06       	cpc	r1, r23
    2af0:	18 06       	cpc	r1, r24
    2af2:	09 06       	cpc	r0, r25
    2af4:	08 95       	ret

00002af6 <__fp_pscB>:
    2af6:	00 24       	eor	r0, r0
    2af8:	0a 94       	dec	r0
    2afa:	12 16       	cp	r1, r18
    2afc:	13 06       	cpc	r1, r19
    2afe:	14 06       	cpc	r1, r20
    2b00:	05 06       	cpc	r0, r21
    2b02:	08 95       	ret

00002b04 <__fp_round>:
    2b04:	09 2e       	mov	r0, r25
    2b06:	03 94       	inc	r0
    2b08:	00 0c       	add	r0, r0
    2b0a:	11 f4       	brne	.+4      	; 0x2b10 <__fp_round+0xc>
    2b0c:	88 23       	and	r24, r24
    2b0e:	52 f0       	brmi	.+20     	; 0x2b24 <__fp_round+0x20>
    2b10:	bb 0f       	add	r27, r27
    2b12:	40 f4       	brcc	.+16     	; 0x2b24 <__fp_round+0x20>
    2b14:	bf 2b       	or	r27, r31
    2b16:	11 f4       	brne	.+4      	; 0x2b1c <__fp_round+0x18>
    2b18:	60 ff       	sbrs	r22, 0
    2b1a:	04 c0       	rjmp	.+8      	; 0x2b24 <__fp_round+0x20>
    2b1c:	6f 5f       	subi	r22, 0xFF	; 255
    2b1e:	7f 4f       	sbci	r23, 0xFF	; 255
    2b20:	8f 4f       	sbci	r24, 0xFF	; 255
    2b22:	9f 4f       	sbci	r25, 0xFF	; 255
    2b24:	08 95       	ret

00002b26 <__fp_split3>:
    2b26:	57 fd       	sbrc	r21, 7
    2b28:	90 58       	subi	r25, 0x80	; 128
    2b2a:	44 0f       	add	r20, r20
    2b2c:	55 1f       	adc	r21, r21
    2b2e:	59 f0       	breq	.+22     	; 0x2b46 <__fp_splitA+0x10>
    2b30:	5f 3f       	cpi	r21, 0xFF	; 255
    2b32:	71 f0       	breq	.+28     	; 0x2b50 <__fp_splitA+0x1a>
    2b34:	47 95       	ror	r20

00002b36 <__fp_splitA>:
    2b36:	88 0f       	add	r24, r24
    2b38:	97 fb       	bst	r25, 7
    2b3a:	99 1f       	adc	r25, r25
    2b3c:	61 f0       	breq	.+24     	; 0x2b56 <__fp_splitA+0x20>
    2b3e:	9f 3f       	cpi	r25, 0xFF	; 255
    2b40:	79 f0       	breq	.+30     	; 0x2b60 <__fp_splitA+0x2a>
    2b42:	87 95       	ror	r24
    2b44:	08 95       	ret
    2b46:	12 16       	cp	r1, r18
    2b48:	13 06       	cpc	r1, r19
    2b4a:	14 06       	cpc	r1, r20
    2b4c:	55 1f       	adc	r21, r21
    2b4e:	f2 cf       	rjmp	.-28     	; 0x2b34 <__fp_split3+0xe>
    2b50:	46 95       	lsr	r20
    2b52:	f1 df       	rcall	.-30     	; 0x2b36 <__fp_splitA>
    2b54:	08 c0       	rjmp	.+16     	; 0x2b66 <__fp_splitA+0x30>
    2b56:	16 16       	cp	r1, r22
    2b58:	17 06       	cpc	r1, r23
    2b5a:	18 06       	cpc	r1, r24
    2b5c:	99 1f       	adc	r25, r25
    2b5e:	f1 cf       	rjmp	.-30     	; 0x2b42 <__fp_splitA+0xc>
    2b60:	86 95       	lsr	r24
    2b62:	71 05       	cpc	r23, r1
    2b64:	61 05       	cpc	r22, r1
    2b66:	08 94       	sec
    2b68:	08 95       	ret

00002b6a <__fp_trunc>:
    2b6a:	e5 df       	rcall	.-54     	; 0x2b36 <__fp_splitA>
    2b6c:	a0 f0       	brcs	.+40     	; 0x2b96 <__fp_trunc+0x2c>
    2b6e:	be e7       	ldi	r27, 0x7E	; 126
    2b70:	b9 17       	cp	r27, r25
    2b72:	88 f4       	brcc	.+34     	; 0x2b96 <__fp_trunc+0x2c>
    2b74:	bb 27       	eor	r27, r27
    2b76:	9f 38       	cpi	r25, 0x8F	; 143
    2b78:	60 f4       	brcc	.+24     	; 0x2b92 <__fp_trunc+0x28>
    2b7a:	16 16       	cp	r1, r22
    2b7c:	b1 1d       	adc	r27, r1
    2b7e:	67 2f       	mov	r22, r23
    2b80:	78 2f       	mov	r23, r24
    2b82:	88 27       	eor	r24, r24
    2b84:	98 5f       	subi	r25, 0xF8	; 248
    2b86:	f7 cf       	rjmp	.-18     	; 0x2b76 <__fp_trunc+0xc>
    2b88:	86 95       	lsr	r24
    2b8a:	77 95       	ror	r23
    2b8c:	67 95       	ror	r22
    2b8e:	b1 1d       	adc	r27, r1
    2b90:	93 95       	inc	r25
    2b92:	96 39       	cpi	r25, 0x96	; 150
    2b94:	c8 f3       	brcs	.-14     	; 0x2b88 <__fp_trunc+0x1e>
    2b96:	08 95       	ret

00002b98 <__fp_zero>:
    2b98:	e8 94       	clt

00002b9a <__fp_szero>:
    2b9a:	bb 27       	eor	r27, r27
    2b9c:	66 27       	eor	r22, r22
    2b9e:	77 27       	eor	r23, r23
    2ba0:	cb 01       	movw	r24, r22
    2ba2:	97 f9       	bld	r25, 7
    2ba4:	08 95       	ret

00002ba6 <__mulsf3>:
    2ba6:	0b d0       	rcall	.+22     	; 0x2bbe <__mulsf3x>
    2ba8:	ad cf       	rjmp	.-166    	; 0x2b04 <__fp_round>
    2baa:	9e df       	rcall	.-196    	; 0x2ae8 <__fp_pscA>
    2bac:	28 f0       	brcs	.+10     	; 0x2bb8 <__mulsf3+0x12>
    2bae:	a3 df       	rcall	.-186    	; 0x2af6 <__fp_pscB>
    2bb0:	18 f0       	brcs	.+6      	; 0x2bb8 <__mulsf3+0x12>
    2bb2:	95 23       	and	r25, r21
    2bb4:	09 f0       	breq	.+2      	; 0x2bb8 <__mulsf3+0x12>
    2bb6:	66 cf       	rjmp	.-308    	; 0x2a84 <__fp_inf>
    2bb8:	94 cf       	rjmp	.-216    	; 0x2ae2 <__fp_nan>
    2bba:	11 24       	eor	r1, r1
    2bbc:	ee cf       	rjmp	.-36     	; 0x2b9a <__fp_szero>

00002bbe <__mulsf3x>:
    2bbe:	b3 df       	rcall	.-154    	; 0x2b26 <__fp_split3>
    2bc0:	a0 f3       	brcs	.-24     	; 0x2baa <__mulsf3+0x4>

00002bc2 <__mulsf3_pse>:
    2bc2:	95 9f       	mul	r25, r21
    2bc4:	d1 f3       	breq	.-12     	; 0x2bba <__mulsf3+0x14>
    2bc6:	95 0f       	add	r25, r21
    2bc8:	50 e0       	ldi	r21, 0x00	; 0
    2bca:	55 1f       	adc	r21, r21
    2bcc:	62 9f       	mul	r22, r18
    2bce:	f0 01       	movw	r30, r0
    2bd0:	72 9f       	mul	r23, r18
    2bd2:	bb 27       	eor	r27, r27
    2bd4:	f0 0d       	add	r31, r0
    2bd6:	b1 1d       	adc	r27, r1
    2bd8:	63 9f       	mul	r22, r19
    2bda:	aa 27       	eor	r26, r26
    2bdc:	f0 0d       	add	r31, r0
    2bde:	b1 1d       	adc	r27, r1
    2be0:	aa 1f       	adc	r26, r26
    2be2:	64 9f       	mul	r22, r20
    2be4:	66 27       	eor	r22, r22
    2be6:	b0 0d       	add	r27, r0
    2be8:	a1 1d       	adc	r26, r1
    2bea:	66 1f       	adc	r22, r22
    2bec:	82 9f       	mul	r24, r18
    2bee:	22 27       	eor	r18, r18
    2bf0:	b0 0d       	add	r27, r0
    2bf2:	a1 1d       	adc	r26, r1
    2bf4:	62 1f       	adc	r22, r18
    2bf6:	73 9f       	mul	r23, r19
    2bf8:	b0 0d       	add	r27, r0
    2bfa:	a1 1d       	adc	r26, r1
    2bfc:	62 1f       	adc	r22, r18
    2bfe:	83 9f       	mul	r24, r19
    2c00:	a0 0d       	add	r26, r0
    2c02:	61 1d       	adc	r22, r1
    2c04:	22 1f       	adc	r18, r18
    2c06:	74 9f       	mul	r23, r20
    2c08:	33 27       	eor	r19, r19
    2c0a:	a0 0d       	add	r26, r0
    2c0c:	61 1d       	adc	r22, r1
    2c0e:	23 1f       	adc	r18, r19
    2c10:	84 9f       	mul	r24, r20
    2c12:	60 0d       	add	r22, r0
    2c14:	21 1d       	adc	r18, r1
    2c16:	82 2f       	mov	r24, r18
    2c18:	76 2f       	mov	r23, r22
    2c1a:	6a 2f       	mov	r22, r26
    2c1c:	11 24       	eor	r1, r1
    2c1e:	9f 57       	subi	r25, 0x7F	; 127
    2c20:	50 40       	sbci	r21, 0x00	; 0
    2c22:	8a f0       	brmi	.+34     	; 0x2c46 <__mulsf3_pse+0x84>
    2c24:	e1 f0       	breq	.+56     	; 0x2c5e <__mulsf3_pse+0x9c>
    2c26:	88 23       	and	r24, r24
    2c28:	4a f0       	brmi	.+18     	; 0x2c3c <__mulsf3_pse+0x7a>
    2c2a:	ee 0f       	add	r30, r30
    2c2c:	ff 1f       	adc	r31, r31
    2c2e:	bb 1f       	adc	r27, r27
    2c30:	66 1f       	adc	r22, r22
    2c32:	77 1f       	adc	r23, r23
    2c34:	88 1f       	adc	r24, r24
    2c36:	91 50       	subi	r25, 0x01	; 1
    2c38:	50 40       	sbci	r21, 0x00	; 0
    2c3a:	a9 f7       	brne	.-22     	; 0x2c26 <__mulsf3_pse+0x64>
    2c3c:	9e 3f       	cpi	r25, 0xFE	; 254
    2c3e:	51 05       	cpc	r21, r1
    2c40:	70 f0       	brcs	.+28     	; 0x2c5e <__mulsf3_pse+0x9c>
    2c42:	20 cf       	rjmp	.-448    	; 0x2a84 <__fp_inf>
    2c44:	aa cf       	rjmp	.-172    	; 0x2b9a <__fp_szero>
    2c46:	5f 3f       	cpi	r21, 0xFF	; 255
    2c48:	ec f3       	brlt	.-6      	; 0x2c44 <__mulsf3_pse+0x82>
    2c4a:	98 3e       	cpi	r25, 0xE8	; 232
    2c4c:	dc f3       	brlt	.-10     	; 0x2c44 <__mulsf3_pse+0x82>
    2c4e:	86 95       	lsr	r24
    2c50:	77 95       	ror	r23
    2c52:	67 95       	ror	r22
    2c54:	b7 95       	ror	r27
    2c56:	f7 95       	ror	r31
    2c58:	e7 95       	ror	r30
    2c5a:	9f 5f       	subi	r25, 0xFF	; 255
    2c5c:	c1 f7       	brne	.-16     	; 0x2c4e <__mulsf3_pse+0x8c>
    2c5e:	fe 2b       	or	r31, r30
    2c60:	88 0f       	add	r24, r24
    2c62:	91 1d       	adc	r25, r1
    2c64:	96 95       	lsr	r25
    2c66:	87 95       	ror	r24
    2c68:	97 f9       	bld	r25, 7
    2c6a:	08 95       	ret

00002c6c <vfprintf>:
    2c6c:	a2 e1       	ldi	r26, 0x12	; 18
    2c6e:	b0 e0       	ldi	r27, 0x00	; 0
    2c70:	ec e3       	ldi	r30, 0x3C	; 60
    2c72:	f6 e1       	ldi	r31, 0x16	; 22
    2c74:	0c 94 b8 19 	jmp	0x3370	; 0x3370 <__prologue_saves__>
    2c78:	7c 01       	movw	r14, r24
    2c7a:	1b 01       	movw	r2, r22
    2c7c:	6a 01       	movw	r12, r20
    2c7e:	fc 01       	movw	r30, r24
    2c80:	17 82       	std	Z+7, r1	; 0x07
    2c82:	16 82       	std	Z+6, r1	; 0x06
    2c84:	83 81       	ldd	r24, Z+3	; 0x03
    2c86:	81 fd       	sbrc	r24, 1
    2c88:	03 c0       	rjmp	.+6      	; 0x2c90 <vfprintf+0x24>
    2c8a:	6b c3       	rjmp	.+1750   	; 0x3362 <vfprintf+0x6f6>
    2c8c:	65 01       	movw	r12, r10
    2c8e:	05 c0       	rjmp	.+10     	; 0x2c9a <vfprintf+0x2e>
    2c90:	88 24       	eor	r8, r8
    2c92:	83 94       	inc	r8
    2c94:	91 2c       	mov	r9, r1
    2c96:	8c 0e       	add	r8, r28
    2c98:	9d 1e       	adc	r9, r29
    2c9a:	f7 01       	movw	r30, r14
    2c9c:	93 81       	ldd	r25, Z+3	; 0x03
    2c9e:	f1 01       	movw	r30, r2
    2ca0:	93 fd       	sbrc	r25, 3
    2ca2:	85 91       	lpm	r24, Z+
    2ca4:	93 ff       	sbrs	r25, 3
    2ca6:	81 91       	ld	r24, Z+
    2ca8:	1f 01       	movw	r2, r30
    2caa:	88 23       	and	r24, r24
    2cac:	09 f4       	brne	.+2      	; 0x2cb0 <vfprintf+0x44>
    2cae:	55 c3       	rjmp	.+1706   	; 0x335a <vfprintf+0x6ee>
    2cb0:	85 32       	cpi	r24, 0x25	; 37
    2cb2:	39 f4       	brne	.+14     	; 0x2cc2 <vfprintf+0x56>
    2cb4:	93 fd       	sbrc	r25, 3
    2cb6:	85 91       	lpm	r24, Z+
    2cb8:	93 ff       	sbrs	r25, 3
    2cba:	81 91       	ld	r24, Z+
    2cbc:	1f 01       	movw	r2, r30
    2cbe:	85 32       	cpi	r24, 0x25	; 37
    2cc0:	31 f4       	brne	.+12     	; 0x2cce <vfprintf+0x62>
    2cc2:	b7 01       	movw	r22, r14
    2cc4:	90 e0       	ldi	r25, 0x00	; 0
    2cc6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2cca:	56 01       	movw	r10, r12
    2ccc:	df cf       	rjmp	.-66     	; 0x2c8c <vfprintf+0x20>
    2cce:	71 2c       	mov	r7, r1
    2cd0:	61 2c       	mov	r6, r1
    2cd2:	20 e0       	ldi	r18, 0x00	; 0
    2cd4:	20 32       	cpi	r18, 0x20	; 32
    2cd6:	a8 f4       	brcc	.+42     	; 0x2d02 <vfprintf+0x96>
    2cd8:	8b 32       	cpi	r24, 0x2B	; 43
    2cda:	61 f0       	breq	.+24     	; 0x2cf4 <vfprintf+0x88>
    2cdc:	28 f4       	brcc	.+10     	; 0x2ce8 <vfprintf+0x7c>
    2cde:	80 32       	cpi	r24, 0x20	; 32
    2ce0:	51 f0       	breq	.+20     	; 0x2cf6 <vfprintf+0x8a>
    2ce2:	83 32       	cpi	r24, 0x23	; 35
    2ce4:	71 f4       	brne	.+28     	; 0x2d02 <vfprintf+0x96>
    2ce6:	0b c0       	rjmp	.+22     	; 0x2cfe <vfprintf+0x92>
    2ce8:	8d 32       	cpi	r24, 0x2D	; 45
    2cea:	39 f0       	breq	.+14     	; 0x2cfa <vfprintf+0x8e>
    2cec:	80 33       	cpi	r24, 0x30	; 48
    2cee:	49 f4       	brne	.+18     	; 0x2d02 <vfprintf+0x96>
    2cf0:	21 60       	ori	r18, 0x01	; 1
    2cf2:	28 c0       	rjmp	.+80     	; 0x2d44 <vfprintf+0xd8>
    2cf4:	22 60       	ori	r18, 0x02	; 2
    2cf6:	24 60       	ori	r18, 0x04	; 4
    2cf8:	25 c0       	rjmp	.+74     	; 0x2d44 <vfprintf+0xd8>
    2cfa:	28 60       	ori	r18, 0x08	; 8
    2cfc:	23 c0       	rjmp	.+70     	; 0x2d44 <vfprintf+0xd8>
    2cfe:	20 61       	ori	r18, 0x10	; 16
    2d00:	21 c0       	rjmp	.+66     	; 0x2d44 <vfprintf+0xd8>
    2d02:	27 fd       	sbrc	r18, 7
    2d04:	27 c0       	rjmp	.+78     	; 0x2d54 <vfprintf+0xe8>
    2d06:	38 2f       	mov	r19, r24
    2d08:	30 53       	subi	r19, 0x30	; 48
    2d0a:	3a 30       	cpi	r19, 0x0A	; 10
    2d0c:	78 f4       	brcc	.+30     	; 0x2d2c <vfprintf+0xc0>
    2d0e:	26 ff       	sbrs	r18, 6
    2d10:	06 c0       	rjmp	.+12     	; 0x2d1e <vfprintf+0xb2>
    2d12:	fa e0       	ldi	r31, 0x0A	; 10
    2d14:	7f 9e       	mul	r7, r31
    2d16:	30 0d       	add	r19, r0
    2d18:	11 24       	eor	r1, r1
    2d1a:	73 2e       	mov	r7, r19
    2d1c:	13 c0       	rjmp	.+38     	; 0x2d44 <vfprintf+0xd8>
    2d1e:	4a e0       	ldi	r20, 0x0A	; 10
    2d20:	64 9e       	mul	r6, r20
    2d22:	30 0d       	add	r19, r0
    2d24:	11 24       	eor	r1, r1
    2d26:	63 2e       	mov	r6, r19
    2d28:	20 62       	ori	r18, 0x20	; 32
    2d2a:	0c c0       	rjmp	.+24     	; 0x2d44 <vfprintf+0xd8>
    2d2c:	8e 32       	cpi	r24, 0x2E	; 46
    2d2e:	21 f4       	brne	.+8      	; 0x2d38 <vfprintf+0xcc>
    2d30:	26 fd       	sbrc	r18, 6
    2d32:	13 c3       	rjmp	.+1574   	; 0x335a <vfprintf+0x6ee>
    2d34:	20 64       	ori	r18, 0x40	; 64
    2d36:	06 c0       	rjmp	.+12     	; 0x2d44 <vfprintf+0xd8>
    2d38:	8c 36       	cpi	r24, 0x6C	; 108
    2d3a:	11 f4       	brne	.+4      	; 0x2d40 <vfprintf+0xd4>
    2d3c:	20 68       	ori	r18, 0x80	; 128
    2d3e:	02 c0       	rjmp	.+4      	; 0x2d44 <vfprintf+0xd8>
    2d40:	88 36       	cpi	r24, 0x68	; 104
    2d42:	41 f4       	brne	.+16     	; 0x2d54 <vfprintf+0xe8>
    2d44:	f1 01       	movw	r30, r2
    2d46:	93 fd       	sbrc	r25, 3
    2d48:	85 91       	lpm	r24, Z+
    2d4a:	93 ff       	sbrs	r25, 3
    2d4c:	81 91       	ld	r24, Z+
    2d4e:	1f 01       	movw	r2, r30
    2d50:	81 11       	cpse	r24, r1
    2d52:	c0 cf       	rjmp	.-128    	; 0x2cd4 <vfprintf+0x68>
    2d54:	98 2f       	mov	r25, r24
    2d56:	95 54       	subi	r25, 0x45	; 69
    2d58:	93 30       	cpi	r25, 0x03	; 3
    2d5a:	18 f4       	brcc	.+6      	; 0x2d62 <vfprintf+0xf6>
    2d5c:	20 61       	ori	r18, 0x10	; 16
    2d5e:	80 5e       	subi	r24, 0xE0	; 224
    2d60:	06 c0       	rjmp	.+12     	; 0x2d6e <vfprintf+0x102>
    2d62:	98 2f       	mov	r25, r24
    2d64:	95 56       	subi	r25, 0x65	; 101
    2d66:	93 30       	cpi	r25, 0x03	; 3
    2d68:	08 f0       	brcs	.+2      	; 0x2d6c <vfprintf+0x100>
    2d6a:	a4 c1       	rjmp	.+840    	; 0x30b4 <vfprintf+0x448>
    2d6c:	2f 7e       	andi	r18, 0xEF	; 239
    2d6e:	26 fd       	sbrc	r18, 6
    2d70:	02 c0       	rjmp	.+4      	; 0x2d76 <vfprintf+0x10a>
    2d72:	16 e0       	ldi	r17, 0x06	; 6
    2d74:	71 2e       	mov	r7, r17
    2d76:	bf e3       	ldi	r27, 0x3F	; 63
    2d78:	5b 2e       	mov	r5, r27
    2d7a:	52 22       	and	r5, r18
    2d7c:	85 36       	cpi	r24, 0x65	; 101
    2d7e:	19 f4       	brne	.+6      	; 0x2d86 <vfprintf+0x11a>
    2d80:	f0 e4       	ldi	r31, 0x40	; 64
    2d82:	5f 2a       	or	r5, r31
    2d84:	07 c0       	rjmp	.+14     	; 0x2d94 <vfprintf+0x128>
    2d86:	86 36       	cpi	r24, 0x66	; 102
    2d88:	19 f4       	brne	.+6      	; 0x2d90 <vfprintf+0x124>
    2d8a:	40 e8       	ldi	r20, 0x80	; 128
    2d8c:	54 2a       	or	r5, r20
    2d8e:	02 c0       	rjmp	.+4      	; 0x2d94 <vfprintf+0x128>
    2d90:	71 10       	cpse	r7, r1
    2d92:	7a 94       	dec	r7
    2d94:	57 fe       	sbrs	r5, 7
    2d96:	07 c0       	rjmp	.+14     	; 0x2da6 <vfprintf+0x13a>
    2d98:	5b e3       	ldi	r21, 0x3B	; 59
    2d9a:	57 15       	cp	r21, r7
    2d9c:	48 f0       	brcs	.+18     	; 0x2db0 <vfprintf+0x144>
    2d9e:	47 2c       	mov	r4, r7
    2da0:	43 94       	inc	r4
    2da2:	27 e0       	ldi	r18, 0x07	; 7
    2da4:	0d c0       	rjmp	.+26     	; 0x2dc0 <vfprintf+0x154>
    2da6:	87 e0       	ldi	r24, 0x07	; 7
    2da8:	87 15       	cp	r24, r7
    2daa:	30 f0       	brcs	.+12     	; 0x2db8 <vfprintf+0x14c>
    2dac:	27 2d       	mov	r18, r7
    2dae:	07 c0       	rjmp	.+14     	; 0x2dbe <vfprintf+0x152>
    2db0:	27 e0       	ldi	r18, 0x07	; 7
    2db2:	ac e3       	ldi	r26, 0x3C	; 60
    2db4:	4a 2e       	mov	r4, r26
    2db6:	04 c0       	rjmp	.+8      	; 0x2dc0 <vfprintf+0x154>
    2db8:	27 e0       	ldi	r18, 0x07	; 7
    2dba:	f7 e0       	ldi	r31, 0x07	; 7
    2dbc:	7f 2e       	mov	r7, r31
    2dbe:	41 2c       	mov	r4, r1
    2dc0:	56 01       	movw	r10, r12
    2dc2:	94 e0       	ldi	r25, 0x04	; 4
    2dc4:	a9 0e       	add	r10, r25
    2dc6:	b1 1c       	adc	r11, r1
    2dc8:	f6 01       	movw	r30, r12
    2dca:	60 81       	ld	r22, Z
    2dcc:	71 81       	ldd	r23, Z+1	; 0x01
    2dce:	82 81       	ldd	r24, Z+2	; 0x02
    2dd0:	93 81       	ldd	r25, Z+3	; 0x03
    2dd2:	04 2d       	mov	r16, r4
    2dd4:	a4 01       	movw	r20, r8
    2dd6:	0e 94 11 1a 	call	0x3422	; 0x3422 <__ftoa_engine>
    2dda:	8c 01       	movw	r16, r24
    2ddc:	49 81       	ldd	r20, Y+1	; 0x01
    2dde:	4c 87       	std	Y+12, r20	; 0x0c
    2de0:	40 ff       	sbrs	r20, 0
    2de2:	02 c0       	rjmp	.+4      	; 0x2de8 <vfprintf+0x17c>
    2de4:	43 ff       	sbrs	r20, 3
    2de6:	07 c0       	rjmp	.+14     	; 0x2df6 <vfprintf+0x18a>
    2de8:	51 fc       	sbrc	r5, 1
    2dea:	08 c0       	rjmp	.+16     	; 0x2dfc <vfprintf+0x190>
    2dec:	52 fe       	sbrs	r5, 2
    2dee:	09 c0       	rjmp	.+18     	; 0x2e02 <vfprintf+0x196>
    2df0:	e0 e2       	ldi	r30, 0x20	; 32
    2df2:	de 2e       	mov	r13, r30
    2df4:	07 c0       	rjmp	.+14     	; 0x2e04 <vfprintf+0x198>
    2df6:	7d e2       	ldi	r23, 0x2D	; 45
    2df8:	d7 2e       	mov	r13, r23
    2dfa:	04 c0       	rjmp	.+8      	; 0x2e04 <vfprintf+0x198>
    2dfc:	6b e2       	ldi	r22, 0x2B	; 43
    2dfe:	d6 2e       	mov	r13, r22
    2e00:	01 c0       	rjmp	.+2      	; 0x2e04 <vfprintf+0x198>
    2e02:	d1 2c       	mov	r13, r1
    2e04:	8c 85       	ldd	r24, Y+12	; 0x0c
    2e06:	8c 70       	andi	r24, 0x0C	; 12
    2e08:	a1 f1       	breq	.+104    	; 0x2e72 <vfprintf+0x206>
    2e0a:	dd 20       	and	r13, r13
    2e0c:	11 f0       	breq	.+4      	; 0x2e12 <vfprintf+0x1a6>
    2e0e:	84 e0       	ldi	r24, 0x04	; 4
    2e10:	01 c0       	rjmp	.+2      	; 0x2e14 <vfprintf+0x1a8>
    2e12:	83 e0       	ldi	r24, 0x03	; 3
    2e14:	86 15       	cp	r24, r6
    2e16:	10 f0       	brcs	.+4      	; 0x2e1c <vfprintf+0x1b0>
    2e18:	61 2c       	mov	r6, r1
    2e1a:	0b c0       	rjmp	.+22     	; 0x2e32 <vfprintf+0x1c6>
    2e1c:	68 1a       	sub	r6, r24
    2e1e:	53 fc       	sbrc	r5, 3
    2e20:	08 c0       	rjmp	.+16     	; 0x2e32 <vfprintf+0x1c6>
    2e22:	b7 01       	movw	r22, r14
    2e24:	80 e2       	ldi	r24, 0x20	; 32
    2e26:	90 e0       	ldi	r25, 0x00	; 0
    2e28:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2e2c:	6a 94       	dec	r6
    2e2e:	c9 f7       	brne	.-14     	; 0x2e22 <vfprintf+0x1b6>
    2e30:	f3 cf       	rjmp	.-26     	; 0x2e18 <vfprintf+0x1ac>
    2e32:	dd 20       	and	r13, r13
    2e34:	29 f0       	breq	.+10     	; 0x2e40 <vfprintf+0x1d4>
    2e36:	b7 01       	movw	r22, r14
    2e38:	8d 2d       	mov	r24, r13
    2e3a:	90 e0       	ldi	r25, 0x00	; 0
    2e3c:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2e40:	5c 85       	ldd	r21, Y+12	; 0x0c
    2e42:	53 fd       	sbrc	r21, 3
    2e44:	03 c0       	rjmp	.+6      	; 0x2e4c <vfprintf+0x1e0>
    2e46:	08 e5       	ldi	r16, 0x58	; 88
    2e48:	10 e0       	ldi	r17, 0x00	; 0
    2e4a:	0c c0       	rjmp	.+24     	; 0x2e64 <vfprintf+0x1f8>
    2e4c:	04 e5       	ldi	r16, 0x54	; 84
    2e4e:	10 e0       	ldi	r17, 0x00	; 0
    2e50:	09 c0       	rjmp	.+18     	; 0x2e64 <vfprintf+0x1f8>
    2e52:	51 10       	cpse	r5, r1
    2e54:	80 52       	subi	r24, 0x20	; 32
    2e56:	b7 01       	movw	r22, r14
    2e58:	90 e0       	ldi	r25, 0x00	; 0
    2e5a:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2e5e:	0f 5f       	subi	r16, 0xFF	; 255
    2e60:	1f 4f       	sbci	r17, 0xFF	; 255
    2e62:	02 c0       	rjmp	.+4      	; 0x2e68 <vfprintf+0x1fc>
    2e64:	80 e1       	ldi	r24, 0x10	; 16
    2e66:	58 22       	and	r5, r24
    2e68:	f8 01       	movw	r30, r16
    2e6a:	84 91       	lpm	r24, Z
    2e6c:	81 11       	cpse	r24, r1
    2e6e:	f1 cf       	rjmp	.-30     	; 0x2e52 <vfprintf+0x1e6>
    2e70:	71 c2       	rjmp	.+1250   	; 0x3354 <vfprintf+0x6e8>
    2e72:	57 fe       	sbrs	r5, 7
    2e74:	0e c0       	rjmp	.+28     	; 0x2e92 <vfprintf+0x226>
    2e76:	40 0e       	add	r4, r16
    2e78:	4c 85       	ldd	r20, Y+12	; 0x0c
    2e7a:	44 ff       	sbrs	r20, 4
    2e7c:	04 c0       	rjmp	.+8      	; 0x2e86 <vfprintf+0x21a>
    2e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    2e80:	81 33       	cpi	r24, 0x31	; 49
    2e82:	09 f4       	brne	.+2      	; 0x2e86 <vfprintf+0x21a>
    2e84:	4a 94       	dec	r4
    2e86:	14 14       	cp	r1, r4
    2e88:	4c f5       	brge	.+82     	; 0x2edc <vfprintf+0x270>
    2e8a:	58 e0       	ldi	r21, 0x08	; 8
    2e8c:	54 15       	cp	r21, r4
    2e8e:	48 f1       	brcs	.+82     	; 0x2ee2 <vfprintf+0x276>
    2e90:	2c c0       	rjmp	.+88     	; 0x2eea <vfprintf+0x27e>
    2e92:	56 fc       	sbrc	r5, 6
    2e94:	2a c0       	rjmp	.+84     	; 0x2eea <vfprintf+0x27e>
    2e96:	87 2d       	mov	r24, r7
    2e98:	90 e0       	ldi	r25, 0x00	; 0
    2e9a:	80 17       	cp	r24, r16
    2e9c:	91 07       	cpc	r25, r17
    2e9e:	44 f0       	brlt	.+16     	; 0x2eb0 <vfprintf+0x244>
    2ea0:	0c 3f       	cpi	r16, 0xFC	; 252
    2ea2:	8f ef       	ldi	r24, 0xFF	; 255
    2ea4:	18 07       	cpc	r17, r24
    2ea6:	24 f0       	brlt	.+8      	; 0x2eb0 <vfprintf+0x244>
    2ea8:	90 e8       	ldi	r25, 0x80	; 128
    2eaa:	59 2a       	or	r5, r25
    2eac:	01 c0       	rjmp	.+2      	; 0x2eb0 <vfprintf+0x244>
    2eae:	7a 94       	dec	r7
    2eb0:	77 20       	and	r7, r7
    2eb2:	49 f0       	breq	.+18     	; 0x2ec6 <vfprintf+0x25a>
    2eb4:	e2 e0       	ldi	r30, 0x02	; 2
    2eb6:	f0 e0       	ldi	r31, 0x00	; 0
    2eb8:	ec 0f       	add	r30, r28
    2eba:	fd 1f       	adc	r31, r29
    2ebc:	e7 0d       	add	r30, r7
    2ebe:	f1 1d       	adc	r31, r1
    2ec0:	80 81       	ld	r24, Z
    2ec2:	80 33       	cpi	r24, 0x30	; 48
    2ec4:	a1 f3       	breq	.-24     	; 0x2eae <vfprintf+0x242>
    2ec6:	57 fe       	sbrs	r5, 7
    2ec8:	10 c0       	rjmp	.+32     	; 0x2eea <vfprintf+0x27e>
    2eca:	47 2c       	mov	r4, r7
    2ecc:	43 94       	inc	r4
    2ece:	87 2d       	mov	r24, r7
    2ed0:	90 e0       	ldi	r25, 0x00	; 0
    2ed2:	08 17       	cp	r16, r24
    2ed4:	19 07       	cpc	r17, r25
    2ed6:	44 f4       	brge	.+16     	; 0x2ee8 <vfprintf+0x27c>
    2ed8:	70 1a       	sub	r7, r16
    2eda:	07 c0       	rjmp	.+14     	; 0x2eea <vfprintf+0x27e>
    2edc:	44 24       	eor	r4, r4
    2ede:	43 94       	inc	r4
    2ee0:	04 c0       	rjmp	.+8      	; 0x2eea <vfprintf+0x27e>
    2ee2:	58 e0       	ldi	r21, 0x08	; 8
    2ee4:	45 2e       	mov	r4, r21
    2ee6:	01 c0       	rjmp	.+2      	; 0x2eea <vfprintf+0x27e>
    2ee8:	71 2c       	mov	r7, r1
    2eea:	57 fe       	sbrs	r5, 7
    2eec:	07 c0       	rjmp	.+14     	; 0x2efc <vfprintf+0x290>
    2eee:	10 16       	cp	r1, r16
    2ef0:	11 06       	cpc	r1, r17
    2ef2:	3c f4       	brge	.+14     	; 0x2f02 <vfprintf+0x296>
    2ef4:	98 01       	movw	r18, r16
    2ef6:	2f 5f       	subi	r18, 0xFF	; 255
    2ef8:	3f 4f       	sbci	r19, 0xFF	; 255
    2efa:	05 c0       	rjmp	.+10     	; 0x2f06 <vfprintf+0x29a>
    2efc:	25 e0       	ldi	r18, 0x05	; 5
    2efe:	30 e0       	ldi	r19, 0x00	; 0
    2f00:	02 c0       	rjmp	.+4      	; 0x2f06 <vfprintf+0x29a>
    2f02:	21 e0       	ldi	r18, 0x01	; 1
    2f04:	30 e0       	ldi	r19, 0x00	; 0
    2f06:	dd 20       	and	r13, r13
    2f08:	11 f0       	breq	.+4      	; 0x2f0e <vfprintf+0x2a2>
    2f0a:	2f 5f       	subi	r18, 0xFF	; 255
    2f0c:	3f 4f       	sbci	r19, 0xFF	; 255
    2f0e:	77 20       	and	r7, r7
    2f10:	31 f0       	breq	.+12     	; 0x2f1e <vfprintf+0x2b2>
    2f12:	47 2d       	mov	r20, r7
    2f14:	50 e0       	ldi	r21, 0x00	; 0
    2f16:	4f 5f       	subi	r20, 0xFF	; 255
    2f18:	5f 4f       	sbci	r21, 0xFF	; 255
    2f1a:	24 0f       	add	r18, r20
    2f1c:	35 1f       	adc	r19, r21
    2f1e:	46 2d       	mov	r20, r6
    2f20:	50 e0       	ldi	r21, 0x00	; 0
    2f22:	24 17       	cp	r18, r20
    2f24:	35 07       	cpc	r19, r21
    2f26:	14 f4       	brge	.+4      	; 0x2f2c <vfprintf+0x2c0>
    2f28:	62 1a       	sub	r6, r18
    2f2a:	01 c0       	rjmp	.+2      	; 0x2f2e <vfprintf+0x2c2>
    2f2c:	61 2c       	mov	r6, r1
    2f2e:	85 2d       	mov	r24, r5
    2f30:	89 70       	andi	r24, 0x09	; 9
    2f32:	49 f4       	brne	.+18     	; 0x2f46 <vfprintf+0x2da>
    2f34:	06 c0       	rjmp	.+12     	; 0x2f42 <vfprintf+0x2d6>
    2f36:	b7 01       	movw	r22, r14
    2f38:	80 e2       	ldi	r24, 0x20	; 32
    2f3a:	90 e0       	ldi	r25, 0x00	; 0
    2f3c:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2f40:	6a 94       	dec	r6
    2f42:	61 10       	cpse	r6, r1
    2f44:	f8 cf       	rjmp	.-16     	; 0x2f36 <vfprintf+0x2ca>
    2f46:	dd 20       	and	r13, r13
    2f48:	29 f0       	breq	.+10     	; 0x2f54 <vfprintf+0x2e8>
    2f4a:	b7 01       	movw	r22, r14
    2f4c:	8d 2d       	mov	r24, r13
    2f4e:	90 e0       	ldi	r25, 0x00	; 0
    2f50:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2f54:	53 fc       	sbrc	r5, 3
    2f56:	09 c0       	rjmp	.+18     	; 0x2f6a <vfprintf+0x2fe>
    2f58:	06 c0       	rjmp	.+12     	; 0x2f66 <vfprintf+0x2fa>
    2f5a:	b7 01       	movw	r22, r14
    2f5c:	80 e3       	ldi	r24, 0x30	; 48
    2f5e:	90 e0       	ldi	r25, 0x00	; 0
    2f60:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2f64:	6a 94       	dec	r6
    2f66:	61 10       	cpse	r6, r1
    2f68:	f8 cf       	rjmp	.-16     	; 0x2f5a <vfprintf+0x2ee>
    2f6a:	57 fe       	sbrs	r5, 7
    2f6c:	56 c0       	rjmp	.+172    	; 0x301a <vfprintf+0x3ae>
    2f6e:	68 01       	movw	r12, r16
    2f70:	17 ff       	sbrs	r17, 7
    2f72:	02 c0       	rjmp	.+4      	; 0x2f78 <vfprintf+0x30c>
    2f74:	c1 2c       	mov	r12, r1
    2f76:	d1 2c       	mov	r13, r1
    2f78:	20 e0       	ldi	r18, 0x00	; 0
    2f7a:	30 e0       	ldi	r19, 0x00	; 0
    2f7c:	a8 01       	movw	r20, r16
    2f7e:	44 19       	sub	r20, r4
    2f80:	51 09       	sbc	r21, r1
    2f82:	5e 87       	std	Y+14, r21	; 0x0e
    2f84:	4d 87       	std	Y+13, r20	; 0x0d
    2f86:	28 01       	movw	r4, r16
    2f88:	4c 18       	sub	r4, r12
    2f8a:	5d 08       	sbc	r5, r13
    2f8c:	48 0c       	add	r4, r8
    2f8e:	59 1c       	adc	r5, r9
    2f90:	87 2d       	mov	r24, r7
    2f92:	90 e0       	ldi	r25, 0x00	; 0
    2f94:	44 27       	eor	r20, r20
    2f96:	55 27       	eor	r21, r21
    2f98:	48 1b       	sub	r20, r24
    2f9a:	59 0b       	sbc	r21, r25
    2f9c:	58 8b       	std	Y+16, r21	; 0x10
    2f9e:	4f 87       	std	Y+15, r20	; 0x0f
    2fa0:	5f ef       	ldi	r21, 0xFF	; 255
    2fa2:	c5 16       	cp	r12, r21
    2fa4:	d5 06       	cpc	r13, r21
    2fa6:	49 f4       	brne	.+18     	; 0x2fba <vfprintf+0x34e>
    2fa8:	b7 01       	movw	r22, r14
    2faa:	8e e2       	ldi	r24, 0x2E	; 46
    2fac:	90 e0       	ldi	r25, 0x00	; 0
    2fae:	2a 8b       	std	Y+18, r18	; 0x12
    2fb0:	39 8b       	std	Y+17, r19	; 0x11
    2fb2:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2fb6:	39 89       	ldd	r19, Y+17	; 0x11
    2fb8:	2a 89       	ldd	r18, Y+18	; 0x12
    2fba:	0c 15       	cp	r16, r12
    2fbc:	1d 05       	cpc	r17, r13
    2fbe:	54 f0       	brlt	.+20     	; 0x2fd4 <vfprintf+0x368>
    2fc0:	4d 85       	ldd	r20, Y+13	; 0x0d
    2fc2:	5e 85       	ldd	r21, Y+14	; 0x0e
    2fc4:	4c 15       	cp	r20, r12
    2fc6:	5d 05       	cpc	r21, r13
    2fc8:	2c f4       	brge	.+10     	; 0x2fd4 <vfprintf+0x368>
    2fca:	f2 01       	movw	r30, r4
    2fcc:	e2 0f       	add	r30, r18
    2fce:	f3 1f       	adc	r31, r19
    2fd0:	81 81       	ldd	r24, Z+1	; 0x01
    2fd2:	01 c0       	rjmp	.+2      	; 0x2fd6 <vfprintf+0x36a>
    2fd4:	80 e3       	ldi	r24, 0x30	; 48
    2fd6:	51 e0       	ldi	r21, 0x01	; 1
    2fd8:	c5 1a       	sub	r12, r21
    2fda:	d1 08       	sbc	r13, r1
    2fdc:	2f 5f       	subi	r18, 0xFF	; 255
    2fde:	3f 4f       	sbci	r19, 0xFF	; 255
    2fe0:	4f 85       	ldd	r20, Y+15	; 0x0f
    2fe2:	58 89       	ldd	r21, Y+16	; 0x10
    2fe4:	c4 16       	cp	r12, r20
    2fe6:	d5 06       	cpc	r13, r21
    2fe8:	4c f0       	brlt	.+18     	; 0x2ffc <vfprintf+0x390>
    2fea:	b7 01       	movw	r22, r14
    2fec:	90 e0       	ldi	r25, 0x00	; 0
    2fee:	2a 8b       	std	Y+18, r18	; 0x12
    2ff0:	39 8b       	std	Y+17, r19	; 0x11
    2ff2:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    2ff6:	2a 89       	ldd	r18, Y+18	; 0x12
    2ff8:	39 89       	ldd	r19, Y+17	; 0x11
    2ffa:	d2 cf       	rjmp	.-92     	; 0x2fa0 <vfprintf+0x334>
    2ffc:	c0 16       	cp	r12, r16
    2ffe:	d1 06       	cpc	r13, r17
    3000:	49 f4       	brne	.+18     	; 0x3014 <vfprintf+0x3a8>
    3002:	9a 81       	ldd	r25, Y+2	; 0x02
    3004:	96 33       	cpi	r25, 0x36	; 54
    3006:	28 f4       	brcc	.+10     	; 0x3012 <vfprintf+0x3a6>
    3008:	95 33       	cpi	r25, 0x35	; 53
    300a:	21 f4       	brne	.+8      	; 0x3014 <vfprintf+0x3a8>
    300c:	5c 85       	ldd	r21, Y+12	; 0x0c
    300e:	54 fd       	sbrc	r21, 4
    3010:	01 c0       	rjmp	.+2      	; 0x3014 <vfprintf+0x3a8>
    3012:	81 e3       	ldi	r24, 0x31	; 49
    3014:	b7 01       	movw	r22, r14
    3016:	90 e0       	ldi	r25, 0x00	; 0
    3018:	4a c0       	rjmp	.+148    	; 0x30ae <vfprintf+0x442>
    301a:	8a 81       	ldd	r24, Y+2	; 0x02
    301c:	81 33       	cpi	r24, 0x31	; 49
    301e:	19 f0       	breq	.+6      	; 0x3026 <vfprintf+0x3ba>
    3020:	4c 85       	ldd	r20, Y+12	; 0x0c
    3022:	4f 7e       	andi	r20, 0xEF	; 239
    3024:	4c 87       	std	Y+12, r20	; 0x0c
    3026:	b7 01       	movw	r22, r14
    3028:	90 e0       	ldi	r25, 0x00	; 0
    302a:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    302e:	71 10       	cpse	r7, r1
    3030:	05 c0       	rjmp	.+10     	; 0x303c <vfprintf+0x3d0>
    3032:	54 fe       	sbrs	r5, 4
    3034:	16 c0       	rjmp	.+44     	; 0x3062 <vfprintf+0x3f6>
    3036:	85 e4       	ldi	r24, 0x45	; 69
    3038:	90 e0       	ldi	r25, 0x00	; 0
    303a:	15 c0       	rjmp	.+42     	; 0x3066 <vfprintf+0x3fa>
    303c:	b7 01       	movw	r22, r14
    303e:	8e e2       	ldi	r24, 0x2E	; 46
    3040:	90 e0       	ldi	r25, 0x00	; 0
    3042:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    3046:	42 e0       	ldi	r20, 0x02	; 2
    3048:	d4 2e       	mov	r13, r20
    304a:	f4 01       	movw	r30, r8
    304c:	ed 0d       	add	r30, r13
    304e:	f1 1d       	adc	r31, r1
    3050:	d3 94       	inc	r13
    3052:	b7 01       	movw	r22, r14
    3054:	80 81       	ld	r24, Z
    3056:	90 e0       	ldi	r25, 0x00	; 0
    3058:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    305c:	7a 94       	dec	r7
    305e:	a9 f7       	brne	.-22     	; 0x304a <vfprintf+0x3de>
    3060:	e8 cf       	rjmp	.-48     	; 0x3032 <vfprintf+0x3c6>
    3062:	85 e6       	ldi	r24, 0x65	; 101
    3064:	90 e0       	ldi	r25, 0x00	; 0
    3066:	b7 01       	movw	r22, r14
    3068:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    306c:	17 fd       	sbrc	r17, 7
    306e:	06 c0       	rjmp	.+12     	; 0x307c <vfprintf+0x410>
    3070:	01 15       	cp	r16, r1
    3072:	11 05       	cpc	r17, r1
    3074:	41 f4       	brne	.+16     	; 0x3086 <vfprintf+0x41a>
    3076:	5c 85       	ldd	r21, Y+12	; 0x0c
    3078:	54 ff       	sbrs	r21, 4
    307a:	05 c0       	rjmp	.+10     	; 0x3086 <vfprintf+0x41a>
    307c:	11 95       	neg	r17
    307e:	01 95       	neg	r16
    3080:	11 09       	sbc	r17, r1
    3082:	8d e2       	ldi	r24, 0x2D	; 45
    3084:	01 c0       	rjmp	.+2      	; 0x3088 <vfprintf+0x41c>
    3086:	8b e2       	ldi	r24, 0x2B	; 43
    3088:	b7 01       	movw	r22, r14
    308a:	90 e0       	ldi	r25, 0x00	; 0
    308c:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    3090:	80 e3       	ldi	r24, 0x30	; 48
    3092:	03 c0       	rjmp	.+6      	; 0x309a <vfprintf+0x42e>
    3094:	8f 5f       	subi	r24, 0xFF	; 255
    3096:	0a 50       	subi	r16, 0x0A	; 10
    3098:	11 09       	sbc	r17, r1
    309a:	0a 30       	cpi	r16, 0x0A	; 10
    309c:	11 05       	cpc	r17, r1
    309e:	d4 f7       	brge	.-12     	; 0x3094 <vfprintf+0x428>
    30a0:	b7 01       	movw	r22, r14
    30a2:	90 e0       	ldi	r25, 0x00	; 0
    30a4:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    30a8:	b7 01       	movw	r22, r14
    30aa:	c8 01       	movw	r24, r16
    30ac:	c0 96       	adiw	r24, 0x30	; 48
    30ae:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    30b2:	50 c1       	rjmp	.+672    	; 0x3354 <vfprintf+0x6e8>
    30b4:	83 36       	cpi	r24, 0x63	; 99
    30b6:	31 f0       	breq	.+12     	; 0x30c4 <vfprintf+0x458>
    30b8:	83 37       	cpi	r24, 0x73	; 115
    30ba:	81 f0       	breq	.+32     	; 0x30dc <vfprintf+0x470>
    30bc:	83 35       	cpi	r24, 0x53	; 83
    30be:	09 f0       	breq	.+2      	; 0x30c2 <vfprintf+0x456>
    30c0:	5e c0       	rjmp	.+188    	; 0x317e <vfprintf+0x512>
    30c2:	24 c0       	rjmp	.+72     	; 0x310c <vfprintf+0x4a0>
    30c4:	56 01       	movw	r10, r12
    30c6:	82 e0       	ldi	r24, 0x02	; 2
    30c8:	a8 0e       	add	r10, r24
    30ca:	b1 1c       	adc	r11, r1
    30cc:	f6 01       	movw	r30, r12
    30ce:	80 81       	ld	r24, Z
    30d0:	89 83       	std	Y+1, r24	; 0x01
    30d2:	cc 24       	eor	r12, r12
    30d4:	c3 94       	inc	r12
    30d6:	d1 2c       	mov	r13, r1
    30d8:	84 01       	movw	r16, r8
    30da:	14 c0       	rjmp	.+40     	; 0x3104 <vfprintf+0x498>
    30dc:	56 01       	movw	r10, r12
    30de:	f2 e0       	ldi	r31, 0x02	; 2
    30e0:	af 0e       	add	r10, r31
    30e2:	b1 1c       	adc	r11, r1
    30e4:	f6 01       	movw	r30, r12
    30e6:	00 81       	ld	r16, Z
    30e8:	11 81       	ldd	r17, Z+1	; 0x01
    30ea:	26 ff       	sbrs	r18, 6
    30ec:	03 c0       	rjmp	.+6      	; 0x30f4 <vfprintf+0x488>
    30ee:	67 2d       	mov	r22, r7
    30f0:	70 e0       	ldi	r23, 0x00	; 0
    30f2:	02 c0       	rjmp	.+4      	; 0x30f8 <vfprintf+0x48c>
    30f4:	6f ef       	ldi	r22, 0xFF	; 255
    30f6:	7f ef       	ldi	r23, 0xFF	; 255
    30f8:	c8 01       	movw	r24, r16
    30fa:	2a 8b       	std	Y+18, r18	; 0x12
    30fc:	0e 94 04 1b 	call	0x3608	; 0x3608 <strnlen>
    3100:	6c 01       	movw	r12, r24
    3102:	2a 89       	ldd	r18, Y+18	; 0x12
    3104:	9f e7       	ldi	r25, 0x7F	; 127
    3106:	59 2e       	mov	r5, r25
    3108:	52 22       	and	r5, r18
    310a:	17 c0       	rjmp	.+46     	; 0x313a <vfprintf+0x4ce>
    310c:	56 01       	movw	r10, r12
    310e:	f2 e0       	ldi	r31, 0x02	; 2
    3110:	af 0e       	add	r10, r31
    3112:	b1 1c       	adc	r11, r1
    3114:	f6 01       	movw	r30, r12
    3116:	00 81       	ld	r16, Z
    3118:	11 81       	ldd	r17, Z+1	; 0x01
    311a:	26 ff       	sbrs	r18, 6
    311c:	03 c0       	rjmp	.+6      	; 0x3124 <vfprintf+0x4b8>
    311e:	67 2d       	mov	r22, r7
    3120:	70 e0       	ldi	r23, 0x00	; 0
    3122:	02 c0       	rjmp	.+4      	; 0x3128 <vfprintf+0x4bc>
    3124:	6f ef       	ldi	r22, 0xFF	; 255
    3126:	7f ef       	ldi	r23, 0xFF	; 255
    3128:	c8 01       	movw	r24, r16
    312a:	2a 8b       	std	Y+18, r18	; 0x12
    312c:	0e 94 e9 1a 	call	0x35d2	; 0x35d2 <strnlen_P>
    3130:	6c 01       	movw	r12, r24
    3132:	2a 89       	ldd	r18, Y+18	; 0x12
    3134:	80 e8       	ldi	r24, 0x80	; 128
    3136:	58 2e       	mov	r5, r24
    3138:	52 2a       	or	r5, r18
    313a:	53 fc       	sbrc	r5, 3
    313c:	1c c0       	rjmp	.+56     	; 0x3176 <vfprintf+0x50a>
    313e:	06 c0       	rjmp	.+12     	; 0x314c <vfprintf+0x4e0>
    3140:	b7 01       	movw	r22, r14
    3142:	80 e2       	ldi	r24, 0x20	; 32
    3144:	90 e0       	ldi	r25, 0x00	; 0
    3146:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    314a:	6a 94       	dec	r6
    314c:	86 2d       	mov	r24, r6
    314e:	90 e0       	ldi	r25, 0x00	; 0
    3150:	c8 16       	cp	r12, r24
    3152:	d9 06       	cpc	r13, r25
    3154:	a8 f3       	brcs	.-22     	; 0x3140 <vfprintf+0x4d4>
    3156:	0f c0       	rjmp	.+30     	; 0x3176 <vfprintf+0x50a>
    3158:	f8 01       	movw	r30, r16
    315a:	57 fc       	sbrc	r5, 7
    315c:	85 91       	lpm	r24, Z+
    315e:	57 fe       	sbrs	r5, 7
    3160:	81 91       	ld	r24, Z+
    3162:	8f 01       	movw	r16, r30
    3164:	b7 01       	movw	r22, r14
    3166:	90 e0       	ldi	r25, 0x00	; 0
    3168:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    316c:	61 10       	cpse	r6, r1
    316e:	6a 94       	dec	r6
    3170:	f1 e0       	ldi	r31, 0x01	; 1
    3172:	cf 1a       	sub	r12, r31
    3174:	d1 08       	sbc	r13, r1
    3176:	c1 14       	cp	r12, r1
    3178:	d1 04       	cpc	r13, r1
    317a:	71 f7       	brne	.-36     	; 0x3158 <vfprintf+0x4ec>
    317c:	eb c0       	rjmp	.+470    	; 0x3354 <vfprintf+0x6e8>
    317e:	84 36       	cpi	r24, 0x64	; 100
    3180:	11 f0       	breq	.+4      	; 0x3186 <vfprintf+0x51a>
    3182:	89 36       	cpi	r24, 0x69	; 105
    3184:	51 f5       	brne	.+84     	; 0x31da <vfprintf+0x56e>
    3186:	56 01       	movw	r10, r12
    3188:	27 ff       	sbrs	r18, 7
    318a:	09 c0       	rjmp	.+18     	; 0x319e <vfprintf+0x532>
    318c:	44 e0       	ldi	r20, 0x04	; 4
    318e:	a4 0e       	add	r10, r20
    3190:	b1 1c       	adc	r11, r1
    3192:	f6 01       	movw	r30, r12
    3194:	60 81       	ld	r22, Z
    3196:	71 81       	ldd	r23, Z+1	; 0x01
    3198:	82 81       	ldd	r24, Z+2	; 0x02
    319a:	93 81       	ldd	r25, Z+3	; 0x03
    319c:	0a c0       	rjmp	.+20     	; 0x31b2 <vfprintf+0x546>
    319e:	f2 e0       	ldi	r31, 0x02	; 2
    31a0:	af 0e       	add	r10, r31
    31a2:	b1 1c       	adc	r11, r1
    31a4:	f6 01       	movw	r30, r12
    31a6:	60 81       	ld	r22, Z
    31a8:	71 81       	ldd	r23, Z+1	; 0x01
    31aa:	88 27       	eor	r24, r24
    31ac:	77 fd       	sbrc	r23, 7
    31ae:	80 95       	com	r24
    31b0:	98 2f       	mov	r25, r24
    31b2:	12 2f       	mov	r17, r18
    31b4:	1f 76       	andi	r17, 0x6F	; 111
    31b6:	97 ff       	sbrs	r25, 7
    31b8:	08 c0       	rjmp	.+16     	; 0x31ca <vfprintf+0x55e>
    31ba:	90 95       	com	r25
    31bc:	80 95       	com	r24
    31be:	70 95       	com	r23
    31c0:	61 95       	neg	r22
    31c2:	7f 4f       	sbci	r23, 0xFF	; 255
    31c4:	8f 4f       	sbci	r24, 0xFF	; 255
    31c6:	9f 4f       	sbci	r25, 0xFF	; 255
    31c8:	10 68       	ori	r17, 0x80	; 128
    31ca:	2a e0       	ldi	r18, 0x0A	; 10
    31cc:	30 e0       	ldi	r19, 0x00	; 0
    31ce:	a4 01       	movw	r20, r8
    31d0:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <__ultoa_invert>
    31d4:	d8 2e       	mov	r13, r24
    31d6:	d8 18       	sub	r13, r8
    31d8:	40 c0       	rjmp	.+128    	; 0x325a <vfprintf+0x5ee>
    31da:	12 2f       	mov	r17, r18
    31dc:	85 37       	cpi	r24, 0x75	; 117
    31de:	21 f4       	brne	.+8      	; 0x31e8 <vfprintf+0x57c>
    31e0:	1f 7e       	andi	r17, 0xEF	; 239
    31e2:	2a e0       	ldi	r18, 0x0A	; 10
    31e4:	30 e0       	ldi	r19, 0x00	; 0
    31e6:	1f c0       	rjmp	.+62     	; 0x3226 <vfprintf+0x5ba>
    31e8:	19 7f       	andi	r17, 0xF9	; 249
    31ea:	8f 36       	cpi	r24, 0x6F	; 111
    31ec:	a1 f0       	breq	.+40     	; 0x3216 <vfprintf+0x5aa>
    31ee:	20 f4       	brcc	.+8      	; 0x31f8 <vfprintf+0x58c>
    31f0:	88 35       	cpi	r24, 0x58	; 88
    31f2:	09 f0       	breq	.+2      	; 0x31f6 <vfprintf+0x58a>
    31f4:	b2 c0       	rjmp	.+356    	; 0x335a <vfprintf+0x6ee>
    31f6:	0b c0       	rjmp	.+22     	; 0x320e <vfprintf+0x5a2>
    31f8:	80 37       	cpi	r24, 0x70	; 112
    31fa:	21 f0       	breq	.+8      	; 0x3204 <vfprintf+0x598>
    31fc:	88 37       	cpi	r24, 0x78	; 120
    31fe:	09 f0       	breq	.+2      	; 0x3202 <vfprintf+0x596>
    3200:	ac c0       	rjmp	.+344    	; 0x335a <vfprintf+0x6ee>
    3202:	01 c0       	rjmp	.+2      	; 0x3206 <vfprintf+0x59a>
    3204:	10 61       	ori	r17, 0x10	; 16
    3206:	14 ff       	sbrs	r17, 4
    3208:	09 c0       	rjmp	.+18     	; 0x321c <vfprintf+0x5b0>
    320a:	14 60       	ori	r17, 0x04	; 4
    320c:	07 c0       	rjmp	.+14     	; 0x321c <vfprintf+0x5b0>
    320e:	24 ff       	sbrs	r18, 4
    3210:	08 c0       	rjmp	.+16     	; 0x3222 <vfprintf+0x5b6>
    3212:	16 60       	ori	r17, 0x06	; 6
    3214:	06 c0       	rjmp	.+12     	; 0x3222 <vfprintf+0x5b6>
    3216:	28 e0       	ldi	r18, 0x08	; 8
    3218:	30 e0       	ldi	r19, 0x00	; 0
    321a:	05 c0       	rjmp	.+10     	; 0x3226 <vfprintf+0x5ba>
    321c:	20 e1       	ldi	r18, 0x10	; 16
    321e:	30 e0       	ldi	r19, 0x00	; 0
    3220:	02 c0       	rjmp	.+4      	; 0x3226 <vfprintf+0x5ba>
    3222:	20 e1       	ldi	r18, 0x10	; 16
    3224:	32 e0       	ldi	r19, 0x02	; 2
    3226:	56 01       	movw	r10, r12
    3228:	17 ff       	sbrs	r17, 7
    322a:	09 c0       	rjmp	.+18     	; 0x323e <vfprintf+0x5d2>
    322c:	f4 e0       	ldi	r31, 0x04	; 4
    322e:	af 0e       	add	r10, r31
    3230:	b1 1c       	adc	r11, r1
    3232:	f6 01       	movw	r30, r12
    3234:	60 81       	ld	r22, Z
    3236:	71 81       	ldd	r23, Z+1	; 0x01
    3238:	82 81       	ldd	r24, Z+2	; 0x02
    323a:	93 81       	ldd	r25, Z+3	; 0x03
    323c:	08 c0       	rjmp	.+16     	; 0x324e <vfprintf+0x5e2>
    323e:	f2 e0       	ldi	r31, 0x02	; 2
    3240:	af 0e       	add	r10, r31
    3242:	b1 1c       	adc	r11, r1
    3244:	f6 01       	movw	r30, r12
    3246:	60 81       	ld	r22, Z
    3248:	71 81       	ldd	r23, Z+1	; 0x01
    324a:	80 e0       	ldi	r24, 0x00	; 0
    324c:	90 e0       	ldi	r25, 0x00	; 0
    324e:	a4 01       	movw	r20, r8
    3250:	0e 94 db 1b 	call	0x37b6	; 0x37b6 <__ultoa_invert>
    3254:	d8 2e       	mov	r13, r24
    3256:	d8 18       	sub	r13, r8
    3258:	1f 77       	andi	r17, 0x7F	; 127
    325a:	16 ff       	sbrs	r17, 6
    325c:	0b c0       	rjmp	.+22     	; 0x3274 <vfprintf+0x608>
    325e:	21 2f       	mov	r18, r17
    3260:	2e 7f       	andi	r18, 0xFE	; 254
    3262:	d7 14       	cp	r13, r7
    3264:	50 f4       	brcc	.+20     	; 0x327a <vfprintf+0x60e>
    3266:	14 ff       	sbrs	r17, 4
    3268:	0a c0       	rjmp	.+20     	; 0x327e <vfprintf+0x612>
    326a:	12 fd       	sbrc	r17, 2
    326c:	08 c0       	rjmp	.+16     	; 0x327e <vfprintf+0x612>
    326e:	21 2f       	mov	r18, r17
    3270:	2e 7e       	andi	r18, 0xEE	; 238
    3272:	05 c0       	rjmp	.+10     	; 0x327e <vfprintf+0x612>
    3274:	0d 2d       	mov	r16, r13
    3276:	21 2f       	mov	r18, r17
    3278:	03 c0       	rjmp	.+6      	; 0x3280 <vfprintf+0x614>
    327a:	0d 2d       	mov	r16, r13
    327c:	01 c0       	rjmp	.+2      	; 0x3280 <vfprintf+0x614>
    327e:	07 2d       	mov	r16, r7
    3280:	24 ff       	sbrs	r18, 4
    3282:	0c c0       	rjmp	.+24     	; 0x329c <vfprintf+0x630>
    3284:	fe 01       	movw	r30, r28
    3286:	ed 0d       	add	r30, r13
    3288:	f1 1d       	adc	r31, r1
    328a:	80 81       	ld	r24, Z
    328c:	80 33       	cpi	r24, 0x30	; 48
    328e:	11 f4       	brne	.+4      	; 0x3294 <vfprintf+0x628>
    3290:	29 7e       	andi	r18, 0xE9	; 233
    3292:	08 c0       	rjmp	.+16     	; 0x32a4 <vfprintf+0x638>
    3294:	22 ff       	sbrs	r18, 2
    3296:	05 c0       	rjmp	.+10     	; 0x32a2 <vfprintf+0x636>
    3298:	0e 5f       	subi	r16, 0xFE	; 254
    329a:	04 c0       	rjmp	.+8      	; 0x32a4 <vfprintf+0x638>
    329c:	82 2f       	mov	r24, r18
    329e:	86 78       	andi	r24, 0x86	; 134
    32a0:	09 f0       	breq	.+2      	; 0x32a4 <vfprintf+0x638>
    32a2:	0f 5f       	subi	r16, 0xFF	; 255
    32a4:	23 fd       	sbrc	r18, 3
    32a6:	14 c0       	rjmp	.+40     	; 0x32d0 <vfprintf+0x664>
    32a8:	20 ff       	sbrs	r18, 0
    32aa:	0f c0       	rjmp	.+30     	; 0x32ca <vfprintf+0x65e>
    32ac:	7d 2c       	mov	r7, r13
    32ae:	06 15       	cp	r16, r6
    32b0:	60 f4       	brcc	.+24     	; 0x32ca <vfprintf+0x65e>
    32b2:	76 0c       	add	r7, r6
    32b4:	70 1a       	sub	r7, r16
    32b6:	06 2d       	mov	r16, r6
    32b8:	08 c0       	rjmp	.+16     	; 0x32ca <vfprintf+0x65e>
    32ba:	b7 01       	movw	r22, r14
    32bc:	80 e2       	ldi	r24, 0x20	; 32
    32be:	90 e0       	ldi	r25, 0x00	; 0
    32c0:	2a 8b       	std	Y+18, r18	; 0x12
    32c2:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    32c6:	0f 5f       	subi	r16, 0xFF	; 255
    32c8:	2a 89       	ldd	r18, Y+18	; 0x12
    32ca:	06 15       	cp	r16, r6
    32cc:	b0 f3       	brcs	.-20     	; 0x32ba <vfprintf+0x64e>
    32ce:	04 c0       	rjmp	.+8      	; 0x32d8 <vfprintf+0x66c>
    32d0:	06 15       	cp	r16, r6
    32d2:	10 f4       	brcc	.+4      	; 0x32d8 <vfprintf+0x66c>
    32d4:	60 1a       	sub	r6, r16
    32d6:	01 c0       	rjmp	.+2      	; 0x32da <vfprintf+0x66e>
    32d8:	61 2c       	mov	r6, r1
    32da:	24 ff       	sbrs	r18, 4
    32dc:	12 c0       	rjmp	.+36     	; 0x3302 <vfprintf+0x696>
    32de:	b7 01       	movw	r22, r14
    32e0:	80 e3       	ldi	r24, 0x30	; 48
    32e2:	90 e0       	ldi	r25, 0x00	; 0
    32e4:	2a 8b       	std	Y+18, r18	; 0x12
    32e6:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    32ea:	2a 89       	ldd	r18, Y+18	; 0x12
    32ec:	22 ff       	sbrs	r18, 2
    32ee:	1e c0       	rjmp	.+60     	; 0x332c <vfprintf+0x6c0>
    32f0:	21 ff       	sbrs	r18, 1
    32f2:	03 c0       	rjmp	.+6      	; 0x32fa <vfprintf+0x68e>
    32f4:	88 e5       	ldi	r24, 0x58	; 88
    32f6:	90 e0       	ldi	r25, 0x00	; 0
    32f8:	02 c0       	rjmp	.+4      	; 0x32fe <vfprintf+0x692>
    32fa:	88 e7       	ldi	r24, 0x78	; 120
    32fc:	90 e0       	ldi	r25, 0x00	; 0
    32fe:	b7 01       	movw	r22, r14
    3300:	0c c0       	rjmp	.+24     	; 0x331a <vfprintf+0x6ae>
    3302:	82 2f       	mov	r24, r18
    3304:	86 78       	andi	r24, 0x86	; 134
    3306:	91 f0       	breq	.+36     	; 0x332c <vfprintf+0x6c0>
    3308:	21 fd       	sbrc	r18, 1
    330a:	02 c0       	rjmp	.+4      	; 0x3310 <vfprintf+0x6a4>
    330c:	80 e2       	ldi	r24, 0x20	; 32
    330e:	01 c0       	rjmp	.+2      	; 0x3312 <vfprintf+0x6a6>
    3310:	8b e2       	ldi	r24, 0x2B	; 43
    3312:	27 fd       	sbrc	r18, 7
    3314:	8d e2       	ldi	r24, 0x2D	; 45
    3316:	b7 01       	movw	r22, r14
    3318:	90 e0       	ldi	r25, 0x00	; 0
    331a:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    331e:	06 c0       	rjmp	.+12     	; 0x332c <vfprintf+0x6c0>
    3320:	b7 01       	movw	r22, r14
    3322:	80 e3       	ldi	r24, 0x30	; 48
    3324:	90 e0       	ldi	r25, 0x00	; 0
    3326:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    332a:	7a 94       	dec	r7
    332c:	d7 14       	cp	r13, r7
    332e:	c0 f3       	brcs	.-16     	; 0x3320 <vfprintf+0x6b4>
    3330:	da 94       	dec	r13
    3332:	f4 01       	movw	r30, r8
    3334:	ed 0d       	add	r30, r13
    3336:	f1 1d       	adc	r31, r1
    3338:	b7 01       	movw	r22, r14
    333a:	80 81       	ld	r24, Z
    333c:	90 e0       	ldi	r25, 0x00	; 0
    333e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    3342:	d1 10       	cpse	r13, r1
    3344:	f5 cf       	rjmp	.-22     	; 0x3330 <vfprintf+0x6c4>
    3346:	06 c0       	rjmp	.+12     	; 0x3354 <vfprintf+0x6e8>
    3348:	b7 01       	movw	r22, r14
    334a:	80 e2       	ldi	r24, 0x20	; 32
    334c:	90 e0       	ldi	r25, 0x00	; 0
    334e:	0e 94 5d 1b 	call	0x36ba	; 0x36ba <fputc>
    3352:	6a 94       	dec	r6
    3354:	61 10       	cpse	r6, r1
    3356:	f8 cf       	rjmp	.-16     	; 0x3348 <vfprintf+0x6dc>
    3358:	99 cc       	rjmp	.-1742   	; 0x2c8c <vfprintf+0x20>
    335a:	f7 01       	movw	r30, r14
    335c:	26 81       	ldd	r18, Z+6	; 0x06
    335e:	37 81       	ldd	r19, Z+7	; 0x07
    3360:	02 c0       	rjmp	.+4      	; 0x3366 <vfprintf+0x6fa>
    3362:	2f ef       	ldi	r18, 0xFF	; 255
    3364:	3f ef       	ldi	r19, 0xFF	; 255
    3366:	c9 01       	movw	r24, r18
    3368:	62 96       	adiw	r28, 0x12	; 18
    336a:	e2 e1       	ldi	r30, 0x12	; 18
    336c:	0c 94 d4 19 	jmp	0x33a8	; 0x33a8 <__epilogue_restores__>

00003370 <__prologue_saves__>:
    3370:	2f 92       	push	r2
    3372:	3f 92       	push	r3
    3374:	4f 92       	push	r4
    3376:	5f 92       	push	r5
    3378:	6f 92       	push	r6
    337a:	7f 92       	push	r7
    337c:	8f 92       	push	r8
    337e:	9f 92       	push	r9
    3380:	af 92       	push	r10
    3382:	bf 92       	push	r11
    3384:	cf 92       	push	r12
    3386:	df 92       	push	r13
    3388:	ef 92       	push	r14
    338a:	ff 92       	push	r15
    338c:	0f 93       	push	r16
    338e:	1f 93       	push	r17
    3390:	cf 93       	push	r28
    3392:	df 93       	push	r29
    3394:	cd b7       	in	r28, 0x3d	; 61
    3396:	de b7       	in	r29, 0x3e	; 62
    3398:	ca 1b       	sub	r28, r26
    339a:	db 0b       	sbc	r29, r27
    339c:	0f b6       	in	r0, 0x3f	; 63
    339e:	f8 94       	cli
    33a0:	de bf       	out	0x3e, r29	; 62
    33a2:	0f be       	out	0x3f, r0	; 63
    33a4:	cd bf       	out	0x3d, r28	; 61
    33a6:	09 94       	ijmp

000033a8 <__epilogue_restores__>:
    33a8:	2a 88       	ldd	r2, Y+18	; 0x12
    33aa:	39 88       	ldd	r3, Y+17	; 0x11
    33ac:	48 88       	ldd	r4, Y+16	; 0x10
    33ae:	5f 84       	ldd	r5, Y+15	; 0x0f
    33b0:	6e 84       	ldd	r6, Y+14	; 0x0e
    33b2:	7d 84       	ldd	r7, Y+13	; 0x0d
    33b4:	8c 84       	ldd	r8, Y+12	; 0x0c
    33b6:	9b 84       	ldd	r9, Y+11	; 0x0b
    33b8:	aa 84       	ldd	r10, Y+10	; 0x0a
    33ba:	b9 84       	ldd	r11, Y+9	; 0x09
    33bc:	c8 84       	ldd	r12, Y+8	; 0x08
    33be:	df 80       	ldd	r13, Y+7	; 0x07
    33c0:	ee 80       	ldd	r14, Y+6	; 0x06
    33c2:	fd 80       	ldd	r15, Y+5	; 0x05
    33c4:	0c 81       	ldd	r16, Y+4	; 0x04
    33c6:	1b 81       	ldd	r17, Y+3	; 0x03
    33c8:	aa 81       	ldd	r26, Y+2	; 0x02
    33ca:	b9 81       	ldd	r27, Y+1	; 0x01
    33cc:	ce 0f       	add	r28, r30
    33ce:	d1 1d       	adc	r29, r1
    33d0:	0f b6       	in	r0, 0x3f	; 63
    33d2:	f8 94       	cli
    33d4:	de bf       	out	0x3e, r29	; 62
    33d6:	0f be       	out	0x3f, r0	; 63
    33d8:	cd bf       	out	0x3d, r28	; 61
    33da:	ed 01       	movw	r28, r26
    33dc:	08 95       	ret

000033de <atof>:
    33de:	66 27       	eor	r22, r22
    33e0:	77 27       	eor	r23, r23
    33e2:	0c 94 39 1c 	jmp	0x3872	; 0x3872 <strtod>

000033e6 <atoi>:
    33e6:	fc 01       	movw	r30, r24
    33e8:	88 27       	eor	r24, r24
    33ea:	99 27       	eor	r25, r25
    33ec:	e8 94       	clt
    33ee:	21 91       	ld	r18, Z+
    33f0:	20 32       	cpi	r18, 0x20	; 32
    33f2:	e9 f3       	breq	.-6      	; 0x33ee <atoi+0x8>
    33f4:	29 30       	cpi	r18, 0x09	; 9
    33f6:	10 f0       	brcs	.+4      	; 0x33fc <atoi+0x16>
    33f8:	2e 30       	cpi	r18, 0x0E	; 14
    33fa:	c8 f3       	brcs	.-14     	; 0x33ee <atoi+0x8>
    33fc:	2b 32       	cpi	r18, 0x2B	; 43
    33fe:	41 f0       	breq	.+16     	; 0x3410 <atoi+0x2a>
    3400:	2d 32       	cpi	r18, 0x2D	; 45
    3402:	39 f4       	brne	.+14     	; 0x3412 <atoi+0x2c>
    3404:	68 94       	set
    3406:	04 c0       	rjmp	.+8      	; 0x3410 <atoi+0x2a>
    3408:	0e 94 30 1b 	call	0x3660	; 0x3660 <__mulhi_const_10>
    340c:	82 0f       	add	r24, r18
    340e:	91 1d       	adc	r25, r1
    3410:	21 91       	ld	r18, Z+
    3412:	20 53       	subi	r18, 0x30	; 48
    3414:	2a 30       	cpi	r18, 0x0A	; 10
    3416:	c0 f3       	brcs	.-16     	; 0x3408 <atoi+0x22>
    3418:	1e f4       	brtc	.+6      	; 0x3420 <atoi+0x3a>
    341a:	90 95       	com	r25
    341c:	81 95       	neg	r24
    341e:	9f 4f       	sbci	r25, 0xFF	; 255
    3420:	08 95       	ret

00003422 <__ftoa_engine>:
    3422:	28 30       	cpi	r18, 0x08	; 8
    3424:	08 f0       	brcs	.+2      	; 0x3428 <__ftoa_engine+0x6>
    3426:	27 e0       	ldi	r18, 0x07	; 7
    3428:	33 27       	eor	r19, r19
    342a:	da 01       	movw	r26, r20
    342c:	99 0f       	add	r25, r25
    342e:	31 1d       	adc	r19, r1
    3430:	87 fd       	sbrc	r24, 7
    3432:	91 60       	ori	r25, 0x01	; 1
    3434:	00 96       	adiw	r24, 0x00	; 0
    3436:	61 05       	cpc	r22, r1
    3438:	71 05       	cpc	r23, r1
    343a:	39 f4       	brne	.+14     	; 0x344a <__ftoa_engine+0x28>
    343c:	32 60       	ori	r19, 0x02	; 2
    343e:	2e 5f       	subi	r18, 0xFE	; 254
    3440:	3d 93       	st	X+, r19
    3442:	30 e3       	ldi	r19, 0x30	; 48
    3444:	2a 95       	dec	r18
    3446:	e1 f7       	brne	.-8      	; 0x3440 <__ftoa_engine+0x1e>
    3448:	08 95       	ret
    344a:	9f 3f       	cpi	r25, 0xFF	; 255
    344c:	30 f0       	brcs	.+12     	; 0x345a <__ftoa_engine+0x38>
    344e:	80 38       	cpi	r24, 0x80	; 128
    3450:	71 05       	cpc	r23, r1
    3452:	61 05       	cpc	r22, r1
    3454:	09 f0       	breq	.+2      	; 0x3458 <__ftoa_engine+0x36>
    3456:	3c 5f       	subi	r19, 0xFC	; 252
    3458:	3c 5f       	subi	r19, 0xFC	; 252
    345a:	3d 93       	st	X+, r19
    345c:	91 30       	cpi	r25, 0x01	; 1
    345e:	08 f0       	brcs	.+2      	; 0x3462 <__ftoa_engine+0x40>
    3460:	80 68       	ori	r24, 0x80	; 128
    3462:	91 1d       	adc	r25, r1
    3464:	df 93       	push	r29
    3466:	cf 93       	push	r28
    3468:	1f 93       	push	r17
    346a:	0f 93       	push	r16
    346c:	ff 92       	push	r15
    346e:	ef 92       	push	r14
    3470:	19 2f       	mov	r17, r25
    3472:	98 7f       	andi	r25, 0xF8	; 248
    3474:	96 95       	lsr	r25
    3476:	e9 2f       	mov	r30, r25
    3478:	96 95       	lsr	r25
    347a:	96 95       	lsr	r25
    347c:	e9 0f       	add	r30, r25
    347e:	ff 27       	eor	r31, r31
    3480:	ea 54       	subi	r30, 0x4A	; 74
    3482:	ff 4f       	sbci	r31, 0xFF	; 255
    3484:	99 27       	eor	r25, r25
    3486:	33 27       	eor	r19, r19
    3488:	ee 24       	eor	r14, r14
    348a:	ff 24       	eor	r15, r15
    348c:	a7 01       	movw	r20, r14
    348e:	e7 01       	movw	r28, r14
    3490:	05 90       	lpm	r0, Z+
    3492:	08 94       	sec
    3494:	07 94       	ror	r0
    3496:	28 f4       	brcc	.+10     	; 0x34a2 <__ftoa_engine+0x80>
    3498:	36 0f       	add	r19, r22
    349a:	e7 1e       	adc	r14, r23
    349c:	f8 1e       	adc	r15, r24
    349e:	49 1f       	adc	r20, r25
    34a0:	51 1d       	adc	r21, r1
    34a2:	66 0f       	add	r22, r22
    34a4:	77 1f       	adc	r23, r23
    34a6:	88 1f       	adc	r24, r24
    34a8:	99 1f       	adc	r25, r25
    34aa:	06 94       	lsr	r0
    34ac:	a1 f7       	brne	.-24     	; 0x3496 <__ftoa_engine+0x74>
    34ae:	05 90       	lpm	r0, Z+
    34b0:	07 94       	ror	r0
    34b2:	28 f4       	brcc	.+10     	; 0x34be <__ftoa_engine+0x9c>
    34b4:	e7 0e       	add	r14, r23
    34b6:	f8 1e       	adc	r15, r24
    34b8:	49 1f       	adc	r20, r25
    34ba:	56 1f       	adc	r21, r22
    34bc:	c1 1d       	adc	r28, r1
    34be:	77 0f       	add	r23, r23
    34c0:	88 1f       	adc	r24, r24
    34c2:	99 1f       	adc	r25, r25
    34c4:	66 1f       	adc	r22, r22
    34c6:	06 94       	lsr	r0
    34c8:	a1 f7       	brne	.-24     	; 0x34b2 <__ftoa_engine+0x90>
    34ca:	05 90       	lpm	r0, Z+
    34cc:	07 94       	ror	r0
    34ce:	28 f4       	brcc	.+10     	; 0x34da <__ftoa_engine+0xb8>
    34d0:	f8 0e       	add	r15, r24
    34d2:	49 1f       	adc	r20, r25
    34d4:	56 1f       	adc	r21, r22
    34d6:	c7 1f       	adc	r28, r23
    34d8:	d1 1d       	adc	r29, r1
    34da:	88 0f       	add	r24, r24
    34dc:	99 1f       	adc	r25, r25
    34de:	66 1f       	adc	r22, r22
    34e0:	77 1f       	adc	r23, r23
    34e2:	06 94       	lsr	r0
    34e4:	a1 f7       	brne	.-24     	; 0x34ce <__ftoa_engine+0xac>
    34e6:	05 90       	lpm	r0, Z+
    34e8:	07 94       	ror	r0
    34ea:	20 f4       	brcc	.+8      	; 0x34f4 <__ftoa_engine+0xd2>
    34ec:	49 0f       	add	r20, r25
    34ee:	56 1f       	adc	r21, r22
    34f0:	c7 1f       	adc	r28, r23
    34f2:	d8 1f       	adc	r29, r24
    34f4:	99 0f       	add	r25, r25
    34f6:	66 1f       	adc	r22, r22
    34f8:	77 1f       	adc	r23, r23
    34fa:	88 1f       	adc	r24, r24
    34fc:	06 94       	lsr	r0
    34fe:	a9 f7       	brne	.-22     	; 0x34ea <__ftoa_engine+0xc8>
    3500:	84 91       	lpm	r24, Z
    3502:	10 95       	com	r17
    3504:	17 70       	andi	r17, 0x07	; 7
    3506:	41 f0       	breq	.+16     	; 0x3518 <__ftoa_engine+0xf6>
    3508:	d6 95       	lsr	r29
    350a:	c7 95       	ror	r28
    350c:	57 95       	ror	r21
    350e:	47 95       	ror	r20
    3510:	f7 94       	ror	r15
    3512:	e7 94       	ror	r14
    3514:	1a 95       	dec	r17
    3516:	c1 f7       	brne	.-16     	; 0x3508 <__ftoa_engine+0xe6>
    3518:	ec e5       	ldi	r30, 0x5C	; 92
    351a:	f0 e0       	ldi	r31, 0x00	; 0
    351c:	68 94       	set
    351e:	15 90       	lpm	r1, Z+
    3520:	15 91       	lpm	r17, Z+
    3522:	35 91       	lpm	r19, Z+
    3524:	65 91       	lpm	r22, Z+
    3526:	95 91       	lpm	r25, Z+
    3528:	05 90       	lpm	r0, Z+
    352a:	7f e2       	ldi	r23, 0x2F	; 47
    352c:	73 95       	inc	r23
    352e:	e1 18       	sub	r14, r1
    3530:	f1 0a       	sbc	r15, r17
    3532:	43 0b       	sbc	r20, r19
    3534:	56 0b       	sbc	r21, r22
    3536:	c9 0b       	sbc	r28, r25
    3538:	d0 09       	sbc	r29, r0
    353a:	c0 f7       	brcc	.-16     	; 0x352c <__ftoa_engine+0x10a>
    353c:	e1 0c       	add	r14, r1
    353e:	f1 1e       	adc	r15, r17
    3540:	43 1f       	adc	r20, r19
    3542:	56 1f       	adc	r21, r22
    3544:	c9 1f       	adc	r28, r25
    3546:	d0 1d       	adc	r29, r0
    3548:	7e f4       	brtc	.+30     	; 0x3568 <__ftoa_engine+0x146>
    354a:	70 33       	cpi	r23, 0x30	; 48
    354c:	11 f4       	brne	.+4      	; 0x3552 <__ftoa_engine+0x130>
    354e:	8a 95       	dec	r24
    3550:	e6 cf       	rjmp	.-52     	; 0x351e <__ftoa_engine+0xfc>
    3552:	e8 94       	clt
    3554:	01 50       	subi	r16, 0x01	; 1
    3556:	30 f0       	brcs	.+12     	; 0x3564 <__ftoa_engine+0x142>
    3558:	08 0f       	add	r16, r24
    355a:	0a f4       	brpl	.+2      	; 0x355e <__ftoa_engine+0x13c>
    355c:	00 27       	eor	r16, r16
    355e:	02 17       	cp	r16, r18
    3560:	08 f4       	brcc	.+2      	; 0x3564 <__ftoa_engine+0x142>
    3562:	20 2f       	mov	r18, r16
    3564:	23 95       	inc	r18
    3566:	02 2f       	mov	r16, r18
    3568:	7a 33       	cpi	r23, 0x3A	; 58
    356a:	28 f0       	brcs	.+10     	; 0x3576 <__ftoa_engine+0x154>
    356c:	79 e3       	ldi	r23, 0x39	; 57
    356e:	7d 93       	st	X+, r23
    3570:	2a 95       	dec	r18
    3572:	e9 f7       	brne	.-6      	; 0x356e <__ftoa_engine+0x14c>
    3574:	10 c0       	rjmp	.+32     	; 0x3596 <__ftoa_engine+0x174>
    3576:	7d 93       	st	X+, r23
    3578:	2a 95       	dec	r18
    357a:	89 f6       	brne	.-94     	; 0x351e <__ftoa_engine+0xfc>
    357c:	06 94       	lsr	r0
    357e:	97 95       	ror	r25
    3580:	67 95       	ror	r22
    3582:	37 95       	ror	r19
    3584:	17 95       	ror	r17
    3586:	17 94       	ror	r1
    3588:	e1 18       	sub	r14, r1
    358a:	f1 0a       	sbc	r15, r17
    358c:	43 0b       	sbc	r20, r19
    358e:	56 0b       	sbc	r21, r22
    3590:	c9 0b       	sbc	r28, r25
    3592:	d0 09       	sbc	r29, r0
    3594:	98 f0       	brcs	.+38     	; 0x35bc <__ftoa_engine+0x19a>
    3596:	23 95       	inc	r18
    3598:	7e 91       	ld	r23, -X
    359a:	73 95       	inc	r23
    359c:	7a 33       	cpi	r23, 0x3A	; 58
    359e:	08 f0       	brcs	.+2      	; 0x35a2 <__ftoa_engine+0x180>
    35a0:	70 e3       	ldi	r23, 0x30	; 48
    35a2:	7c 93       	st	X, r23
    35a4:	20 13       	cpse	r18, r16
    35a6:	b8 f7       	brcc	.-18     	; 0x3596 <__ftoa_engine+0x174>
    35a8:	7e 91       	ld	r23, -X
    35aa:	70 61       	ori	r23, 0x10	; 16
    35ac:	7d 93       	st	X+, r23
    35ae:	30 f0       	brcs	.+12     	; 0x35bc <__ftoa_engine+0x19a>
    35b0:	83 95       	inc	r24
    35b2:	71 e3       	ldi	r23, 0x31	; 49
    35b4:	7d 93       	st	X+, r23
    35b6:	70 e3       	ldi	r23, 0x30	; 48
    35b8:	2a 95       	dec	r18
    35ba:	e1 f7       	brne	.-8      	; 0x35b4 <__ftoa_engine+0x192>
    35bc:	11 24       	eor	r1, r1
    35be:	ef 90       	pop	r14
    35c0:	ff 90       	pop	r15
    35c2:	0f 91       	pop	r16
    35c4:	1f 91       	pop	r17
    35c6:	cf 91       	pop	r28
    35c8:	df 91       	pop	r29
    35ca:	99 27       	eor	r25, r25
    35cc:	87 fd       	sbrc	r24, 7
    35ce:	90 95       	com	r25
    35d0:	08 95       	ret

000035d2 <strnlen_P>:
    35d2:	fc 01       	movw	r30, r24
    35d4:	05 90       	lpm	r0, Z+
    35d6:	61 50       	subi	r22, 0x01	; 1
    35d8:	70 40       	sbci	r23, 0x00	; 0
    35da:	01 10       	cpse	r0, r1
    35dc:	d8 f7       	brcc	.-10     	; 0x35d4 <strnlen_P+0x2>
    35de:	80 95       	com	r24
    35e0:	90 95       	com	r25
    35e2:	8e 0f       	add	r24, r30
    35e4:	9f 1f       	adc	r25, r31
    35e6:	08 95       	ret

000035e8 <memcpy>:
    35e8:	fb 01       	movw	r30, r22
    35ea:	dc 01       	movw	r26, r24
    35ec:	02 c0       	rjmp	.+4      	; 0x35f2 <memcpy+0xa>
    35ee:	01 90       	ld	r0, Z+
    35f0:	0d 92       	st	X+, r0
    35f2:	41 50       	subi	r20, 0x01	; 1
    35f4:	50 40       	sbci	r21, 0x00	; 0
    35f6:	d8 f7       	brcc	.-10     	; 0x35ee <memcpy+0x6>
    35f8:	08 95       	ret

000035fa <memset>:
    35fa:	dc 01       	movw	r26, r24
    35fc:	01 c0       	rjmp	.+2      	; 0x3600 <memset+0x6>
    35fe:	6d 93       	st	X+, r22
    3600:	41 50       	subi	r20, 0x01	; 1
    3602:	50 40       	sbci	r21, 0x00	; 0
    3604:	e0 f7       	brcc	.-8      	; 0x35fe <memset+0x4>
    3606:	08 95       	ret

00003608 <strnlen>:
    3608:	fc 01       	movw	r30, r24
    360a:	61 50       	subi	r22, 0x01	; 1
    360c:	70 40       	sbci	r23, 0x00	; 0
    360e:	01 90       	ld	r0, Z+
    3610:	01 10       	cpse	r0, r1
    3612:	d8 f7       	brcc	.-10     	; 0x360a <strnlen+0x2>
    3614:	80 95       	com	r24
    3616:	90 95       	com	r25
    3618:	8e 0f       	add	r24, r30
    361a:	9f 1f       	adc	r25, r31
    361c:	08 95       	ret

0000361e <itoa>:
    361e:	fb 01       	movw	r30, r22
    3620:	9f 01       	movw	r18, r30
    3622:	e8 94       	clt
    3624:	42 30       	cpi	r20, 0x02	; 2
    3626:	c4 f0       	brlt	.+48     	; 0x3658 <itoa+0x3a>
    3628:	45 32       	cpi	r20, 0x25	; 37
    362a:	b4 f4       	brge	.+44     	; 0x3658 <itoa+0x3a>
    362c:	4a 30       	cpi	r20, 0x0A	; 10
    362e:	29 f4       	brne	.+10     	; 0x363a <itoa+0x1c>
    3630:	97 fb       	bst	r25, 7
    3632:	1e f4       	brtc	.+6      	; 0x363a <itoa+0x1c>
    3634:	90 95       	com	r25
    3636:	81 95       	neg	r24
    3638:	9f 4f       	sbci	r25, 0xFF	; 255
    363a:	64 2f       	mov	r22, r20
    363c:	77 27       	eor	r23, r23
    363e:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <__udivmodhi4>
    3642:	80 5d       	subi	r24, 0xD0	; 208
    3644:	8a 33       	cpi	r24, 0x3A	; 58
    3646:	0c f0       	brlt	.+2      	; 0x364a <itoa+0x2c>
    3648:	89 5d       	subi	r24, 0xD9	; 217
    364a:	81 93       	st	Z+, r24
    364c:	cb 01       	movw	r24, r22
    364e:	00 97       	sbiw	r24, 0x00	; 0
    3650:	a1 f7       	brne	.-24     	; 0x363a <itoa+0x1c>
    3652:	16 f4       	brtc	.+4      	; 0x3658 <itoa+0x3a>
    3654:	5d e2       	ldi	r21, 0x2D	; 45
    3656:	51 93       	st	Z+, r21
    3658:	10 82       	st	Z, r1
    365a:	c9 01       	movw	r24, r18
    365c:	0c 94 a6 1d 	jmp	0x3b4c	; 0x3b4c <strrev>

00003660 <__mulhi_const_10>:
    3660:	7a e0       	ldi	r23, 0x0A	; 10
    3662:	97 9f       	mul	r25, r23
    3664:	90 2d       	mov	r25, r0
    3666:	87 9f       	mul	r24, r23
    3668:	80 2d       	mov	r24, r0
    366a:	91 0d       	add	r25, r1
    366c:	11 24       	eor	r1, r1
    366e:	08 95       	ret

00003670 <ultoa>:
    3670:	fa 01       	movw	r30, r20
    3672:	cf 93       	push	r28
    3674:	ff 93       	push	r31
    3676:	ef 93       	push	r30
    3678:	22 30       	cpi	r18, 0x02	; 2
    367a:	cc f0       	brlt	.+50     	; 0x36ae <ultoa+0x3e>
    367c:	25 32       	cpi	r18, 0x25	; 37
    367e:	bc f4       	brge	.+46     	; 0x36ae <ultoa+0x3e>
    3680:	c2 2f       	mov	r28, r18
    3682:	2c 2f       	mov	r18, r28
    3684:	33 27       	eor	r19, r19
    3686:	44 27       	eor	r20, r20
    3688:	55 27       	eor	r21, r21
    368a:	ff 93       	push	r31
    368c:	ef 93       	push	r30
    368e:	0e 94 cd 1d 	call	0x3b9a	; 0x3b9a <__udivmodsi4>
    3692:	ef 91       	pop	r30
    3694:	ff 91       	pop	r31
    3696:	60 5d       	subi	r22, 0xD0	; 208
    3698:	6a 33       	cpi	r22, 0x3A	; 58
    369a:	0c f0       	brlt	.+2      	; 0x369e <ultoa+0x2e>
    369c:	69 5d       	subi	r22, 0xD9	; 217
    369e:	61 93       	st	Z+, r22
    36a0:	b9 01       	movw	r22, r18
    36a2:	ca 01       	movw	r24, r20
    36a4:	60 50       	subi	r22, 0x00	; 0
    36a6:	70 40       	sbci	r23, 0x00	; 0
    36a8:	80 40       	sbci	r24, 0x00	; 0
    36aa:	90 40       	sbci	r25, 0x00	; 0
    36ac:	51 f7       	brne	.-44     	; 0x3682 <ultoa+0x12>
    36ae:	10 82       	st	Z, r1
    36b0:	8f 91       	pop	r24
    36b2:	9f 91       	pop	r25
    36b4:	cf 91       	pop	r28
    36b6:	0c 94 a6 1d 	jmp	0x3b4c	; 0x3b4c <strrev>

000036ba <fputc>:
    36ba:	0f 93       	push	r16
    36bc:	1f 93       	push	r17
    36be:	cf 93       	push	r28
    36c0:	df 93       	push	r29
    36c2:	8c 01       	movw	r16, r24
    36c4:	eb 01       	movw	r28, r22
    36c6:	8b 81       	ldd	r24, Y+3	; 0x03
    36c8:	81 fd       	sbrc	r24, 1
    36ca:	03 c0       	rjmp	.+6      	; 0x36d2 <fputc+0x18>
    36cc:	0f ef       	ldi	r16, 0xFF	; 255
    36ce:	1f ef       	ldi	r17, 0xFF	; 255
    36d0:	1a c0       	rjmp	.+52     	; 0x3706 <fputc+0x4c>
    36d2:	82 ff       	sbrs	r24, 2
    36d4:	0d c0       	rjmp	.+26     	; 0x36f0 <fputc+0x36>
    36d6:	2e 81       	ldd	r18, Y+6	; 0x06
    36d8:	3f 81       	ldd	r19, Y+7	; 0x07
    36da:	8c 81       	ldd	r24, Y+4	; 0x04
    36dc:	9d 81       	ldd	r25, Y+5	; 0x05
    36de:	28 17       	cp	r18, r24
    36e0:	39 07       	cpc	r19, r25
    36e2:	64 f4       	brge	.+24     	; 0x36fc <fputc+0x42>
    36e4:	e8 81       	ld	r30, Y
    36e6:	f9 81       	ldd	r31, Y+1	; 0x01
    36e8:	01 93       	st	Z+, r16
    36ea:	f9 83       	std	Y+1, r31	; 0x01
    36ec:	e8 83       	st	Y, r30
    36ee:	06 c0       	rjmp	.+12     	; 0x36fc <fputc+0x42>
    36f0:	e8 85       	ldd	r30, Y+8	; 0x08
    36f2:	f9 85       	ldd	r31, Y+9	; 0x09
    36f4:	80 2f       	mov	r24, r16
    36f6:	09 95       	icall
    36f8:	89 2b       	or	r24, r25
    36fa:	41 f7       	brne	.-48     	; 0x36cc <fputc+0x12>
    36fc:	8e 81       	ldd	r24, Y+6	; 0x06
    36fe:	9f 81       	ldd	r25, Y+7	; 0x07
    3700:	01 96       	adiw	r24, 0x01	; 1
    3702:	9f 83       	std	Y+7, r25	; 0x07
    3704:	8e 83       	std	Y+6, r24	; 0x06
    3706:	c8 01       	movw	r24, r16
    3708:	df 91       	pop	r29
    370a:	cf 91       	pop	r28
    370c:	1f 91       	pop	r17
    370e:	0f 91       	pop	r16
    3710:	08 95       	ret

00003712 <snprintf>:
    3712:	ae e0       	ldi	r26, 0x0E	; 14
    3714:	b0 e0       	ldi	r27, 0x00	; 0
    3716:	ef e8       	ldi	r30, 0x8F	; 143
    3718:	fb e1       	ldi	r31, 0x1B	; 27
    371a:	0c 94 c6 19 	jmp	0x338c	; 0x338c <__prologue_saves__+0x1c>
    371e:	0d 89       	ldd	r16, Y+21	; 0x15
    3720:	1e 89       	ldd	r17, Y+22	; 0x16
    3722:	8f 89       	ldd	r24, Y+23	; 0x17
    3724:	98 8d       	ldd	r25, Y+24	; 0x18
    3726:	26 e0       	ldi	r18, 0x06	; 6
    3728:	2c 83       	std	Y+4, r18	; 0x04
    372a:	1a 83       	std	Y+2, r17	; 0x02
    372c:	09 83       	std	Y+1, r16	; 0x01
    372e:	97 ff       	sbrs	r25, 7
    3730:	02 c0       	rjmp	.+4      	; 0x3736 <snprintf+0x24>
    3732:	80 e0       	ldi	r24, 0x00	; 0
    3734:	90 e8       	ldi	r25, 0x80	; 128
    3736:	01 97       	sbiw	r24, 0x01	; 1
    3738:	9e 83       	std	Y+6, r25	; 0x06
    373a:	8d 83       	std	Y+5, r24	; 0x05
    373c:	ce 01       	movw	r24, r28
    373e:	4b 96       	adiw	r24, 0x1b	; 27
    3740:	ac 01       	movw	r20, r24
    3742:	69 8d       	ldd	r22, Y+25	; 0x19
    3744:	7a 8d       	ldd	r23, Y+26	; 0x1a
    3746:	ce 01       	movw	r24, r28
    3748:	01 96       	adiw	r24, 0x01	; 1
    374a:	0e 94 36 16 	call	0x2c6c	; 0x2c6c <vfprintf>
    374e:	4d 81       	ldd	r20, Y+5	; 0x05
    3750:	5e 81       	ldd	r21, Y+6	; 0x06
    3752:	57 fd       	sbrc	r21, 7
    3754:	0a c0       	rjmp	.+20     	; 0x376a <snprintf+0x58>
    3756:	2f 81       	ldd	r18, Y+7	; 0x07
    3758:	38 85       	ldd	r19, Y+8	; 0x08
    375a:	42 17       	cp	r20, r18
    375c:	53 07       	cpc	r21, r19
    375e:	0c f4       	brge	.+2      	; 0x3762 <snprintf+0x50>
    3760:	9a 01       	movw	r18, r20
    3762:	f8 01       	movw	r30, r16
    3764:	e2 0f       	add	r30, r18
    3766:	f3 1f       	adc	r31, r19
    3768:	10 82       	st	Z, r1
    376a:	2e 96       	adiw	r28, 0x0e	; 14
    376c:	e4 e0       	ldi	r30, 0x04	; 4
    376e:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__epilogue_restores__+0x1c>

00003772 <sprintf>:
    3772:	ae e0       	ldi	r26, 0x0E	; 14
    3774:	b0 e0       	ldi	r27, 0x00	; 0
    3776:	ef eb       	ldi	r30, 0xBF	; 191
    3778:	fb e1       	ldi	r31, 0x1B	; 27
    377a:	0c 94 c6 19 	jmp	0x338c	; 0x338c <__prologue_saves__+0x1c>
    377e:	0d 89       	ldd	r16, Y+21	; 0x15
    3780:	1e 89       	ldd	r17, Y+22	; 0x16
    3782:	86 e0       	ldi	r24, 0x06	; 6
    3784:	8c 83       	std	Y+4, r24	; 0x04
    3786:	1a 83       	std	Y+2, r17	; 0x02
    3788:	09 83       	std	Y+1, r16	; 0x01
    378a:	8f ef       	ldi	r24, 0xFF	; 255
    378c:	9f e7       	ldi	r25, 0x7F	; 127
    378e:	9e 83       	std	Y+6, r25	; 0x06
    3790:	8d 83       	std	Y+5, r24	; 0x05
    3792:	ce 01       	movw	r24, r28
    3794:	49 96       	adiw	r24, 0x19	; 25
    3796:	ac 01       	movw	r20, r24
    3798:	6f 89       	ldd	r22, Y+23	; 0x17
    379a:	78 8d       	ldd	r23, Y+24	; 0x18
    379c:	ce 01       	movw	r24, r28
    379e:	01 96       	adiw	r24, 0x01	; 1
    37a0:	0e 94 36 16 	call	0x2c6c	; 0x2c6c <vfprintf>
    37a4:	ef 81       	ldd	r30, Y+7	; 0x07
    37a6:	f8 85       	ldd	r31, Y+8	; 0x08
    37a8:	e0 0f       	add	r30, r16
    37aa:	f1 1f       	adc	r31, r17
    37ac:	10 82       	st	Z, r1
    37ae:	2e 96       	adiw	r28, 0x0e	; 14
    37b0:	e4 e0       	ldi	r30, 0x04	; 4
    37b2:	0c 94 e2 19 	jmp	0x33c4	; 0x33c4 <__epilogue_restores__+0x1c>

000037b6 <__ultoa_invert>:
    37b6:	fa 01       	movw	r30, r20
    37b8:	aa 27       	eor	r26, r26
    37ba:	28 30       	cpi	r18, 0x08	; 8
    37bc:	51 f1       	breq	.+84     	; 0x3812 <__ultoa_invert+0x5c>
    37be:	20 31       	cpi	r18, 0x10	; 16
    37c0:	81 f1       	breq	.+96     	; 0x3822 <__ultoa_invert+0x6c>
    37c2:	e8 94       	clt
    37c4:	6f 93       	push	r22
    37c6:	6e 7f       	andi	r22, 0xFE	; 254
    37c8:	6e 5f       	subi	r22, 0xFE	; 254
    37ca:	7f 4f       	sbci	r23, 0xFF	; 255
    37cc:	8f 4f       	sbci	r24, 0xFF	; 255
    37ce:	9f 4f       	sbci	r25, 0xFF	; 255
    37d0:	af 4f       	sbci	r26, 0xFF	; 255
    37d2:	b1 e0       	ldi	r27, 0x01	; 1
    37d4:	3e d0       	rcall	.+124    	; 0x3852 <__ultoa_invert+0x9c>
    37d6:	b4 e0       	ldi	r27, 0x04	; 4
    37d8:	3c d0       	rcall	.+120    	; 0x3852 <__ultoa_invert+0x9c>
    37da:	67 0f       	add	r22, r23
    37dc:	78 1f       	adc	r23, r24
    37de:	89 1f       	adc	r24, r25
    37e0:	9a 1f       	adc	r25, r26
    37e2:	a1 1d       	adc	r26, r1
    37e4:	68 0f       	add	r22, r24
    37e6:	79 1f       	adc	r23, r25
    37e8:	8a 1f       	adc	r24, r26
    37ea:	91 1d       	adc	r25, r1
    37ec:	a1 1d       	adc	r26, r1
    37ee:	6a 0f       	add	r22, r26
    37f0:	71 1d       	adc	r23, r1
    37f2:	81 1d       	adc	r24, r1
    37f4:	91 1d       	adc	r25, r1
    37f6:	a1 1d       	adc	r26, r1
    37f8:	20 d0       	rcall	.+64     	; 0x383a <__ultoa_invert+0x84>
    37fa:	09 f4       	brne	.+2      	; 0x37fe <__ultoa_invert+0x48>
    37fc:	68 94       	set
    37fe:	3f 91       	pop	r19
    3800:	2a e0       	ldi	r18, 0x0A	; 10
    3802:	26 9f       	mul	r18, r22
    3804:	11 24       	eor	r1, r1
    3806:	30 19       	sub	r19, r0
    3808:	30 5d       	subi	r19, 0xD0	; 208
    380a:	31 93       	st	Z+, r19
    380c:	de f6       	brtc	.-74     	; 0x37c4 <__ultoa_invert+0xe>
    380e:	cf 01       	movw	r24, r30
    3810:	08 95       	ret
    3812:	46 2f       	mov	r20, r22
    3814:	47 70       	andi	r20, 0x07	; 7
    3816:	40 5d       	subi	r20, 0xD0	; 208
    3818:	41 93       	st	Z+, r20
    381a:	b3 e0       	ldi	r27, 0x03	; 3
    381c:	0f d0       	rcall	.+30     	; 0x383c <__ultoa_invert+0x86>
    381e:	c9 f7       	brne	.-14     	; 0x3812 <__ultoa_invert+0x5c>
    3820:	f6 cf       	rjmp	.-20     	; 0x380e <__ultoa_invert+0x58>
    3822:	46 2f       	mov	r20, r22
    3824:	4f 70       	andi	r20, 0x0F	; 15
    3826:	40 5d       	subi	r20, 0xD0	; 208
    3828:	4a 33       	cpi	r20, 0x3A	; 58
    382a:	18 f0       	brcs	.+6      	; 0x3832 <__ultoa_invert+0x7c>
    382c:	49 5d       	subi	r20, 0xD9	; 217
    382e:	31 fd       	sbrc	r19, 1
    3830:	40 52       	subi	r20, 0x20	; 32
    3832:	41 93       	st	Z+, r20
    3834:	02 d0       	rcall	.+4      	; 0x383a <__ultoa_invert+0x84>
    3836:	a9 f7       	brne	.-22     	; 0x3822 <__ultoa_invert+0x6c>
    3838:	ea cf       	rjmp	.-44     	; 0x380e <__ultoa_invert+0x58>
    383a:	b4 e0       	ldi	r27, 0x04	; 4
    383c:	a6 95       	lsr	r26
    383e:	97 95       	ror	r25
    3840:	87 95       	ror	r24
    3842:	77 95       	ror	r23
    3844:	67 95       	ror	r22
    3846:	ba 95       	dec	r27
    3848:	c9 f7       	brne	.-14     	; 0x383c <__ultoa_invert+0x86>
    384a:	00 97       	sbiw	r24, 0x00	; 0
    384c:	61 05       	cpc	r22, r1
    384e:	71 05       	cpc	r23, r1
    3850:	08 95       	ret
    3852:	9b 01       	movw	r18, r22
    3854:	ac 01       	movw	r20, r24
    3856:	0a 2e       	mov	r0, r26
    3858:	06 94       	lsr	r0
    385a:	57 95       	ror	r21
    385c:	47 95       	ror	r20
    385e:	37 95       	ror	r19
    3860:	27 95       	ror	r18
    3862:	ba 95       	dec	r27
    3864:	c9 f7       	brne	.-14     	; 0x3858 <__ultoa_invert+0xa2>
    3866:	62 0f       	add	r22, r18
    3868:	73 1f       	adc	r23, r19
    386a:	84 1f       	adc	r24, r20
    386c:	95 1f       	adc	r25, r21
    386e:	a0 1d       	adc	r26, r0
    3870:	08 95       	ret

00003872 <strtod>:
    3872:	a0 e0       	ldi	r26, 0x00	; 0
    3874:	b0 e0       	ldi	r27, 0x00	; 0
    3876:	ef e3       	ldi	r30, 0x3F	; 63
    3878:	fc e1       	ldi	r31, 0x1C	; 28
    387a:	0c 94 be 19 	jmp	0x337c	; 0x337c <__prologue_saves__+0xc>
    387e:	7b 01       	movw	r14, r22
    3880:	61 15       	cp	r22, r1
    3882:	71 05       	cpc	r23, r1
    3884:	21 f0       	breq	.+8      	; 0x388e <strtod+0x1c>
    3886:	db 01       	movw	r26, r22
    3888:	8c 93       	st	X, r24
    388a:	11 96       	adiw	r26, 0x01	; 1
    388c:	9c 93       	st	X, r25
    388e:	ec 01       	movw	r28, r24
    3890:	c9 90       	ld	r12, Y+
    3892:	8e 01       	movw	r16, r28
    3894:	8c 2d       	mov	r24, r12
    3896:	90 e0       	ldi	r25, 0x00	; 0
    3898:	0e 94 86 1d 	call	0x3b0c	; 0x3b0c <isspace>
    389c:	89 2b       	or	r24, r25
    389e:	c1 f7       	brne	.-16     	; 0x3890 <strtod+0x1e>
    38a0:	bd e2       	ldi	r27, 0x2D	; 45
    38a2:	cb 12       	cpse	r12, r27
    38a4:	06 c0       	rjmp	.+12     	; 0x38b2 <strtod+0x40>
    38a6:	fe 01       	movw	r30, r28
    38a8:	c1 90       	ld	r12, Z+
    38aa:	8f 01       	movw	r16, r30
    38ac:	dd 24       	eor	r13, r13
    38ae:	d3 94       	inc	r13
    38b0:	07 c0       	rjmp	.+14     	; 0x38c0 <strtod+0x4e>
    38b2:	fb e2       	ldi	r31, 0x2B	; 43
    38b4:	cf 12       	cpse	r12, r31
    38b6:	03 c0       	rjmp	.+6      	; 0x38be <strtod+0x4c>
    38b8:	de 01       	movw	r26, r28
    38ba:	cd 90       	ld	r12, X+
    38bc:	8d 01       	movw	r16, r26
    38be:	d1 2c       	mov	r13, r1
    38c0:	e8 01       	movw	r28, r16
    38c2:	21 97       	sbiw	r28, 0x01	; 1
    38c4:	43 e0       	ldi	r20, 0x03	; 3
    38c6:	50 e0       	ldi	r21, 0x00	; 0
    38c8:	66 e5       	ldi	r22, 0x56	; 86
    38ca:	71 e0       	ldi	r23, 0x01	; 1
    38cc:	ce 01       	movw	r24, r28
    38ce:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <strncasecmp_P>
    38d2:	89 2b       	or	r24, r25
    38d4:	c9 f4       	brne	.+50     	; 0x3908 <strtod+0x96>
    38d6:	e8 01       	movw	r28, r16
    38d8:	22 96       	adiw	r28, 0x02	; 2
    38da:	45 e0       	ldi	r20, 0x05	; 5
    38dc:	50 e0       	ldi	r21, 0x00	; 0
    38de:	69 e5       	ldi	r22, 0x59	; 89
    38e0:	71 e0       	ldi	r23, 0x01	; 1
    38e2:	ce 01       	movw	r24, r28
    38e4:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <strncasecmp_P>
    38e8:	89 2b       	or	r24, r25
    38ea:	11 f4       	brne	.+4      	; 0x38f0 <strtod+0x7e>
    38ec:	e8 01       	movw	r28, r16
    38ee:	27 96       	adiw	r28, 0x07	; 7
    38f0:	e1 14       	cp	r14, r1
    38f2:	f1 04       	cpc	r15, r1
    38f4:	19 f0       	breq	.+6      	; 0x38fc <strtod+0x8a>
    38f6:	f7 01       	movw	r30, r14
    38f8:	d1 83       	std	Z+1, r29	; 0x01
    38fa:	c0 83       	st	Z, r28
    38fc:	81 2c       	mov	r8, r1
    38fe:	91 2c       	mov	r9, r1
    3900:	90 e8       	ldi	r25, 0x80	; 128
    3902:	d1 10       	cpse	r13, r1
    3904:	f3 c0       	rjmp	.+486    	; 0x3aec <strtod+0x27a>
    3906:	f7 c0       	rjmp	.+494    	; 0x3af6 <strtod+0x284>
    3908:	43 e0       	ldi	r20, 0x03	; 3
    390a:	50 e0       	ldi	r21, 0x00	; 0
    390c:	6e e5       	ldi	r22, 0x5E	; 94
    390e:	71 e0       	ldi	r23, 0x01	; 1
    3910:	ce 01       	movw	r24, r28
    3912:	0e 94 8e 1d 	call	0x3b1c	; 0x3b1c <strncasecmp_P>
    3916:	89 2b       	or	r24, r25
    3918:	51 f4       	brne	.+20     	; 0x392e <strtod+0xbc>
    391a:	e1 14       	cp	r14, r1
    391c:	f1 04       	cpc	r15, r1
    391e:	09 f4       	brne	.+2      	; 0x3922 <strtod+0xb0>
    3920:	e7 c0       	rjmp	.+462    	; 0x3af0 <strtod+0x27e>
    3922:	0e 5f       	subi	r16, 0xFE	; 254
    3924:	1f 4f       	sbci	r17, 0xFF	; 255
    3926:	d7 01       	movw	r26, r14
    3928:	0d 93       	st	X+, r16
    392a:	1c 93       	st	X, r17
    392c:	e1 c0       	rjmp	.+450    	; 0x3af0 <strtod+0x27e>
    392e:	60 e0       	ldi	r22, 0x00	; 0
    3930:	70 e0       	ldi	r23, 0x00	; 0
    3932:	cb 01       	movw	r24, r22
    3934:	c0 e0       	ldi	r28, 0x00	; 0
    3936:	d0 e0       	ldi	r29, 0x00	; 0
    3938:	ec 2d       	mov	r30, r12
    393a:	e0 53       	subi	r30, 0x30	; 48
    393c:	ea 30       	cpi	r30, 0x0A	; 10
    393e:	20 f5       	brcc	.+72     	; 0x3988 <strtod+0x116>
    3940:	fd 2d       	mov	r31, r13
    3942:	f2 60       	ori	r31, 0x02	; 2
    3944:	2d 2d       	mov	r18, r13
    3946:	28 70       	andi	r18, 0x08	; 8
    3948:	d2 fe       	sbrs	r13, 2
    394a:	04 c0       	rjmp	.+8      	; 0x3954 <strtod+0xe2>
    394c:	21 11       	cpse	r18, r1
    394e:	22 c0       	rjmp	.+68     	; 0x3994 <strtod+0x122>
    3950:	21 96       	adiw	r28, 0x01	; 1
    3952:	20 c0       	rjmp	.+64     	; 0x3994 <strtod+0x122>
    3954:	21 11       	cpse	r18, r1
    3956:	21 97       	sbiw	r28, 0x01	; 1
    3958:	a5 e0       	ldi	r26, 0x05	; 5
    395a:	b0 e0       	ldi	r27, 0x00	; 0
    395c:	9b 01       	movw	r18, r22
    395e:	ac 01       	movw	r20, r24
    3960:	0e 94 ef 1d 	call	0x3bde	; 0x3bde <__muluhisi3>
    3964:	66 0f       	add	r22, r22
    3966:	77 1f       	adc	r23, r23
    3968:	88 1f       	adc	r24, r24
    396a:	99 1f       	adc	r25, r25
    396c:	6e 0f       	add	r22, r30
    396e:	71 1d       	adc	r23, r1
    3970:	81 1d       	adc	r24, r1
    3972:	91 1d       	adc	r25, r1
    3974:	68 39       	cpi	r22, 0x98	; 152
    3976:	b9 e9       	ldi	r27, 0x99	; 153
    3978:	7b 07       	cpc	r23, r27
    397a:	8b 07       	cpc	r24, r27
    397c:	b9 e1       	ldi	r27, 0x19	; 25
    397e:	9b 07       	cpc	r25, r27
    3980:	48 f0       	brcs	.+18     	; 0x3994 <strtod+0x122>
    3982:	fd 2d       	mov	r31, r13
    3984:	f6 60       	ori	r31, 0x06	; 6
    3986:	06 c0       	rjmp	.+12     	; 0x3994 <strtod+0x122>
    3988:	ee 3f       	cpi	r30, 0xFE	; 254
    398a:	49 f4       	brne	.+18     	; 0x399e <strtod+0x12c>
    398c:	d3 fc       	sbrc	r13, 3
    398e:	43 c0       	rjmp	.+134    	; 0x3a16 <strtod+0x1a4>
    3990:	fd 2d       	mov	r31, r13
    3992:	f8 60       	ori	r31, 0x08	; 8
    3994:	d8 01       	movw	r26, r16
    3996:	cd 90       	ld	r12, X+
    3998:	8d 01       	movw	r16, r26
    399a:	df 2e       	mov	r13, r31
    399c:	cd cf       	rjmp	.-102    	; 0x3938 <strtod+0xc6>
    399e:	e5 33       	cpi	r30, 0x35	; 53
    39a0:	11 f0       	breq	.+4      	; 0x39a6 <strtod+0x134>
    39a2:	e5 31       	cpi	r30, 0x15	; 21
    39a4:	c1 f5       	brne	.+112    	; 0x3a16 <strtod+0x1a4>
    39a6:	f8 01       	movw	r30, r16
    39a8:	a0 81       	ld	r26, Z
    39aa:	ad 32       	cpi	r26, 0x2D	; 45
    39ac:	19 f4       	brne	.+6      	; 0x39b4 <strtod+0x142>
    39ae:	f0 e1       	ldi	r31, 0x10	; 16
    39b0:	df 2a       	or	r13, r31
    39b2:	07 c0       	rjmp	.+14     	; 0x39c2 <strtod+0x150>
    39b4:	ab 32       	cpi	r26, 0x2B	; 43
    39b6:	29 f0       	breq	.+10     	; 0x39c2 <strtod+0x150>
    39b8:	0f 5f       	subi	r16, 0xFF	; 255
    39ba:	1f 4f       	sbci	r17, 0xFF	; 255
    39bc:	21 e0       	ldi	r18, 0x01	; 1
    39be:	30 e0       	ldi	r19, 0x00	; 0
    39c0:	06 c0       	rjmp	.+12     	; 0x39ce <strtod+0x15c>
    39c2:	f8 01       	movw	r30, r16
    39c4:	a1 81       	ldd	r26, Z+1	; 0x01
    39c6:	0e 5f       	subi	r16, 0xFE	; 254
    39c8:	1f 4f       	sbci	r17, 0xFF	; 255
    39ca:	22 e0       	ldi	r18, 0x02	; 2
    39cc:	30 e0       	ldi	r19, 0x00	; 0
    39ce:	a0 53       	subi	r26, 0x30	; 48
    39d0:	aa 30       	cpi	r26, 0x0A	; 10
    39d2:	18 f0       	brcs	.+6      	; 0x39da <strtod+0x168>
    39d4:	02 1b       	sub	r16, r18
    39d6:	13 0b       	sbc	r17, r19
    39d8:	1e c0       	rjmp	.+60     	; 0x3a16 <strtod+0x1a4>
    39da:	f8 01       	movw	r30, r16
    39dc:	20 e0       	ldi	r18, 0x00	; 0
    39de:	30 e0       	ldi	r19, 0x00	; 0
    39e0:	20 38       	cpi	r18, 0x80	; 128
    39e2:	4c e0       	ldi	r20, 0x0C	; 12
    39e4:	34 07       	cpc	r19, r20
    39e6:	5c f4       	brge	.+22     	; 0x39fe <strtod+0x18c>
    39e8:	a9 01       	movw	r20, r18
    39ea:	44 0f       	add	r20, r20
    39ec:	55 1f       	adc	r21, r21
    39ee:	44 0f       	add	r20, r20
    39f0:	55 1f       	adc	r21, r21
    39f2:	24 0f       	add	r18, r20
    39f4:	35 1f       	adc	r19, r21
    39f6:	22 0f       	add	r18, r18
    39f8:	33 1f       	adc	r19, r19
    39fa:	2a 0f       	add	r18, r26
    39fc:	31 1d       	adc	r19, r1
    39fe:	a1 91       	ld	r26, Z+
    3a00:	a0 53       	subi	r26, 0x30	; 48
    3a02:	8f 01       	movw	r16, r30
    3a04:	aa 30       	cpi	r26, 0x0A	; 10
    3a06:	60 f3       	brcs	.-40     	; 0x39e0 <strtod+0x16e>
    3a08:	d4 fe       	sbrs	r13, 4
    3a0a:	03 c0       	rjmp	.+6      	; 0x3a12 <strtod+0x1a0>
    3a0c:	31 95       	neg	r19
    3a0e:	21 95       	neg	r18
    3a10:	31 09       	sbc	r19, r1
    3a12:	c2 0f       	add	r28, r18
    3a14:	d3 1f       	adc	r29, r19
    3a16:	d1 fe       	sbrs	r13, 1
    3a18:	08 c0       	rjmp	.+16     	; 0x3a2a <strtod+0x1b8>
    3a1a:	e1 14       	cp	r14, r1
    3a1c:	f1 04       	cpc	r15, r1
    3a1e:	29 f0       	breq	.+10     	; 0x3a2a <strtod+0x1b8>
    3a20:	01 50       	subi	r16, 0x01	; 1
    3a22:	11 09       	sbc	r17, r1
    3a24:	d7 01       	movw	r26, r14
    3a26:	0d 93       	st	X+, r16
    3a28:	1c 93       	st	X, r17
    3a2a:	0e 94 ce 14 	call	0x299c	; 0x299c <__floatunsisf>
    3a2e:	2d 2d       	mov	r18, r13
    3a30:	23 70       	andi	r18, 0x03	; 3
    3a32:	23 30       	cpi	r18, 0x03	; 3
    3a34:	19 f0       	breq	.+6      	; 0x3a3c <strtod+0x1ca>
    3a36:	4b 01       	movw	r8, r22
    3a38:	5c 01       	movw	r10, r24
    3a3a:	05 c0       	rjmp	.+10     	; 0x3a46 <strtod+0x1d4>
    3a3c:	dc 01       	movw	r26, r24
    3a3e:	cb 01       	movw	r24, r22
    3a40:	b0 58       	subi	r27, 0x80	; 128
    3a42:	4c 01       	movw	r8, r24
    3a44:	5d 01       	movw	r10, r26
    3a46:	20 e0       	ldi	r18, 0x00	; 0
    3a48:	30 e0       	ldi	r19, 0x00	; 0
    3a4a:	a9 01       	movw	r20, r18
    3a4c:	68 2d       	mov	r22, r8
    3a4e:	79 2d       	mov	r23, r9
    3a50:	8a 2d       	mov	r24, r10
    3a52:	9b 2d       	mov	r25, r11
    3a54:	0e 94 31 14 	call	0x2862	; 0x2862 <__cmpsf2>
    3a58:	88 23       	and	r24, r24
    3a5a:	09 f4       	brne	.+2      	; 0x3a5e <strtod+0x1ec>
    3a5c:	44 c0       	rjmp	.+136    	; 0x3ae6 <strtod+0x274>
    3a5e:	d7 ff       	sbrs	r29, 7
    3a60:	06 c0       	rjmp	.+12     	; 0x3a6e <strtod+0x1fc>
    3a62:	d1 95       	neg	r29
    3a64:	c1 95       	neg	r28
    3a66:	d1 09       	sbc	r29, r1
    3a68:	0d e8       	ldi	r16, 0x8D	; 141
    3a6a:	11 e0       	ldi	r17, 0x01	; 1
    3a6c:	02 c0       	rjmp	.+4      	; 0x3a72 <strtod+0x200>
    3a6e:	05 e7       	ldi	r16, 0x75	; 117
    3a70:	11 e0       	ldi	r17, 0x01	; 1
    3a72:	68 01       	movw	r12, r16
    3a74:	b8 e1       	ldi	r27, 0x18	; 24
    3a76:	cb 1a       	sub	r12, r27
    3a78:	d1 08       	sbc	r13, r1
    3a7a:	90 e2       	ldi	r25, 0x20	; 32
    3a7c:	e9 2e       	mov	r14, r25
    3a7e:	f1 2c       	mov	r15, r1
    3a80:	13 c0       	rjmp	.+38     	; 0x3aa8 <strtod+0x236>
    3a82:	f8 01       	movw	r30, r16
    3a84:	85 91       	lpm	r24, Z+
    3a86:	95 91       	lpm	r25, Z+
    3a88:	a5 91       	lpm	r26, Z+
    3a8a:	b4 91       	lpm	r27, Z
    3a8c:	28 2f       	mov	r18, r24
    3a8e:	39 2f       	mov	r19, r25
    3a90:	4a 2f       	mov	r20, r26
    3a92:	5b 2f       	mov	r21, r27
    3a94:	68 2d       	mov	r22, r8
    3a96:	79 2d       	mov	r23, r9
    3a98:	8a 2d       	mov	r24, r10
    3a9a:	9b 2d       	mov	r25, r11
    3a9c:	0e 94 d3 15 	call	0x2ba6	; 0x2ba6 <__mulsf3>
    3aa0:	4b 01       	movw	r8, r22
    3aa2:	5c 01       	movw	r10, r24
    3aa4:	ce 19       	sub	r28, r14
    3aa6:	df 09       	sbc	r29, r15
    3aa8:	ce 15       	cp	r28, r14
    3aaa:	df 05       	cpc	r29, r15
    3aac:	54 f7       	brge	.-44     	; 0x3a82 <strtod+0x210>
    3aae:	04 50       	subi	r16, 0x04	; 4
    3ab0:	11 09       	sbc	r17, r1
    3ab2:	f5 94       	asr	r15
    3ab4:	e7 94       	ror	r14
    3ab6:	0c 15       	cp	r16, r12
    3ab8:	1d 05       	cpc	r17, r13
    3aba:	b1 f7       	brne	.-20     	; 0x3aa8 <strtod+0x236>
    3abc:	b4 01       	movw	r22, r8
    3abe:	c5 01       	movw	r24, r10
    3ac0:	28 2f       	mov	r18, r24
    3ac2:	22 0f       	add	r18, r18
    3ac4:	29 2f       	mov	r18, r25
    3ac6:	22 1f       	adc	r18, r18
    3ac8:	2f 3f       	cpi	r18, 0xFF	; 255
    3aca:	39 f0       	breq	.+14     	; 0x3ada <strtod+0x268>
    3acc:	20 e0       	ldi	r18, 0x00	; 0
    3ace:	30 e0       	ldi	r19, 0x00	; 0
    3ad0:	a9 01       	movw	r20, r18
    3ad2:	0e 94 31 14 	call	0x2862	; 0x2862 <__cmpsf2>
    3ad6:	81 11       	cpse	r24, r1
    3ad8:	06 c0       	rjmp	.+12     	; 0x3ae6 <strtod+0x274>
    3ada:	82 e2       	ldi	r24, 0x22	; 34
    3adc:	90 e0       	ldi	r25, 0x00	; 0
    3ade:	90 93 0d 08 	sts	0x080D, r25
    3ae2:	80 93 0c 08 	sts	0x080C, r24
    3ae6:	9a 2d       	mov	r25, r10
    3ae8:	8b 2d       	mov	r24, r11
    3aea:	06 c0       	rjmp	.+12     	; 0x3af8 <strtod+0x286>
    3aec:	8f ef       	ldi	r24, 0xFF	; 255
    3aee:	04 c0       	rjmp	.+8      	; 0x3af8 <strtod+0x286>
    3af0:	81 2c       	mov	r8, r1
    3af2:	91 2c       	mov	r9, r1
    3af4:	90 ec       	ldi	r25, 0xC0	; 192
    3af6:	8f e7       	ldi	r24, 0x7F	; 127
    3af8:	9c 01       	movw	r18, r24
    3afa:	68 2d       	mov	r22, r8
    3afc:	79 2d       	mov	r23, r9
    3afe:	83 2f       	mov	r24, r19
    3b00:	92 2f       	mov	r25, r18
    3b02:	cd b7       	in	r28, 0x3d	; 61
    3b04:	de b7       	in	r29, 0x3e	; 62
    3b06:	ec e0       	ldi	r30, 0x0C	; 12
    3b08:	0c 94 da 19 	jmp	0x33b4	; 0x33b4 <__epilogue_restores__+0xc>

00003b0c <isspace>:
    3b0c:	91 11       	cpse	r25, r1
    3b0e:	2e c0       	rjmp	.+92     	; 0x3b6c <__ctype_isfalse>
    3b10:	80 32       	cpi	r24, 0x20	; 32
    3b12:	19 f0       	breq	.+6      	; 0x3b1a <isspace+0xe>
    3b14:	89 50       	subi	r24, 0x09	; 9
    3b16:	85 50       	subi	r24, 0x05	; 5
    3b18:	d0 f7       	brcc	.-12     	; 0x3b0e <isspace+0x2>
    3b1a:	08 95       	ret

00003b1c <strncasecmp_P>:
    3b1c:	fb 01       	movw	r30, r22
    3b1e:	dc 01       	movw	r26, r24
    3b20:	41 50       	subi	r20, 0x01	; 1
    3b22:	50 40       	sbci	r21, 0x00	; 0
    3b24:	88 f0       	brcs	.+34     	; 0x3b48 <strncasecmp_P+0x2c>
    3b26:	8d 91       	ld	r24, X+
    3b28:	81 34       	cpi	r24, 0x41	; 65
    3b2a:	1c f0       	brlt	.+6      	; 0x3b32 <strncasecmp_P+0x16>
    3b2c:	8b 35       	cpi	r24, 0x5B	; 91
    3b2e:	0c f4       	brge	.+2      	; 0x3b32 <strncasecmp_P+0x16>
    3b30:	80 5e       	subi	r24, 0xE0	; 224
    3b32:	65 91       	lpm	r22, Z+
    3b34:	61 34       	cpi	r22, 0x41	; 65
    3b36:	1c f0       	brlt	.+6      	; 0x3b3e <strncasecmp_P+0x22>
    3b38:	6b 35       	cpi	r22, 0x5B	; 91
    3b3a:	0c f4       	brge	.+2      	; 0x3b3e <strncasecmp_P+0x22>
    3b3c:	60 5e       	subi	r22, 0xE0	; 224
    3b3e:	86 1b       	sub	r24, r22
    3b40:	61 11       	cpse	r22, r1
    3b42:	71 f3       	breq	.-36     	; 0x3b20 <strncasecmp_P+0x4>
    3b44:	99 0b       	sbc	r25, r25
    3b46:	08 95       	ret
    3b48:	88 1b       	sub	r24, r24
    3b4a:	fc cf       	rjmp	.-8      	; 0x3b44 <strncasecmp_P+0x28>

00003b4c <strrev>:
    3b4c:	dc 01       	movw	r26, r24
    3b4e:	fc 01       	movw	r30, r24
    3b50:	67 2f       	mov	r22, r23
    3b52:	71 91       	ld	r23, Z+
    3b54:	77 23       	and	r23, r23
    3b56:	e1 f7       	brne	.-8      	; 0x3b50 <strrev+0x4>
    3b58:	32 97       	sbiw	r30, 0x02	; 2
    3b5a:	04 c0       	rjmp	.+8      	; 0x3b64 <strrev+0x18>
    3b5c:	7c 91       	ld	r23, X
    3b5e:	6d 93       	st	X+, r22
    3b60:	70 83       	st	Z, r23
    3b62:	62 91       	ld	r22, -Z
    3b64:	ae 17       	cp	r26, r30
    3b66:	bf 07       	cpc	r27, r31
    3b68:	c8 f3       	brcs	.-14     	; 0x3b5c <strrev+0x10>
    3b6a:	08 95       	ret

00003b6c <__ctype_isfalse>:
    3b6c:	99 27       	eor	r25, r25
    3b6e:	88 27       	eor	r24, r24

00003b70 <__ctype_istrue>:
    3b70:	08 95       	ret

00003b72 <__udivmodhi4>:
    3b72:	aa 1b       	sub	r26, r26
    3b74:	bb 1b       	sub	r27, r27
    3b76:	51 e1       	ldi	r21, 0x11	; 17
    3b78:	07 c0       	rjmp	.+14     	; 0x3b88 <__udivmodhi4_ep>

00003b7a <__udivmodhi4_loop>:
    3b7a:	aa 1f       	adc	r26, r26
    3b7c:	bb 1f       	adc	r27, r27
    3b7e:	a6 17       	cp	r26, r22
    3b80:	b7 07       	cpc	r27, r23
    3b82:	10 f0       	brcs	.+4      	; 0x3b88 <__udivmodhi4_ep>
    3b84:	a6 1b       	sub	r26, r22
    3b86:	b7 0b       	sbc	r27, r23

00003b88 <__udivmodhi4_ep>:
    3b88:	88 1f       	adc	r24, r24
    3b8a:	99 1f       	adc	r25, r25
    3b8c:	5a 95       	dec	r21
    3b8e:	a9 f7       	brne	.-22     	; 0x3b7a <__udivmodhi4_loop>
    3b90:	80 95       	com	r24
    3b92:	90 95       	com	r25
    3b94:	bc 01       	movw	r22, r24
    3b96:	cd 01       	movw	r24, r26
    3b98:	08 95       	ret

00003b9a <__udivmodsi4>:
    3b9a:	a1 e2       	ldi	r26, 0x21	; 33
    3b9c:	1a 2e       	mov	r1, r26
    3b9e:	aa 1b       	sub	r26, r26
    3ba0:	bb 1b       	sub	r27, r27
    3ba2:	fd 01       	movw	r30, r26
    3ba4:	0d c0       	rjmp	.+26     	; 0x3bc0 <__udivmodsi4_ep>

00003ba6 <__udivmodsi4_loop>:
    3ba6:	aa 1f       	adc	r26, r26
    3ba8:	bb 1f       	adc	r27, r27
    3baa:	ee 1f       	adc	r30, r30
    3bac:	ff 1f       	adc	r31, r31
    3bae:	a2 17       	cp	r26, r18
    3bb0:	b3 07       	cpc	r27, r19
    3bb2:	e4 07       	cpc	r30, r20
    3bb4:	f5 07       	cpc	r31, r21
    3bb6:	20 f0       	brcs	.+8      	; 0x3bc0 <__udivmodsi4_ep>
    3bb8:	a2 1b       	sub	r26, r18
    3bba:	b3 0b       	sbc	r27, r19
    3bbc:	e4 0b       	sbc	r30, r20
    3bbe:	f5 0b       	sbc	r31, r21

00003bc0 <__udivmodsi4_ep>:
    3bc0:	66 1f       	adc	r22, r22
    3bc2:	77 1f       	adc	r23, r23
    3bc4:	88 1f       	adc	r24, r24
    3bc6:	99 1f       	adc	r25, r25
    3bc8:	1a 94       	dec	r1
    3bca:	69 f7       	brne	.-38     	; 0x3ba6 <__udivmodsi4_loop>
    3bcc:	60 95       	com	r22
    3bce:	70 95       	com	r23
    3bd0:	80 95       	com	r24
    3bd2:	90 95       	com	r25
    3bd4:	9b 01       	movw	r18, r22
    3bd6:	ac 01       	movw	r20, r24
    3bd8:	bd 01       	movw	r22, r26
    3bda:	cf 01       	movw	r24, r30
    3bdc:	08 95       	ret

00003bde <__muluhisi3>:
    3bde:	0e 94 fa 1d 	call	0x3bf4	; 0x3bf4 <__umulhisi3>
    3be2:	a5 9f       	mul	r26, r21
    3be4:	90 0d       	add	r25, r0
    3be6:	b4 9f       	mul	r27, r20
    3be8:	90 0d       	add	r25, r0
    3bea:	a4 9f       	mul	r26, r20
    3bec:	80 0d       	add	r24, r0
    3bee:	91 1d       	adc	r25, r1
    3bf0:	11 24       	eor	r1, r1
    3bf2:	08 95       	ret

00003bf4 <__umulhisi3>:
    3bf4:	a2 9f       	mul	r26, r18
    3bf6:	b0 01       	movw	r22, r0
    3bf8:	b3 9f       	mul	r27, r19
    3bfa:	c0 01       	movw	r24, r0
    3bfc:	a3 9f       	mul	r26, r19
    3bfe:	01 d0       	rcall	.+2      	; 0x3c02 <__umulhisi3+0xe>
    3c00:	b2 9f       	mul	r27, r18
    3c02:	70 0d       	add	r23, r0
    3c04:	81 1d       	adc	r24, r1
    3c06:	11 24       	eor	r1, r1
    3c08:	91 1d       	adc	r25, r1
    3c0a:	08 95       	ret

00003c0c <_exit>:
    3c0c:	f8 94       	cli

00003c0e <__stop_program>:
    3c0e:	ff cf       	rjmp	.-2      	; 0x3c0e <__stop_program>
